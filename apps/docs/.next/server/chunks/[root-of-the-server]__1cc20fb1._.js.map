{"version":3,"sources":["../../../../../apps/docs/node_modules/.pnpm/image-size%402.0.2/node_modules/image-size/dist/fromFile.mjs"],"sourcesContent":["import * as fs from 'node:fs';\nimport * as path from 'node:path';\n\n// lib/fromFile.ts\n\n// lib/types/utils.ts\nvar decoder = new TextDecoder();\nvar toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));\nvar toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + `0${i.toString(16)}`.slice(-2), \"\");\nvar getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);\nvar readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);\nvar readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);\nvar readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);\nvar readUInt24LE = (input, offset = 0) => {\n  const view = getView(input, offset);\n  return view.getUint16(0, true) + (view.getUint8(2) << 16);\n};\nvar readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);\nvar readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);\nvar readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);\nvar readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);\nvar methods = {\n  readUInt16BE,\n  readUInt16LE,\n  readUInt32BE,\n  readUInt32LE\n};\nfunction readUInt(input, bits, offset = 0, isBigEndian = false) {\n  const endian = isBigEndian ? \"BE\" : \"LE\";\n  const methodName = `readUInt${bits}${endian}`;\n  return methods[methodName](input, offset);\n}\nfunction readBox(input, offset) {\n  if (input.length - offset < 4) return;\n  const boxSize = readUInt32BE(input, offset);\n  if (input.length - offset < boxSize) return;\n  return {\n    name: toUTF8String(input, 4 + offset, 8 + offset),\n    offset,\n    size: boxSize\n  };\n}\nfunction findBox(input, boxName, currentOffset) {\n  while (currentOffset < input.length) {\n    const box = readBox(input, currentOffset);\n    if (!box) break;\n    if (box.name === boxName) return box;\n    currentOffset += box.size > 0 ? box.size : 8;\n  }\n}\n\n// lib/types/bmp.ts\nvar BMP = {\n  validate: (input) => toUTF8String(input, 0, 2) === \"BM\",\n  calculate: (input) => ({\n    height: Math.abs(readInt32LE(input, 22)),\n    width: readUInt32LE(input, 18)\n  })\n};\n\n// lib/types/ico.ts\nvar TYPE_ICON = 1;\nvar SIZE_HEADER = 2 + 2 + 2;\nvar SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;\nfunction getSizeFromOffset(input, offset) {\n  const value = input[offset];\n  return value === 0 ? 256 : value;\n}\nfunction getImageSize(input, imageIndex) {\n  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;\n  return {\n    height: getSizeFromOffset(input, offset + 1),\n    width: getSizeFromOffset(input, offset)\n  };\n}\nvar ICO = {\n  validate(input) {\n    const reserved = readUInt16LE(input, 0);\n    const imageCount = readUInt16LE(input, 4);\n    if (reserved !== 0 || imageCount === 0) return false;\n    const imageType = readUInt16LE(input, 2);\n    return imageType === TYPE_ICON;\n  },\n  calculate(input) {\n    const nbImages = readUInt16LE(input, 4);\n    const imageSize2 = getImageSize(input, 0);\n    if (nbImages === 1) return imageSize2;\n    const images = [];\n    for (let imageIndex = 0; imageIndex < nbImages; imageIndex += 1) {\n      images.push(getImageSize(input, imageIndex));\n    }\n    return {\n      width: imageSize2.width,\n      height: imageSize2.height,\n      images\n    };\n  }\n};\n\n// lib/types/cur.ts\nvar TYPE_CURSOR = 2;\nvar CUR = {\n  validate(input) {\n    const reserved = readUInt16LE(input, 0);\n    const imageCount = readUInt16LE(input, 4);\n    if (reserved !== 0 || imageCount === 0) return false;\n    const imageType = readUInt16LE(input, 2);\n    return imageType === TYPE_CURSOR;\n  },\n  calculate: (input) => ICO.calculate(input)\n};\n\n// lib/types/dds.ts\nvar DDS = {\n  validate: (input) => readUInt32LE(input, 0) === 542327876,\n  calculate: (input) => ({\n    height: readUInt32LE(input, 12),\n    width: readUInt32LE(input, 16)\n  })\n};\n\n// lib/types/gif.ts\nvar gifRegexp = /^GIF8[79]a/;\nvar GIF = {\n  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),\n  calculate: (input) => ({\n    height: readUInt16LE(input, 8),\n    width: readUInt16LE(input, 6)\n  })\n};\n\n// lib/types/heif.ts\nvar brandMap = {\n  avif: \"avif\",\n  mif1: \"heif\",\n  msf1: \"heif\",\n  // heif-sequence\n  heic: \"heic\",\n  heix: \"heic\",\n  hevc: \"heic\",\n  // heic-sequence\n  hevx: \"heic\"\n  // heic-sequence\n};\nvar HEIF = {\n  validate(input) {\n    const boxType = toUTF8String(input, 4, 8);\n    if (boxType !== \"ftyp\") return false;\n    const ftypBox = findBox(input, \"ftyp\", 0);\n    if (!ftypBox) return false;\n    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);\n    return brand in brandMap;\n  },\n  calculate(input) {\n    const metaBox = findBox(input, \"meta\", 0);\n    const iprpBox = metaBox && findBox(input, \"iprp\", metaBox.offset + 12);\n    const ipcoBox = iprpBox && findBox(input, \"ipco\", iprpBox.offset + 8);\n    if (!ipcoBox) {\n      throw new TypeError(\"Invalid HEIF, no ipco box found\");\n    }\n    const type = toUTF8String(input, 8, 12);\n    const images = [];\n    let currentOffset = ipcoBox.offset + 8;\n    while (currentOffset < ipcoBox.offset + ipcoBox.size) {\n      const ispeBox = findBox(input, \"ispe\", currentOffset);\n      if (!ispeBox) break;\n      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);\n      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);\n      const clapBox = findBox(input, \"clap\", currentOffset);\n      let width = rawWidth;\n      let height = rawHeight;\n      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {\n        const cropRight = readUInt32BE(input, clapBox.offset + 12);\n        width = rawWidth - cropRight;\n      }\n      images.push({ height, width });\n      currentOffset = ispeBox.offset + ispeBox.size;\n    }\n    if (images.length === 0) {\n      throw new TypeError(\"Invalid HEIF, no sizes found\");\n    }\n    return {\n      width: images[0].width,\n      height: images[0].height,\n      type,\n      ...images.length > 1 ? { images } : {}\n    };\n  }\n};\n\n// lib/types/icns.ts\nvar SIZE_HEADER2 = 4 + 4;\nvar FILE_LENGTH_OFFSET = 4;\nvar ENTRY_LENGTH_OFFSET = 4;\nvar ICON_TYPE_SIZE = {\n  ICON: 32,\n  \"ICN#\": 32,\n  // m => 16 x 16\n  \"icm#\": 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  \"ics#\": 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024\n};\nfunction readImageHeader(input, imageOffset) {\n  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  return [\n    toUTF8String(input, imageOffset, imageLengthOffset),\n    readUInt32BE(input, imageLengthOffset)\n  ];\n}\nfunction getImageSize2(type) {\n  const size = ICON_TYPE_SIZE[type];\n  return { width: size, height: size, type };\n}\nvar ICNS = {\n  validate: (input) => toUTF8String(input, 0, 4) === \"icns\",\n  calculate(input) {\n    const inputLength = input.length;\n    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);\n    let imageOffset = SIZE_HEADER2;\n    const images = [];\n    while (imageOffset < fileLength && imageOffset < inputLength) {\n      const imageHeader = readImageHeader(input, imageOffset);\n      const imageSize2 = getImageSize2(imageHeader[0]);\n      images.push(imageSize2);\n      imageOffset += imageHeader[1];\n    }\n    if (images.length === 0) {\n      throw new TypeError(\"Invalid ICNS, no sizes found\");\n    }\n    return {\n      width: images[0].width,\n      height: images[0].height,\n      ...images.length > 1 ? { images } : {}\n    };\n  }\n};\n\n// lib/types/j2c.ts\nvar J2C = {\n  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC\n  validate: (input) => readUInt32BE(input, 0) === 4283432785,\n  calculate: (input) => ({\n    height: readUInt32BE(input, 12),\n    width: readUInt32BE(input, 8)\n  })\n};\n\n// lib/types/jp2.ts\nvar JP2 = {\n  validate(input) {\n    const boxType = toUTF8String(input, 4, 8);\n    if (boxType !== \"jP  \") return false;\n    const ftypBox = findBox(input, \"ftyp\", 0);\n    if (!ftypBox) return false;\n    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);\n    return brand === \"jp2 \";\n  },\n  calculate(input) {\n    const jp2hBox = findBox(input, \"jp2h\", 0);\n    const ihdrBox = jp2hBox && findBox(input, \"ihdr\", jp2hBox.offset + 8);\n    if (ihdrBox) {\n      return {\n        height: readUInt32BE(input, ihdrBox.offset + 8),\n        width: readUInt32BE(input, ihdrBox.offset + 12)\n      };\n    }\n    throw new TypeError(\"Unsupported JPEG 2000 format\");\n  }\n};\n\n// lib/types/jpg.ts\nvar EXIF_MARKER = \"45786966\";\nvar APP1_DATA_SIZE_BYTES = 2;\nvar EXIF_HEADER_BYTES = 6;\nvar TIFF_BYTE_ALIGN_BYTES = 2;\nvar BIG_ENDIAN_BYTE_ALIGN = \"4d4d\";\nvar LITTLE_ENDIAN_BYTE_ALIGN = \"4949\";\nvar IDF_ENTRY_BYTES = 12;\nvar NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(input) {\n  return toHexString(input, 2, 6) === EXIF_MARKER;\n}\nfunction extractSize(input, index) {\n  return {\n    height: readUInt16BE(input, index),\n    width: readUInt16BE(input, index + 2)\n  };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n  const idfOffset = 8;\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES;\n    if (start > exifBlock.length) {\n      return;\n    }\n    const block = exifBlock.slice(start, end);\n    const tagNumber = readUInt(block, 16, 0, isBigEndian);\n    if (tagNumber === 274) {\n      const dataFormat = readUInt(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\nfunction validateExifBlock(input, index) {\n  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);\n  const byteAlign = toHexString(\n    exifBlock,\n    EXIF_HEADER_BYTES,\n    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES\n  );\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\nfunction validateInput(input, index) {\n  if (index > input.length) {\n    throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");\n  }\n}\nvar JPG = {\n  validate: (input) => toHexString(input, 0, 2) === \"ffd8\",\n  calculate(_input) {\n    let input = _input.slice(4);\n    let orientation;\n    let next;\n    while (input.length) {\n      const i = readUInt16BE(input, 0);\n      validateInput(input, i);\n      if (input[i] !== 255) {\n        input = input.slice(1);\n        continue;\n      }\n      if (isEXIF(input)) {\n        orientation = validateExifBlock(input, i);\n      }\n      next = input[i + 1];\n      if (next === 192 || next === 193 || next === 194) {\n        const size = extractSize(input, i + 5);\n        if (!orientation) {\n          return size;\n        }\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      }\n      input = input.slice(i + 2);\n    }\n    throw new TypeError(\"Invalid JPG, no size found\");\n  }\n};\n\n// lib/utils/bit-reader.ts\nvar BitReader = class {\n  constructor(input, endianness) {\n    this.input = input;\n    this.endianness = endianness;\n    // Skip the first 16 bits (2 bytes) of signature\n    this.byteOffset = 2;\n    this.bitOffset = 0;\n  }\n  /** Reads a specified number of bits, and move the offset */\n  getBits(length = 1) {\n    let result = 0;\n    let bitsRead = 0;\n    while (bitsRead < length) {\n      if (this.byteOffset >= this.input.length) {\n        throw new Error(\"Reached end of input\");\n      }\n      const currentByte = this.input[this.byteOffset];\n      const bitsLeft = 8 - this.bitOffset;\n      const bitsToRead = Math.min(length - bitsRead, bitsLeft);\n      if (this.endianness === \"little-endian\") {\n        const mask = (1 << bitsToRead) - 1;\n        const bits = currentByte >> this.bitOffset & mask;\n        result |= bits << bitsRead;\n      } else {\n        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;\n        const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;\n        result = result << bitsToRead | bits;\n      }\n      bitsRead += bitsToRead;\n      this.bitOffset += bitsToRead;\n      if (this.bitOffset === 8) {\n        this.byteOffset++;\n        this.bitOffset = 0;\n      }\n    }\n    return result;\n  }\n};\n\n// lib/types/jxl-stream.ts\nfunction calculateImageDimension(reader, isSmallImage) {\n  if (isSmallImage) {\n    return 8 * (1 + reader.getBits(5));\n  }\n  const sizeClass = reader.getBits(2);\n  const extraBits = [9, 13, 18, 30][sizeClass];\n  return 1 + reader.getBits(extraBits);\n}\nfunction calculateImageWidth(reader, isSmallImage, widthMode, height) {\n  if (isSmallImage && widthMode === 0) {\n    return 8 * (1 + reader.getBits(5));\n  }\n  if (widthMode === 0) {\n    return calculateImageDimension(reader, false);\n  }\n  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];\n  return Math.floor(height * aspectRatios[widthMode - 1]);\n}\nvar JXLStream = {\n  validate: (input) => {\n    return toHexString(input, 0, 2) === \"ff0a\";\n  },\n  calculate(input) {\n    const reader = new BitReader(input, \"little-endian\");\n    const isSmallImage = reader.getBits(1) === 1;\n    const height = calculateImageDimension(reader, isSmallImage);\n    const widthMode = reader.getBits(3);\n    const width = calculateImageWidth(reader, isSmallImage, widthMode, height);\n    return { width, height };\n  }\n};\n\n// lib/types/jxl.ts\nfunction extractCodestream(input) {\n  const jxlcBox = findBox(input, \"jxlc\", 0);\n  if (jxlcBox) {\n    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);\n  }\n  const partialStreams = extractPartialStreams(input);\n  if (partialStreams.length > 0) {\n    return concatenateCodestreams(partialStreams);\n  }\n  return void 0;\n}\nfunction extractPartialStreams(input) {\n  const partialStreams = [];\n  let offset = 0;\n  while (offset < input.length) {\n    const jxlpBox = findBox(input, \"jxlp\", offset);\n    if (!jxlpBox) break;\n    partialStreams.push(\n      input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size)\n    );\n    offset = jxlpBox.offset + jxlpBox.size;\n  }\n  return partialStreams;\n}\nfunction concatenateCodestreams(partialCodestreams) {\n  const totalLength = partialCodestreams.reduce(\n    (acc, curr) => acc + curr.length,\n    0\n  );\n  const codestream = new Uint8Array(totalLength);\n  let position = 0;\n  for (const partial of partialCodestreams) {\n    codestream.set(partial, position);\n    position += partial.length;\n  }\n  return codestream;\n}\nvar JXL = {\n  validate: (input) => {\n    const boxType = toUTF8String(input, 4, 8);\n    if (boxType !== \"JXL \") return false;\n    const ftypBox = findBox(input, \"ftyp\", 0);\n    if (!ftypBox) return false;\n    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);\n    return brand === \"jxl \";\n  },\n  calculate(input) {\n    const codestream = extractCodestream(input);\n    if (codestream) return JXLStream.calculate(codestream);\n    throw new Error(\"No codestream found in JXL container\");\n  }\n};\n\n// lib/types/ktx.ts\nvar KTX = {\n  validate: (input) => {\n    const signature = toUTF8String(input, 1, 7);\n    return [\"KTX 11\", \"KTX 20\"].includes(signature);\n  },\n  calculate: (input) => {\n    const type = input[5] === 49 ? \"ktx\" : \"ktx2\";\n    const offset = type === \"ktx\" ? 36 : 20;\n    return {\n      height: readUInt32LE(input, offset + 4),\n      width: readUInt32LE(input, offset),\n      type\n    };\n  }\n};\n\n// lib/types/png.ts\nvar pngSignature = \"PNG\\r\\n\u001a\\n\";\nvar pngImageHeaderChunkName = \"IHDR\";\nvar pngFriedChunkName = \"CgBI\";\nvar PNG = {\n  validate(input) {\n    if (pngSignature === toUTF8String(input, 1, 8)) {\n      let chunkName = toUTF8String(input, 12, 16);\n      if (chunkName === pngFriedChunkName) {\n        chunkName = toUTF8String(input, 28, 32);\n      }\n      if (chunkName !== pngImageHeaderChunkName) {\n        throw new TypeError(\"Invalid PNG\");\n      }\n      return true;\n    }\n    return false;\n  },\n  calculate(input) {\n    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {\n      return {\n        height: readUInt32BE(input, 36),\n        width: readUInt32BE(input, 32)\n      };\n    }\n    return {\n      height: readUInt32BE(input, 20),\n      width: readUInt32BE(input, 16)\n    };\n  }\n};\n\n// lib/types/pnm.ts\nvar PNMTypes = {\n  P1: \"pbm/ascii\",\n  P2: \"pgm/ascii\",\n  P3: \"ppm/ascii\",\n  P4: \"pbm\",\n  P5: \"pgm\",\n  P6: \"ppm\",\n  P7: \"pam\",\n  PF: \"pfm\"\n};\nvar handlers = {\n  default: (lines) => {\n    let dimensions = [];\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line[0] === \"#\") {\n        continue;\n      }\n      dimensions = line.split(\" \");\n      break;\n    }\n    if (dimensions.length === 2) {\n      return {\n        height: Number.parseInt(dimensions[1], 10),\n        width: Number.parseInt(dimensions[0], 10)\n      };\n    }\n    throw new TypeError(\"Invalid PNM\");\n  },\n  pam: (lines) => {\n    const size = {};\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line.length > 16 || line.charCodeAt(0) > 128) {\n        continue;\n      }\n      const [key, value] = line.split(\" \");\n      if (key && value) {\n        size[key.toLowerCase()] = Number.parseInt(value, 10);\n      }\n      if (size.height && size.width) {\n        break;\n      }\n    }\n    if (size.height && size.width) {\n      return {\n        height: size.height,\n        width: size.width\n      };\n    }\n    throw new TypeError(\"Invalid PAM\");\n  }\n};\nvar PNM = {\n  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,\n  calculate(input) {\n    const signature = toUTF8String(input, 0, 2);\n    const type = PNMTypes[signature];\n    const lines = toUTF8String(input, 3).split(/[\\r\\n]+/);\n    const handler = handlers[type] || handlers.default;\n    return handler(lines);\n  }\n};\n\n// lib/types/psd.ts\nvar PSD = {\n  validate: (input) => toUTF8String(input, 0, 4) === \"8BPS\",\n  calculate: (input) => ({\n    height: readUInt32BE(input, 14),\n    width: readUInt32BE(input, 18)\n  })\n};\n\n// lib/types/svg.ts\nvar svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nvar extractorRegExps = {\n  height: /\\sheight=(['\"])([^%]+?)\\1/,\n  root: svgReg,\n  viewbox: /\\sviewBox=(['\"])(.+?)\\1/i,\n  width: /\\swidth=(['\"])([^%]+?)\\1/\n};\nvar INCH_CM = 2.54;\nvar units = {\n  in: 96,\n  cm: 96 / INCH_CM,\n  em: 16,\n  ex: 8,\n  m: 96 / INCH_CM * 100,\n  mm: 96 / INCH_CM / 10,\n  pc: 96 / 72 / 12,\n  pt: 96 / 72,\n  px: 1\n};\nvar unitsReg = new RegExp(\n  `^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join(\"|\")})?$`\n);\nfunction parseLength(len) {\n  const m = unitsReg.exec(len);\n  if (!m) {\n    return void 0;\n  }\n  return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n  const bounds = viewbox.split(\" \");\n  return {\n    height: parseLength(bounds[3]),\n    width: parseLength(bounds[2])\n  };\n}\nfunction parseAttributes(root) {\n  const width = root.match(extractorRegExps.width);\n  const height = root.match(extractorRegExps.height);\n  const viewbox = root.match(extractorRegExps.viewbox);\n  return {\n    height: height && parseLength(height[2]),\n    viewbox: viewbox && parseViewbox(viewbox[2]),\n    width: width && parseLength(width[2])\n  };\n}\nfunction calculateByDimensions(attrs) {\n  return {\n    height: attrs.height,\n    width: attrs.width\n  };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n  const ratio = viewbox.width / viewbox.height;\n  if (attrs.width) {\n    return {\n      height: Math.floor(attrs.width / ratio),\n      width: attrs.width\n    };\n  }\n  if (attrs.height) {\n    return {\n      height: attrs.height,\n      width: Math.floor(attrs.height * ratio)\n    };\n  }\n  return {\n    height: viewbox.height,\n    width: viewbox.width\n  };\n}\nvar SVG = {\n  // Scan only the first kilo-byte to speed up the check on larger files\n  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),\n  calculate(input) {\n    const root = toUTF8String(input).match(extractorRegExps.root);\n    if (root) {\n      const attrs = parseAttributes(root[0]);\n      if (attrs.width && attrs.height) {\n        return calculateByDimensions(attrs);\n      }\n      if (attrs.viewbox) {\n        return calculateByViewbox(attrs, attrs.viewbox);\n      }\n    }\n    throw new TypeError(\"Invalid SVG\");\n  }\n};\n\n// lib/types/tga.ts\nvar TGA = {\n  validate(input) {\n    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;\n  },\n  calculate(input) {\n    return {\n      height: readUInt16LE(input, 14),\n      width: readUInt16LE(input, 12)\n    };\n  }\n};\n\n// lib/types/tiff.ts\nvar CONSTANTS = {\n  TAG: {\n    WIDTH: 256,\n    HEIGHT: 257,\n    COMPRESSION: 259\n  },\n  TYPE: {\n    SHORT: 3,\n    LONG: 4,\n    LONG8: 16\n  },\n  ENTRY_SIZE: {\n    STANDARD: 12,\n    BIG: 20\n  },\n  COUNT_SIZE: {\n    STANDARD: 2,\n    BIG: 8\n  }\n};\nfunction readIFD(input, { isBigEndian, isBigTiff }) {\n  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);\n  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;\n  return input.slice(ifdOffset + entryCountSize);\n}\nfunction readTagValue(input, type, offset, isBigEndian) {\n  switch (type) {\n    case CONSTANTS.TYPE.SHORT:\n      return readUInt(input, 16, offset, isBigEndian);\n    case CONSTANTS.TYPE.LONG:\n      return readUInt(input, 32, offset, isBigEndian);\n    case CONSTANTS.TYPE.LONG8: {\n      const value = Number(readUInt64(input, offset, isBigEndian));\n      if (value > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError(\"Value too large\");\n      }\n      return value;\n    }\n    default:\n      return 0;\n  }\n}\nfunction nextTag(input, isBigTiff) {\n  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;\n  if (input.length > entrySize) {\n    return input.slice(entrySize);\n  }\n}\nfunction extractTags(input, { isBigEndian, isBigTiff }) {\n  const tags = {};\n  let temp = input;\n  while (temp?.length) {\n    const code = readUInt(temp, 16, 0, isBigEndian);\n    const type = readUInt(temp, 16, 2, isBigEndian);\n    const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);\n    if (code === 0) break;\n    if (length === 1 && (type === CONSTANTS.TYPE.SHORT || type === CONSTANTS.TYPE.LONG || isBigTiff && type === CONSTANTS.TYPE.LONG8)) {\n      const valueOffset = isBigTiff ? 12 : 8;\n      tags[code] = readTagValue(temp, type, valueOffset, isBigEndian);\n    }\n    temp = nextTag(temp, isBigTiff);\n  }\n  return tags;\n}\nfunction determineFormat(input) {\n  const signature = toUTF8String(input, 0, 2);\n  const version = readUInt(input, 16, 2, signature === \"MM\");\n  return {\n    isBigEndian: signature === \"MM\",\n    isBigTiff: version === 43\n  };\n}\nfunction validateBigTIFFHeader(input, isBigEndian) {\n  const byteSize = readUInt(input, 16, 4, isBigEndian);\n  const reserved = readUInt(input, 16, 6, isBigEndian);\n  if (byteSize !== 8 || reserved !== 0) {\n    throw new TypeError(\"Invalid BigTIFF header\");\n  }\n}\nvar signatures = /* @__PURE__ */ new Set([\n  \"49492a00\",\n  // Little Endian\n  \"4d4d002a\",\n  // Big Endian\n  \"49492b00\",\n  // BigTIFF Little Endian\n  \"4d4d002b\"\n  // BigTIFF Big Endian\n]);\nvar TIFF = {\n  validate: (input) => {\n    const signature = toHexString(input, 0, 4);\n    return signatures.has(signature);\n  },\n  calculate(input) {\n    const format = determineFormat(input);\n    if (format.isBigTiff) {\n      validateBigTIFFHeader(input, format.isBigEndian);\n    }\n    const ifdBuffer = readIFD(input, format);\n    const tags = extractTags(ifdBuffer, format);\n    const info = {\n      height: tags[CONSTANTS.TAG.HEIGHT],\n      width: tags[CONSTANTS.TAG.WIDTH],\n      type: format.isBigTiff ? \"bigtiff\" : \"tiff\"\n    };\n    if (tags[CONSTANTS.TAG.COMPRESSION]) {\n      info.compression = tags[CONSTANTS.TAG.COMPRESSION];\n    }\n    if (!info.width || !info.height) {\n      throw new TypeError(\"Invalid Tiff. Missing tags\");\n    }\n    return info;\n  }\n};\n\n// lib/types/webp.ts\nfunction calculateExtended(input) {\n  return {\n    height: 1 + readUInt24LE(input, 7),\n    width: 1 + readUInt24LE(input, 4)\n  };\n}\nfunction calculateLossless(input) {\n  return {\n    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),\n    width: 1 + ((input[2] & 63) << 8 | input[1])\n  };\n}\nfunction calculateLossy(input) {\n  return {\n    height: readInt16LE(input, 8) & 16383,\n    width: readInt16LE(input, 6) & 16383\n  };\n}\nvar WEBP = {\n  validate(input) {\n    const riffHeader = \"RIFF\" === toUTF8String(input, 0, 4);\n    const webpHeader = \"WEBP\" === toUTF8String(input, 8, 12);\n    const vp8Header = \"VP8\" === toUTF8String(input, 12, 15);\n    return riffHeader && webpHeader && vp8Header;\n  },\n  calculate(_input) {\n    const chunkHeader = toUTF8String(_input, 12, 16);\n    const input = _input.slice(20, 30);\n    if (chunkHeader === \"VP8X\") {\n      const extendedHeader = input[0];\n      const validStart = (extendedHeader & 192) === 0;\n      const validEnd = (extendedHeader & 1) === 0;\n      if (validStart && validEnd) {\n        return calculateExtended(input);\n      }\n      throw new TypeError(\"Invalid WebP\");\n    }\n    if (chunkHeader === \"VP8 \" && input[0] !== 47) {\n      return calculateLossy(input);\n    }\n    const signature = toHexString(input, 3, 6);\n    if (chunkHeader === \"VP8L\" && signature !== \"9d012a\") {\n      return calculateLossless(input);\n    }\n    throw new TypeError(\"Invalid WebP\");\n  }\n};\n\n// lib/types/index.ts\nvar typeHandlers = /* @__PURE__ */ new Map([\n  [\"bmp\", BMP],\n  [\"cur\", CUR],\n  [\"dds\", DDS],\n  [\"gif\", GIF],\n  [\"heif\", HEIF],\n  [\"icns\", ICNS],\n  [\"ico\", ICO],\n  [\"j2c\", J2C],\n  [\"jp2\", JP2],\n  [\"jpg\", JPG],\n  [\"jxl\", JXL],\n  [\"jxl-stream\", JXLStream],\n  [\"ktx\", KTX],\n  [\"png\", PNG],\n  [\"pnm\", PNM],\n  [\"psd\", PSD],\n  [\"svg\", SVG],\n  [\"tga\", TGA],\n  [\"tiff\", TIFF],\n  [\"webp\", WEBP]\n]);\nvar types = Array.from(typeHandlers.keys());\n\n// lib/detector.ts\nvar firstBytes = /* @__PURE__ */ new Map([\n  [0, \"heif\"],\n  [56, \"psd\"],\n  [66, \"bmp\"],\n  [68, \"dds\"],\n  [71, \"gif\"],\n  [73, \"tiff\"],\n  [77, \"tiff\"],\n  [82, \"webp\"],\n  [105, \"icns\"],\n  [137, \"png\"],\n  [255, \"jpg\"]\n]);\nfunction detector(input) {\n  const byte = input[0];\n  const type = firstBytes.get(byte);\n  if (type && typeHandlers.get(type).validate(input)) {\n    return type;\n  }\n  return types.find((type2) => typeHandlers.get(type2).validate(input));\n}\n\n// lib/lookup.ts\nvar globalOptions = {\n  disabledTypes: []\n};\nfunction imageSize(input) {\n  const type = detector(input);\n  if (typeof type !== \"undefined\") {\n    if (globalOptions.disabledTypes.indexOf(type) > -1) {\n      throw new TypeError(`disabled file type: ${type}`);\n    }\n    const size = typeHandlers.get(type).calculate(input);\n    if (size !== void 0) {\n      size.type = size.type ?? type;\n      if (size.images && size.images.length > 1) {\n        const largestImage = size.images.reduce((largest, current) => {\n          return current.width * current.height > largest.width * largest.height ? current : largest;\n        }, size.images[0]);\n        size.width = largestImage.width;\n        size.height = largestImage.height;\n      }\n      return size;\n    }\n  }\n  throw new TypeError(`unsupported file type: ${type}`);\n}\n\n// lib/fromFile.ts\nvar MaxInputSize = 512 * 1024;\nvar queue = [];\nvar concurrency = 100;\nvar setConcurrency = (c) => {\n  concurrency = c;\n};\nvar processQueue = async () => {\n  const jobs = queue.splice(0, concurrency);\n  const promises2 = jobs.map(async ({ filePath, resolve: resolve2, reject }) => {\n    let handle;\n    try {\n      handle = await fs.promises.open(path.resolve(filePath), \"r\");\n    } catch (err) {\n      return reject(err);\n    }\n    try {\n      const { size } = await handle.stat();\n      if (size <= 0) {\n        throw new Error(\"Empty file\");\n      }\n      const inputSize = Math.min(size, MaxInputSize);\n      const input = new Uint8Array(inputSize);\n      await handle.read(input, 0, inputSize, 0);\n      resolve2(imageSize(input));\n    } catch (err) {\n      reject(err);\n    } finally {\n      await handle.close();\n    }\n  });\n  await Promise.allSettled(promises2);\n  if (queue.length) setTimeout(processQueue, 100);\n};\nvar imageSizeFromFile = async (filePath) => new Promise((resolve2, reject) => {\n  queue.push({ filePath, resolve: resolve2, reject });\n  processQueue();\n});\n\nexport { imageSizeFromFile, setConcurrency };\n"],"names":[],"mappings":"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","ignoreList":[0]}