{"version":3,"sources":["../../../../../../apps/docs/node_modules/.pnpm/%40fumari%2Bjson-schema-to-typescript%402.0.0_prettier%403.6.2/node_modules/%40fumari/json-schema-to-typescript/dist/chunk-6FNC3XMI.js","../../../../../../apps/docs/node_modules/.pnpm/%40fumari%2Bjson-schema-to-typescript%402.0.0_prettier%403.6.2/node_modules/%40fumari/json-schema-to-typescript/dist/chunk-HXIR7QLA.js","../../../../../../apps/docs/node_modules/.pnpm/%40fumari%2Bjson-schema-to-typescript%402.0.0_prettier%403.6.2/node_modules/%40fumari/json-schema-to-typescript/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nexport {\n  __spreadValues,\n  __spreadProps,\n  __async\n};\n","import {\n  __spreadValues\n} from \"./chunk-6FNC3XMI.js\";\n\n// src/types/JSONSchema.ts\nvar Parent = Symbol(\"Parent\");\nvar Types = Symbol(\"Types\");\nvar Intersection = Symbol(\"Intersection\");\nfunction getRootSchema(schema) {\n  const parent = schema[Parent];\n  if (!parent) {\n    return schema;\n  }\n  return getRootSchema(parent);\n}\nfunction isBoolean(schema) {\n  return schema === true || schema === false;\n}\nfunction isPrimitive(schema) {\n  return !isPlainObject(schema);\n}\nfunction isCompound(schema) {\n  return Array.isArray(schema.type) || \"anyOf\" in schema || \"oneOf\" in schema;\n}\n\n// src/utils.ts\nvar BLACKLISTED_KEYS = /* @__PURE__ */ new Set([\n  \"id\",\n  \"$defs\",\n  \"$id\",\n  \"$schema\",\n  \"title\",\n  \"description\",\n  \"default\",\n  \"multipleOf\",\n  \"maximum\",\n  \"exclusiveMaximum\",\n  \"minimum\",\n  \"exclusiveMinimum\",\n  \"maxLength\",\n  \"minLength\",\n  \"pattern\",\n  \"additionalItems\",\n  \"items\",\n  \"maxItems\",\n  \"minItems\",\n  \"uniqueItems\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"required\",\n  \"additionalProperties\",\n  \"definitions\",\n  \"properties\",\n  \"patternProperties\",\n  \"dependencies\",\n  \"enum\",\n  \"type\",\n  \"allOf\",\n  \"anyOf\",\n  \"oneOf\",\n  \"not\"\n]);\nfunction traverseObjectKeys(obj, callback, processed) {\n  Object.keys(obj).forEach((k) => {\n    if (obj[k] && typeof obj[k] === \"object\" && !Array.isArray(obj[k])) {\n      traverse(obj[k], callback, processed, k);\n    }\n  });\n}\nfunction traverseArray(arr, callback, processed) {\n  arr.forEach((s, k) => traverse(s, callback, processed, k.toString()));\n}\nfunction traverseIntersection(schema, callback, processed) {\n  if (typeof schema !== \"object\" || !schema) {\n    return;\n  }\n  const r = schema;\n  const intersection = r[Intersection];\n  if (!intersection) {\n    return;\n  }\n  if (Array.isArray(intersection.allOf)) {\n    traverseArray(intersection.allOf, callback, processed);\n  }\n}\nfunction traverse(schema, callback, processed = /* @__PURE__ */ new Set(), key) {\n  if (processed.has(schema)) {\n    return;\n  }\n  processed.add(schema);\n  callback(schema, key != null ? key : null);\n  if (schema.anyOf) {\n    traverseArray(schema.anyOf, callback, processed);\n  }\n  if (schema.allOf) {\n    traverseArray(schema.allOf, callback, processed);\n  }\n  if (schema.oneOf) {\n    traverseArray(schema.oneOf, callback, processed);\n  }\n  if (schema.properties) {\n    traverseObjectKeys(schema.properties, callback, processed);\n  }\n  if (schema.patternProperties) {\n    traverseObjectKeys(schema.patternProperties, callback, processed);\n  }\n  if (schema.additionalProperties && typeof schema.additionalProperties === \"object\") {\n    traverse(schema.additionalProperties, callback, processed);\n  }\n  if (schema.items) {\n    const { items } = schema;\n    if (Array.isArray(items)) {\n      traverseArray(items, callback, processed);\n    } else {\n      traverse(items, callback, processed);\n    }\n  }\n  if (schema.additionalItems && typeof schema.additionalItems === \"object\") {\n    traverse(schema.additionalItems, callback, processed);\n  }\n  if (schema.dependencies) {\n    if (Array.isArray(schema.dependencies)) {\n      traverseArray(schema.dependencies, callback, processed);\n    } else {\n      traverseObjectKeys(schema.dependencies, callback, processed);\n    }\n  }\n  if (schema.definitions) {\n    traverseObjectKeys(schema.definitions, callback, processed);\n  }\n  if (schema.$defs) {\n    traverseObjectKeys(schema.$defs, callback, processed);\n  }\n  if (schema.not) {\n    traverse(schema.not, callback, processed);\n  }\n  traverseIntersection(schema, callback, processed);\n  Object.keys(schema).filter((key2) => !BLACKLISTED_KEYS.has(key2)).forEach((key2) => {\n    const child = schema[key2];\n    if (child && typeof child === \"object\") {\n      traverseObjectKeys(child, callback, processed);\n    }\n  });\n}\nfunction toSafeString(str) {\n  const value = str.normalize().replace(/[^a-zA-Z0-9_$]/g, \" \").replace(/(^\\w|\\s+\\w|_\\w|\\d\\w)/g, (letter) => {\n    if (letter.startsWith(\"_\")) return letter.slice(1).toUpperCase();\n    return letter.trim().toUpperCase();\n  }).replace(/\\s+/g, \"\").replace(/^\\d+/, \"\");\n  return value;\n}\nfunction generateName(from, usedNames) {\n  let name = toSafeString(from);\n  if (!name) {\n    name = \"NoName\";\n  }\n  if (usedNames.has(name)) {\n    let counter = 1;\n    let nameWithCounter = `${name}${counter}`;\n    while (usedNames.has(nameWithCounter)) {\n      nameWithCounter = `${name}${counter}`;\n      counter++;\n    }\n    name = nameWithCounter;\n  }\n  usedNames.add(name);\n  return name;\n}\nfunction error(...messages) {\n  console.error(\"[error]\", ...messages);\n}\nfunction log(title, ...messages) {\n  if (!process.env.VERBOSE) {\n    return;\n  }\n  let lastMessage = null;\n  if (messages.length > 1 && typeof messages[messages.length - 1] !== \"string\") {\n    lastMessage = messages.splice(messages.length - 1, 1);\n  }\n  console.info(`[debug]`, title, ...messages);\n  if (lastMessage) {\n    console.dir(lastMessage, { depth: 6, maxArrayLength: 6 });\n  }\n}\nfunction escapeBlockComment(schema) {\n  const replacer = \"* /\";\n  if (schema === null || typeof schema !== \"object\") {\n    return;\n  }\n  for (const key of Object.keys(schema)) {\n    if (key === \"description\" && typeof schema[key] === \"string\") {\n      schema[key] = schema[key].replace(/\\*\\//g, replacer);\n    }\n  }\n}\nfunction maybeStripDefault(schema) {\n  if (!(\"default\" in schema)) {\n    return schema;\n  }\n  switch (schema.type) {\n    case \"array\":\n      if (Array.isArray(schema.default)) {\n        return schema;\n      }\n      break;\n    case \"boolean\":\n      if (typeof schema.default === \"boolean\") {\n        return schema;\n      }\n      break;\n    case \"integer\":\n    case \"number\":\n      if (typeof schema.default === \"number\") {\n        return schema;\n      }\n      break;\n    case \"string\":\n      if (typeof schema.default === \"string\") {\n        return schema;\n      }\n      break;\n    case \"null\":\n      if (schema.default === null) {\n        return schema;\n      }\n      break;\n    case \"object\":\n      if (isPlainObject(schema.default)) {\n        return schema;\n      }\n      break;\n  }\n  delete schema.default;\n  return schema;\n}\nfunction appendToDescription(existingDescription, ...values) {\n  if (existingDescription) {\n    return `${existingDescription}\n\n${values.join(\"\\n\")}`;\n  }\n  return values.join(\"\\n\");\n}\nfunction isSchemaLike(schema) {\n  if (!isPlainObject(schema) || !schema || typeof schema !== \"object\") {\n    return false;\n  }\n  const parent = schema[Parent];\n  if (parent === null) {\n    return true;\n  }\n  const JSON_SCHEMA_KEYWORDS = [\n    \"$defs\",\n    \"allOf\",\n    \"anyOf\",\n    \"definitions\",\n    \"dependencies\",\n    \"enum\",\n    \"not\",\n    \"oneOf\",\n    \"patternProperties\",\n    \"properties\",\n    \"required\"\n  ];\n  if (JSON_SCHEMA_KEYWORDS.some((_) => parent[_] === schema)) {\n    return false;\n  }\n  return true;\n}\nfunction omit(obj, ...keys) {\n  const result = __spreadValues({}, obj);\n  for (const key of keys) {\n    delete result[key];\n  }\n  return result;\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.prototype.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor === \"function\" && Ctor instanceof Ctor && Function.prototype.toString.call(Ctor) === Function.prototype.toString.call(Object);\n}\nfunction deepMerge(target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isPlainObject(target) && isPlainObject(source)) {\n    const _target = target;\n    for (const key in source) {\n      if (isPlainObject(source[key])) {\n        if (!(key in target) || typeof _target[key] !== \"object\") Object.assign(_target, { [key]: {} });\n        deepMerge(_target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n      if (Array.isArray(source[key])) {\n        if (!Array.isArray(_target[key])) _target[key] = [];\n        const arr = _target[key];\n        arr.push(source[key]);\n      }\n    }\n  }\n  return deepMerge(target, ...sources);\n}\n\nexport {\n  Parent,\n  Types,\n  Intersection,\n  getRootSchema,\n  isBoolean,\n  isPrimitive,\n  isCompound,\n  traverse,\n  toSafeString,\n  generateName,\n  error,\n  log,\n  escapeBlockComment,\n  maybeStripDefault,\n  appendToDescription,\n  isSchemaLike,\n  omit,\n  isPlainObject,\n  deepMerge\n};\n","import {\n  Intersection,\n  Parent,\n  Types,\n  appendToDescription,\n  deepMerge,\n  error,\n  escapeBlockComment,\n  generateName,\n  getRootSchema,\n  isBoolean,\n  isCompound,\n  isPlainObject,\n  isPrimitive,\n  isSchemaLike,\n  log,\n  maybeStripDefault,\n  omit,\n  toSafeString,\n  traverse\n} from \"./chunk-HXIR7QLA.js\";\nimport {\n  __async,\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-6FNC3XMI.js\";\n\n// src/types/AST.ts\nfunction hasComment(ast) {\n  return \"comment\" in ast && ast.comment != null && ast.comment !== \"\" || // Compare to true because ast.deprecated might be undefined\n  \"deprecated\" in ast && ast.deprecated === true;\n}\nfunction hasStandaloneName(ast) {\n  return \"standaloneName\" in ast && ast.standaloneName != null && ast.standaloneName !== \"\";\n}\nvar T_ANY = {\n  type: \"ANY\"\n};\nvar T_NULL = {\n  type: \"NULL\"\n};\nvar T_ANY_ADDITIONAL_PROPERTIES = {\n  keyName: \"[k: string]\",\n  type: \"ANY\"\n};\nvar T_UNKNOWN = {\n  type: \"UNKNOWN\"\n};\nvar T_UNKNOWN_ADDITIONAL_PROPERTIES = {\n  keyName: \"[k: string]\",\n  type: \"UNKNOWN\"\n};\n\n// src/generator.ts\nfunction generate(ast, options = DEFAULT_OPTIONS) {\n  return [\n    options.bannerComment,\n    declareNamedTypes(ast, options, ast.standaloneName),\n    declareNamedInterfaces(ast, options, ast.standaloneName),\n    declareEnums(ast, options)\n  ].filter(Boolean).join(\"\\n\\n\") + \"\\n\";\n}\nfunction declareEnums(ast, options, processed = /* @__PURE__ */ new Set()) {\n  if (processed.has(ast)) {\n    return \"\";\n  }\n  processed.add(ast);\n  let type = \"\";\n  switch (ast.type) {\n    case \"ENUM\":\n      return generateStandaloneEnum(ast, options) + \"\\n\";\n    case \"ARRAY\":\n      return declareEnums(ast.params, options, processed);\n    case \"UNION\":\n    case \"INTERSECTION\":\n      return ast.params.reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), \"\");\n    case \"TUPLE\":\n      type = ast.params.reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), \"\");\n      if (ast.spreadParam) {\n        type += declareEnums(ast.spreadParam, options, processed);\n      }\n      return type;\n    case \"INTERFACE\":\n      return getSuperTypesAndParams(ast).reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), \"\");\n    default:\n      return \"\";\n  }\n}\nfunction declareNamedInterfaces(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {\n  if (processed.has(ast)) {\n    return \"\";\n  }\n  processed.add(ast);\n  let type = \"\";\n  switch (ast.type) {\n    case \"ARRAY\":\n      type = declareNamedInterfaces(ast.params, options, rootASTName, processed);\n      break;\n    case \"INTERFACE\":\n      type = [\n        hasStandaloneName(ast) && (ast.standaloneName === rootASTName || options.declareExternallyReferenced) && generateStandaloneInterface(ast, options),\n        getSuperTypesAndParams(ast).map((ast2) => declareNamedInterfaces(ast2, options, rootASTName, processed)).filter(Boolean).join(\"\\n\")\n      ].filter(Boolean).join(\"\\n\");\n      break;\n    case \"INTERSECTION\":\n    case \"TUPLE\":\n    case \"UNION\":\n      type = ast.params.map((_) => declareNamedInterfaces(_, options, rootASTName, processed)).filter(Boolean).join(\"\\n\");\n      if (ast.type === \"TUPLE\" && ast.spreadParam) {\n        type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);\n      }\n      break;\n    default:\n      type = \"\";\n  }\n  return type;\n}\nfunction declareNamedTypes(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {\n  if (processed.has(ast)) {\n    return \"\";\n  }\n  processed.add(ast);\n  switch (ast.type) {\n    case \"ARRAY\":\n      return [\n        declareNamedTypes(ast.params, options, rootASTName, processed),\n        hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0\n      ].filter(Boolean).join(\"\\n\");\n    case \"ENUM\":\n      return \"\";\n    case \"INTERFACE\":\n      return getSuperTypesAndParams(ast).map(\n        (ast2) => (ast2.standaloneName === rootASTName || options.declareExternallyReferenced) && declareNamedTypes(ast2, options, rootASTName, processed)\n      ).filter(Boolean).join(\"\\n\");\n    case \"INTERSECTION\":\n    case \"TUPLE\":\n    case \"UNION\":\n      return [\n        hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0,\n        ast.params.map((ast2) => declareNamedTypes(ast2, options, rootASTName, processed)).filter(Boolean).join(\"\\n\"),\n        \"spreadParam\" in ast && ast.spreadParam ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed) : void 0\n      ].filter(Boolean).join(\"\\n\");\n    default:\n      if (hasStandaloneName(ast)) {\n        return generateStandaloneType(ast, options);\n      }\n      return \"\";\n  }\n}\nfunction generateType(ast, options) {\n  const type = generateRawType(ast, options);\n  if (options.strictIndexSignatures && ast.keyName === \"[k: string]\" && ast.type !== \"UNKNOWN\" && ast.type !== \"ANY\") {\n    return `${type} | undefined`;\n  }\n  return type;\n}\nfunction generateRawType(ast, options) {\n  log(\"generator\", ast);\n  if (hasStandaloneName(ast)) {\n    return toSafeString(ast.standaloneName);\n  }\n  switch (ast.type) {\n    case \"ANY\":\n      return \"any\";\n    case \"ARRAY\":\n      return (() => {\n        const type = generateType(ast.params, options);\n        return type.endsWith('\"') ? \"(\" + type + \")[]\" : type + \"[]\";\n      })();\n    case \"BOOLEAN\":\n      return \"boolean\";\n    case \"INTERFACE\":\n      return generateInterface(ast, options);\n    case \"INTERSECTION\":\n      return generateSetOperation(ast, options);\n    case \"LITERAL\":\n      return JSON.stringify(ast.params);\n    case \"NEVER\":\n      return \"never\";\n    case \"NUMBER\":\n      return \"number\";\n    case \"NULL\":\n      return \"null\";\n    case \"OBJECT\":\n      return \"object\";\n    case \"REFERENCE\":\n      return ast.params;\n    case \"STRING\":\n      return \"string\";\n    case \"TUPLE\":\n      return (() => {\n        const minItems = ast.minItems;\n        const maxItems = ast.maxItems || -1;\n        let spreadParam = ast.spreadParam;\n        const astParams = [...ast.params];\n        if (minItems > 0 && minItems > astParams.length && ast.spreadParam === void 0) {\n          if (maxItems < 0) {\n            spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;\n          }\n        }\n        if (maxItems > astParams.length && ast.spreadParam === void 0) {\n          for (let i = astParams.length; i < maxItems; i += 1) {\n            astParams.push(options.unknownAny ? T_UNKNOWN : T_ANY);\n          }\n        }\n        function addSpreadParam(params) {\n          if (spreadParam) {\n            const spread = \"...(\" + generateType(spreadParam, options) + \")[]\";\n            params.push(spread);\n          }\n          return params;\n        }\n        function paramsToString(params) {\n          return \"[\" + params.join(\", \") + \"]\";\n        }\n        const paramsList = astParams.map((param) => generateType(param, options));\n        if (paramsList.length > minItems) {\n          const cumulativeParamsList = paramsList.slice(0, minItems);\n          const typesToUnion = [];\n          if (cumulativeParamsList.length > 0) {\n            typesToUnion.push(paramsToString(cumulativeParamsList));\n          } else {\n            typesToUnion.push(paramsToString([]));\n          }\n          for (let i = minItems; i < paramsList.length; i += 1) {\n            cumulativeParamsList.push(paramsList[i]);\n            if (i === paramsList.length - 1) {\n              addSpreadParam(cumulativeParamsList);\n            }\n            typesToUnion.push(paramsToString(cumulativeParamsList));\n          }\n          return typesToUnion.join(\"|\");\n        }\n        return paramsToString(addSpreadParam(paramsList));\n      })();\n    case \"UNION\":\n      return generateSetOperation(ast, options);\n    case \"UNKNOWN\":\n      return \"unknown\";\n    case \"CUSTOM_TYPE\":\n      return ast.params;\n  }\n}\nfunction generateSetOperation(ast, options) {\n  const members = ast.params.map((_) => generateType(_, options));\n  const separator = ast.type === \"UNION\" ? \"|\" : \"&\";\n  return members.length === 1 ? members[0] : \"(\" + members.join(\" \" + separator + \" \") + \")\";\n}\nfunction generateInterface(ast, options) {\n  return `{\n` + ast.params.filter((_) => !_.isPatternProperty && !_.isUnreachableDefinition).map(\n    ({ isRequired, keyName, ast: ast2 }) => [isRequired, keyName, ast2, generateType(ast2, options)]\n  ).map(\n    ([isRequired, keyName, ast2, type]) => (hasComment(ast2) && !ast2.standaloneName ? generateComment(ast2.comment, ast2.deprecated) + \"\\n\" : \"\") + escapeKeyName(keyName) + (isRequired ? \"\" : \"?\") + \": \" + type\n  ).join(\"\\n\") + \"\\n}\";\n}\nfunction generateComment(comment, deprecated) {\n  const commentLines = [\"/**\"];\n  if (deprecated) {\n    commentLines.push(\" * @deprecated\");\n  }\n  if (typeof comment !== \"undefined\") {\n    commentLines.push(...comment.split(\"\\n\").map((_) => \" * \" + _));\n  }\n  commentLines.push(\" */\");\n  return commentLines.join(\"\\n\");\n}\nfunction generateStandaloneEnum(ast, options) {\n  return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + \"\\n\" : \"\") + \"export \" + (options.enableConstEnums ? \"const \" : \"\") + `enum ${toSafeString(ast.standaloneName)} {\n` + ast.params.map(({ ast: ast2, keyName }) => keyName + \" = \" + generateType(ast2, options)).join(\",\\n\") + \"\\n}\";\n}\nfunction generateStandaloneInterface(ast, options) {\n  return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + \"\\n\" : \"\") + `export interface ${toSafeString(ast.standaloneName)} ` + (ast.superTypes.length > 0 ? `extends ${ast.superTypes.map((superType) => toSafeString(superType.standaloneName)).join(\", \")} ` : \"\") + generateInterface(ast, options);\n}\nfunction generateStandaloneType(ast, options) {\n  return (hasComment(ast) ? generateComment(ast.comment) + \"\\n\" : \"\") + `export type ${toSafeString(ast.standaloneName)} = ${generateType(\n    omit(ast, \"standaloneName\"),\n    options\n  )}`;\n}\nfunction escapeKeyName(keyName) {\n  if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\\w$]+$/.test(keyName)) {\n    return keyName;\n  }\n  if (keyName === \"[k: string]\") {\n    return keyName;\n  }\n  return JSON.stringify(keyName);\n}\nfunction getSuperTypesAndParams(ast) {\n  return ast.params.map((param) => param.ast).concat(ast.superTypes);\n}\n\n// src/typesOfSchema.ts\nfunction typesOfSchema(schema) {\n  if (schema.tsType) {\n    return /* @__PURE__ */ new Set([\"CUSTOM_TYPE\"]);\n  }\n  const matchedTypes = /* @__PURE__ */ new Set();\n  for (const [schemaType, f] of Object.entries(matchers)) {\n    if (f(schema)) {\n      matchedTypes.add(schemaType);\n    }\n  }\n  if (!matchedTypes.size) {\n    matchedTypes.add(\"UNNAMED_SCHEMA\");\n  }\n  return matchedTypes;\n}\nvar matchers = {\n  ALL_OF(schema) {\n    return \"allOf\" in schema;\n  },\n  ANY(schema) {\n    if (Object.keys(schema).length === 0) {\n      return true;\n    }\n    return schema.type === \"any\";\n  },\n  ANY_OF(schema) {\n    return \"anyOf\" in schema;\n  },\n  BOOLEAN(schema) {\n    if (\"enum\" in schema) {\n      return false;\n    }\n    if (schema.type === \"boolean\") {\n      return true;\n    }\n    if (!isCompound(schema) && typeof schema.default === \"boolean\") {\n      return true;\n    }\n    return false;\n  },\n  CUSTOM_TYPE() {\n    return false;\n  },\n  NAMED_ENUM(schema) {\n    return \"enum\" in schema && \"tsEnumNames\" in schema;\n  },\n  NAMED_SCHEMA(schema) {\n    return \"$id\" in schema && (\"patternProperties\" in schema || \"properties\" in schema);\n  },\n  NEVER(schema) {\n    return schema === false;\n  },\n  NULL(schema) {\n    return schema.type === \"null\";\n  },\n  NUMBER(schema) {\n    if (\"enum\" in schema) {\n      return false;\n    }\n    if (schema.type === \"integer\" || schema.type === \"number\") {\n      return true;\n    }\n    if (!isCompound(schema) && typeof schema.default === \"number\") {\n      return true;\n    }\n    return false;\n  },\n  OBJECT(schema) {\n    return schema.type === \"object\" && !isPlainObject(schema.additionalProperties) && !schema.allOf && !schema.anyOf && !schema.oneOf && !schema.patternProperties && !schema.properties && !schema.required;\n  },\n  ONE_OF(schema) {\n    return \"oneOf\" in schema;\n  },\n  REFERENCE(schema) {\n    return \"$ref\" in schema;\n  },\n  STRING(schema) {\n    if (\"enum\" in schema) {\n      return false;\n    }\n    if (schema.type === \"string\") {\n      return true;\n    }\n    if (!isCompound(schema) && typeof schema.default === \"string\") {\n      return true;\n    }\n    return false;\n  },\n  TYPED_ARRAY(schema) {\n    if (schema.type && schema.type !== \"array\") {\n      return false;\n    }\n    return \"items\" in schema;\n  },\n  UNION(schema) {\n    return Array.isArray(schema.type);\n  },\n  UNNAMED_ENUM(schema) {\n    if (\"tsEnumNames\" in schema) {\n      return false;\n    }\n    if (schema.type && schema.type !== \"boolean\" && schema.type !== \"integer\" && schema.type !== \"number\" && schema.type !== \"string\") {\n      return false;\n    }\n    return \"enum\" in schema;\n  },\n  UNNAMED_SCHEMA() {\n    return false;\n  },\n  UNTYPED_ARRAY(schema) {\n    return schema.type === \"array\" && !(\"items\" in schema);\n  }\n};\n\n// src/applySchemaTyping.ts\nfunction applySchemaTyping(schema) {\n  var _a;\n  const types = typesOfSchema(schema);\n  Object.assign(schema, {\n    [Types]: types\n  });\n  if (types.size === 1) {\n    return;\n  }\n  const intersection = {\n    [Parent]: schema,\n    [Types]: /* @__PURE__ */ new Set([\"ALL_OF\"]),\n    $id: schema.$id,\n    description: schema.description,\n    name: schema.name,\n    title: schema.title,\n    allOf: (_a = schema.allOf) != null ? _a : [],\n    required: [],\n    additionalProperties: false\n  };\n  types.delete(\"ALL_OF\");\n  delete schema.allOf;\n  delete schema.$id;\n  delete schema.description;\n  delete schema.name;\n  delete schema.title;\n  Object.assign(schema, {\n    [Intersection]: intersection\n  });\n}\n\n// src/normalizer.ts\nvar rules = /* @__PURE__ */ new Map();\nfunction hasType(schema, type) {\n  return schema.type === type || Array.isArray(schema.type) && schema.type.includes(type);\n}\nfunction isObjectType(schema) {\n  return schema.properties !== void 0 || hasType(schema, \"object\") || hasType(schema, \"any\");\n}\nfunction isArrayType(schema) {\n  return schema.items !== void 0 || hasType(schema, \"array\") || hasType(schema, \"any\");\n}\nfunction isEnumTypeWithoutTsEnumNames(schema) {\n  return schema.type === \"string\" && schema.enum !== void 0 && schema.tsEnumNames === void 0;\n}\nfunction normalizeName(filename) {\n  const name = filename.split(\"/\").at(-1);\n  if (!name) return filename;\n  const dotIdx = name.lastIndexOf(\".\");\n  if (dotIdx === -1) return name;\n  return name.slice(0, dotIdx);\n}\nrules.set('Remove `type=[\"null\"]` if `enum=[null]`', (schema) => {\n  if (Array.isArray(schema.enum) && schema.enum.some((e) => e === null) && Array.isArray(schema.type) && schema.type.includes(\"null\")) {\n    schema.type = schema.type.filter((type) => type !== \"null\");\n  }\n});\nrules.set('Convert nullable to type: [..., \"null\"]', (schema) => {\n  if (schema.nullable && schema.type !== void 0) {\n    if (!Array.isArray(schema.type)) {\n      schema.type = [schema.type];\n    }\n    schema.type.push(\"null\");\n    delete schema.nullable;\n  }\n});\nrules.set(\"Destructure unary types\", (schema) => {\n  if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {\n    schema.type = schema.type[0];\n  }\n});\nrules.set(\"Add empty `required` property if none is defined\", (schema) => {\n  if (isObjectType(schema) && !(\"required\" in schema)) {\n    schema.required = [];\n  }\n});\nrules.set(\"Transform `required`=false to `required`=[]\", (schema) => {\n  if (schema.required === false) {\n    schema.required = [];\n  }\n});\nrules.set(\"Default additionalProperties\", (schema, _, options) => {\n  if (isObjectType(schema) && !(\"additionalProperties\" in schema) && schema.patternProperties === void 0) {\n    schema.additionalProperties = options.additionalProperties;\n  }\n});\nrules.set(\"Transform id to $id\", (schema, fileName) => {\n  if (!isSchemaLike(schema)) {\n    return;\n  }\n  if (schema.id && schema.$id && schema.id !== schema.$id) {\n    throw ReferenceError(\n      `Schema must define either id or $id, not both. Given id=${schema.id}, $id=${schema.$id} in ${fileName}`\n    );\n  }\n  if (schema.id) {\n    schema.$id = schema.id;\n    delete schema.id;\n  }\n});\nrules.set(\"Add an $id to anything that needs it\", (schema, fileName, _options, _key, dereferencedPaths) => {\n  if (!isSchemaLike(schema)) {\n    return;\n  }\n  if (!schema.$id && !schema[Parent]) {\n    schema.$id = toSafeString(normalizeName(fileName));\n    return;\n  }\n  if (!dereferencedPaths) return;\n  if (!isArrayType(schema) && !isObjectType(schema)) {\n    return;\n  }\n  const dereferencedName = dereferencedPaths.get(schema);\n  if (!schema.$id && !schema.title && dereferencedName) {\n    schema.$id = toSafeString(normalizeName(dereferencedName));\n  }\n});\nrules.set(\"Escape closing JSDoc comment\", (schema) => {\n  escapeBlockComment(schema);\n});\nrules.set(\"Add JSDoc comments for minItems and maxItems\", (schema) => {\n  if (!isArrayType(schema)) {\n    return;\n  }\n  const commentsToAppend = [\n    \"minItems\" in schema ? `@minItems ${schema.minItems}` : \"\",\n    \"maxItems\" in schema ? `@maxItems ${schema.maxItems}` : \"\"\n  ].filter(Boolean);\n  if (commentsToAppend.length) {\n    schema.description = appendToDescription(schema.description, ...commentsToAppend);\n  }\n});\nrules.set(\"Optionally remove maxItems and minItems\", (schema, _fileName, options) => {\n  if (!isArrayType(schema)) {\n    return;\n  }\n  if (\"minItems\" in schema && options.ignoreMinAndMaxItems) {\n    delete schema.minItems;\n  }\n  if (\"maxItems\" in schema && (options.ignoreMinAndMaxItems || options.maxItems === -1)) {\n    delete schema.maxItems;\n  }\n});\nrules.set(\"Normalize schema.minItems\", (schema, _fileName, options) => {\n  if (options.ignoreMinAndMaxItems) {\n    return;\n  }\n  if (!isArrayType(schema)) {\n    return;\n  }\n  const { minItems } = schema;\n  schema.minItems = typeof minItems === \"number\" ? minItems : 0;\n});\nrules.set(\"Remove maxItems if it is big enough to likely cause OOMs\", (schema, _fileName, options) => {\n  if (options.ignoreMinAndMaxItems || options.maxItems === -1) {\n    return;\n  }\n  if (!isArrayType(schema)) {\n    return;\n  }\n  const { maxItems, minItems } = schema;\n  if (maxItems !== void 0 && maxItems - minItems > options.maxItems) {\n    delete schema.maxItems;\n  }\n});\nrules.set(\"Normalize schema.items\", (schema, _fileName, options) => {\n  if (options.ignoreMinAndMaxItems) {\n    return;\n  }\n  const { maxItems, minItems } = schema;\n  const hasMaxItems = typeof maxItems === \"number\" && maxItems >= 0;\n  const hasMinItems = typeof minItems === \"number\" && minItems > 0;\n  if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {\n    const items = schema.items;\n    const newItems = Array(maxItems || minItems || 0).fill(items);\n    if (!hasMaxItems) {\n      schema.additionalItems = items;\n    }\n    schema.items = newItems;\n  }\n  if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {\n    schema.items = schema.items.slice(0, maxItems);\n  }\n  return schema;\n});\nrules.set(\"Remove extends, if it is empty\", (schema) => {\n  if (!schema.hasOwnProperty(\"extends\")) {\n    return;\n  }\n  if (schema.extends == null || Array.isArray(schema.extends) && schema.extends.length === 0) {\n    delete schema.extends;\n  }\n});\nrules.set(\"Make extends always an array, if it is defined\", (schema) => {\n  if (schema.extends == null) {\n    return;\n  }\n  if (!Array.isArray(schema.extends)) {\n    schema.extends = [schema.extends];\n  }\n});\nrules.set(\"Transform definitions to $defs\", (schema, fileName) => {\n  if (schema.definitions && schema.$defs) {\n    throw ReferenceError(\n      `Schema must define either definitions or $defs, not both. Given id=${schema.id} in ${fileName}`\n    );\n  }\n  if (schema.definitions) {\n    schema.$defs = schema.definitions;\n    delete schema.definitions;\n  }\n});\nrules.set(\"Transform const to singleton enum\", (schema) => {\n  if (schema.const !== void 0) {\n    schema.enum = [schema.const];\n    delete schema.const;\n  }\n});\nrules.set(\"Add tsEnumNames to enum types\", (schema, _, options) => {\n  var _a;\n  if (isEnumTypeWithoutTsEnumNames(schema) && options.inferStringEnumKeysFromValues) {\n    schema.tsEnumNames = (_a = schema.enum) == null ? void 0 : _a.map(String);\n  }\n});\nrules.set(\"Pre-calculate schema types and intersections\", (schema) => {\n  if (schema !== null && typeof schema === \"object\") {\n    applySchemaTyping(schema);\n  }\n});\nfunction normalize(input, filename, options) {\n  rules.forEach((rule) => traverse(input.schema, (schema, key) => rule(schema, filename, options, key, input.schemaToId)));\n  return input.schema;\n}\n\n// src/optimizer.ts\nfunction optimize(ast, options, processed = /* @__PURE__ */ new Set()) {\n  if (processed.has(ast)) {\n    return ast;\n  }\n  processed.add(ast);\n  switch (ast.type) {\n    case \"ARRAY\":\n      return Object.assign(ast, {\n        params: optimize(ast.params, options, processed)\n      });\n    case \"INTERFACE\":\n      return Object.assign(ast, {\n        params: ast.params.map((_) => Object.assign(_, { ast: optimize(_.ast, options, processed) }))\n      });\n    case \"INTERSECTION\":\n    case \"UNION\":\n      const optimizedAST = Object.assign(ast, {\n        params: ast.params.map((_) => optimize(_, options, processed))\n      });\n      if (optimizedAST.params.some((_) => _.type === \"ANY\")) {\n        log(\"optimizer\", \"[A, B, C, Any] -> Any\", optimizedAST);\n        return T_ANY;\n      }\n      if (optimizedAST.params.some((_) => _.type === \"UNKNOWN\")) {\n        log(\"optimizer\", \"[A, B, C, Unknown] -> Unknown\", optimizedAST);\n        return T_UNKNOWN;\n      }\n      if (optimizedAST.params.every((_) => {\n        const a = generateType(omitStandaloneName(_), options);\n        const b = generateType(omitStandaloneName(optimizedAST.params[0]), options);\n        return a === b;\n      }) && optimizedAST.params.some((_) => _.standaloneName !== void 0)) {\n        log(\"optimizer\", \"[A (named), A] -> [A (named)]\", optimizedAST);\n        optimizedAST.params = optimizedAST.params.filter((_) => _.standaloneName !== void 0);\n      }\n      const params = deduplicate(optimizedAST.params, (item) => generateType(item, options));\n      if (params.length !== optimizedAST.params.length) {\n        log(\"optimizer\", \"[A, B, B] -> [A, B]\", optimizedAST);\n        optimizedAST.params = params;\n      }\n      return Object.assign(optimizedAST, {\n        params: optimizedAST.params.map((_) => optimize(_, options, processed))\n      });\n    default:\n      return ast;\n  }\n}\nfunction omitStandaloneName(ast) {\n  switch (ast.type) {\n    case \"ENUM\":\n      return ast;\n    default:\n      return __spreadProps(__spreadValues({}, ast), { standaloneName: void 0 });\n  }\n}\nfunction deduplicate(asts, hasher) {\n  const out = [];\n  const added = /* @__PURE__ */ new Set();\n  for (const item of asts) {\n    const hash = hasher(item);\n    if (added.has(hash)) continue;\n    added.add(hash);\n    out.push(item);\n  }\n  return out;\n}\n\n// src/parser.ts\nfunction parse(schema, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {\n  if (isPrimitive(schema)) {\n    if (isBoolean(schema)) {\n      return parseBooleanSchema(schema, keyName, options);\n    }\n    return parseLiteral(schema, keyName);\n  }\n  const intersection = schema[Intersection];\n  const types = schema[Types];\n  if (intersection) {\n    const ast = parseAsTypeWithCache(intersection, \"ALL_OF\", options, keyName, processed, usedNames);\n    types.forEach((type) => {\n      ast.params.push(parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames));\n    });\n    log(\"parser\", \"Types:\", [...types], \"Input:\", schema, \"Output:\", ast);\n    return ast;\n  }\n  if (types.size === 1) {\n    const type = [...types][0];\n    const ast = parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames);\n    log(\"parser\", \"Type:\", type, \"Input:\", schema, \"Output:\", ast);\n    return ast;\n  }\n  throw new ReferenceError(\"Expected intersection schema. Please file an issue on GitHub.\");\n}\nfunction parseAsTypeWithCache(schema, type, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {\n  let cachedTypeMap = processed.get(schema);\n  if (!cachedTypeMap) {\n    cachedTypeMap = /* @__PURE__ */ new Map();\n    processed.set(schema, cachedTypeMap);\n  }\n  const cachedAST = cachedTypeMap.get(type);\n  if (cachedAST) {\n    return cachedAST;\n  }\n  const ast = {};\n  cachedTypeMap.set(type, ast);\n  return Object.assign(ast, parseNonLiteral(schema, type, options, keyName, processed, usedNames));\n}\nfunction parseBooleanSchema(schema, keyName, options) {\n  if (schema) {\n    return {\n      keyName,\n      type: options.unknownAny ? \"UNKNOWN\" : \"ANY\"\n    };\n  }\n  return {\n    keyName,\n    type: \"NEVER\"\n  };\n}\nfunction parseLiteral(schema, keyName) {\n  return {\n    keyName,\n    params: schema,\n    type: \"LITERAL\"\n  };\n}\nfunction parseNonLiteral(schema, type, options, keyName, processed, usedNames) {\n  const definitions = getDefinitions(getRootSchema(schema));\n  const keyNameFromDefinition = Array.from(Object.keys(definitions)).find((k) => definitions[k] === schema);\n  switch (type) {\n    case \"ALL_OF\": {\n      const hasNullable = schema.allOf.some((s) => s.nullable && s.type === void 0);\n      const params = schema.allOf.filter((s) => !s.nullable || s.type !== void 0).map((_) => parse(_, options, void 0, processed, usedNames));\n      const baseAst = {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options)\n      };\n      if (!hasNullable) {\n        return __spreadProps(__spreadValues({}, baseAst), {\n          type: \"INTERSECTION\",\n          params\n        });\n      }\n      if (params.length === 0) {\n        return __spreadProps(__spreadValues({}, baseAst), {\n          type: \"NULL\"\n        });\n      } else if (params.length === 1) {\n        return __spreadProps(__spreadValues({}, baseAst), {\n          type: \"UNION\",\n          params: [params[0], T_NULL]\n        });\n      } else {\n        return __spreadProps(__spreadValues({}, baseAst), {\n          type: \"UNION\",\n          params: [\n            {\n              type: \"INTERSECTION\",\n              params\n            },\n            T_NULL\n          ]\n        });\n      }\n    }\n    case \"ANY\":\n      return __spreadProps(__spreadValues({}, options.unknownAny ? T_UNKNOWN : T_ANY), {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options)\n      });\n    case \"ANY_OF\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        params: schema.anyOf.map((_) => parse(_, options, void 0, processed, usedNames)),\n        type: \"UNION\"\n      };\n    case \"BOOLEAN\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"BOOLEAN\"\n      };\n    case \"CUSTOM_TYPE\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        params: schema.tsType,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"CUSTOM_TYPE\"\n      };\n    case \"NAMED_ENUM\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition != null ? keyNameFromDefinition : keyName, usedNames, options),\n        params: schema.enum.map((_, n) => ({\n          ast: parseLiteral(_, void 0),\n          keyName: schema.tsEnumNames[n]\n        })),\n        type: \"ENUM\"\n      };\n    case \"NAMED_SCHEMA\":\n      return newInterface(schema, options, processed, usedNames, keyName);\n    case \"NEVER\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"NEVER\"\n      };\n    case \"NULL\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"NULL\"\n      };\n    case \"NUMBER\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"NUMBER\"\n      };\n    case \"OBJECT\":\n      return {\n        comment: schema.description,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"OBJECT\",\n        deprecated: schema.deprecated\n      };\n    case \"ONE_OF\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        params: schema.oneOf.map((_) => parse(_, options, void 0, processed, usedNames)),\n        type: \"UNION\"\n      };\n    case \"REFERENCE\":\n      throw Error(\"Refs should have been resolved by the resolver!\");\n    case \"STRING\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"STRING\"\n      };\n    case \"TYPED_ARRAY\":\n      if (Array.isArray(schema.items)) {\n        const minItems = schema.minItems;\n        const maxItems = schema.maxItems;\n        const arrayType = {\n          comment: schema.description,\n          deprecated: schema.deprecated,\n          keyName,\n          maxItems,\n          minItems,\n          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n          params: schema.items.map((_) => parse(_, options, void 0, processed, usedNames)),\n          type: \"TUPLE\"\n        };\n        if (schema.additionalItems === true) {\n          arrayType.spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;\n        } else if (schema.additionalItems) {\n          arrayType.spreadParam = parse(schema.additionalItems, options, void 0, processed, usedNames);\n        }\n        return arrayType;\n      } else {\n        return {\n          comment: schema.description,\n          deprecated: schema.deprecated,\n          keyName,\n          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n          params: parse(schema.items, options, `{keyNameFromDefinition}Items`, processed, usedNames),\n          type: \"ARRAY\"\n        };\n      }\n    case \"UNION\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        params: schema.type.map((type2) => {\n          const member = __spreadProps(__spreadValues({}, omit(schema, \"$id\", \"description\", \"title\")), { type: type2 });\n          maybeStripDefault(member);\n          applySchemaTyping(member);\n          return parse(member, options, void 0, processed, usedNames);\n        }),\n        type: \"UNION\"\n      };\n    case \"UNNAMED_ENUM\":\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        params: schema.enum.map((_) => parseLiteral(_, void 0)),\n        type: \"UNION\"\n      };\n    case \"UNNAMED_SCHEMA\":\n      return newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition);\n    case \"UNTYPED_ARRAY\": {\n      const minItems = schema.minItems;\n      const maxItems = typeof schema.maxItems === \"number\" ? schema.maxItems : -1;\n      const params = options.unknownAny ? T_UNKNOWN : T_ANY;\n      if (minItems > 0 || maxItems >= 0) {\n        return {\n          comment: schema.description,\n          deprecated: schema.deprecated,\n          keyName,\n          maxItems: schema.maxItems,\n          minItems,\n          // create a tuple of length N\n          params: Array(Math.max(maxItems, minItems) || 0).fill(params),\n          // if there is no maximum, then add a spread item to collect the rest\n          spreadParam: maxItems >= 0 ? void 0 : params,\n          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n          type: \"TUPLE\"\n        };\n      }\n      return {\n        comment: schema.description,\n        deprecated: schema.deprecated,\n        keyName,\n        params,\n        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),\n        type: \"ARRAY\"\n      };\n    }\n  }\n}\nfunction standaloneName(schema, keyNameFromDefinition, usedNames, options) {\n  var _a;\n  const name = ((_a = options.customName) == null ? void 0 : _a.call(options, schema, keyNameFromDefinition)) || schema.title || schema.$id || keyNameFromDefinition;\n  if (name) {\n    return generateName(name, usedNames);\n  }\n}\nfunction newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition) {\n  const name = standaloneName(schema, keyNameFromDefinition, usedNames, options);\n  return {\n    comment: schema.description,\n    deprecated: schema.deprecated,\n    keyName,\n    params: parseSchema(schema, options, processed, usedNames, name),\n    standaloneName: name,\n    superTypes: parseSuperTypes(schema, options, processed, usedNames),\n    type: \"INTERFACE\"\n  };\n}\nfunction parseSuperTypes(schema, options, processed, usedNames) {\n  const superTypes = schema.extends;\n  if (!superTypes) {\n    return [];\n  }\n  return superTypes.map((_) => parse(_, options, void 0, processed, usedNames));\n}\nfunction parseSchema(schema, options, processed, usedNames, parentSchemaName) {\n  var _a, _b;\n  let asts = Array.from(Object.entries((_a = schema.properties) != null ? _a : {})).map(([key, value]) => {\n    var _a2;\n    return {\n      ast: parse(value, options, key, processed, usedNames),\n      isPatternProperty: false,\n      isRequired: ((_a2 = schema.required) != null ? _a2 : []).includes(key),\n      isUnreachableDefinition: false,\n      keyName: key\n    };\n  });\n  let singlePatternProperty = false;\n  if (schema.patternProperties) {\n    singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;\n    asts = asts.concat(\n      Array.from(Object.entries(schema.patternProperties)).map(([key, value]) => {\n        var _a2;\n        const ast = parse(value, options, key, processed, usedNames);\n        const comment = `This interface was referenced by \\`${parentSchemaName}\\`'s JSON-Schema definition\nvia the \\`patternProperty\\` \"${key.replace(\"*/\", \"*\\\\/\")}\".`;\n        ast.comment = ast.comment ? `${ast.comment}\n\n${comment}` : comment;\n        return {\n          ast,\n          isPatternProperty: !singlePatternProperty,\n          isRequired: singlePatternProperty || ((_a2 = schema.required) != null ? _a2 : []).includes(key),\n          isUnreachableDefinition: false,\n          keyName: singlePatternProperty ? \"[k: string]\" : key\n        };\n      })\n    );\n  }\n  if (options.unreachableDefinitions) {\n    asts = asts.concat(\n      Array.from(Object.entries((_b = schema.$defs) != null ? _b : {})).map(([key, value]) => {\n        var _a2;\n        const ast = parse(value, options, key, processed, usedNames);\n        const comment = `This interface was referenced by \\`${parentSchemaName}\\`'s JSON-Schema\nvia the \\`definition\\` \"${key}\".`;\n        ast.comment = ast.comment ? `${ast.comment}\n\n${comment}` : comment;\n        return {\n          ast,\n          isPatternProperty: false,\n          isRequired: ((_a2 = schema.required) != null ? _a2 : []).includes(key),\n          isUnreachableDefinition: true,\n          keyName: key\n        };\n      })\n    );\n  }\n  switch (schema.additionalProperties) {\n    case void 0:\n    case true:\n      if (singlePatternProperty) {\n        return asts;\n      }\n      return asts.concat({\n        ast: options.unknownAny ? T_UNKNOWN_ADDITIONAL_PROPERTIES : T_ANY_ADDITIONAL_PROPERTIES,\n        isPatternProperty: false,\n        isRequired: true,\n        isUnreachableDefinition: false,\n        keyName: \"[k: string]\"\n      });\n    case false:\n      return asts;\n    // pass \"true\" as the last param because in TS, properties\n    // defined via index signatures are already optional\n    default:\n      return asts.concat({\n        ast: parse(schema.additionalProperties, options, \"[k: string]\", processed, usedNames),\n        isPatternProperty: false,\n        isRequired: true,\n        isUnreachableDefinition: false,\n        keyName: \"[k: string]\"\n      });\n  }\n}\nvar cacheList = [];\nfunction getDefinitions(schema, isSchema = true, processed = /* @__PURE__ */ new Set()) {\n  var _a;\n  if (processed.has(schema)) {\n    return {};\n  }\n  const cached = (_a = cacheList.findLast((item) => item[0] === schema)) == null ? void 0 : _a[1];\n  if (cached) return cached;\n  let result = {};\n  processed.add(schema);\n  if (Array.isArray(schema)) {\n    result = schema.reduce(\n      (prev, cur) => __spreadValues(__spreadValues({}, prev), getDefinitions(cur, false, processed)),\n      {}\n    );\n  } else if (isPlainObject(schema)) {\n    result = __spreadValues(__spreadValues({}, isSchema && hasDefinitions(schema) ? schema.$defs : {}), Object.keys(schema).reduce(\n      (prev, cur) => __spreadValues(__spreadValues({}, prev), getDefinitions(schema[cur], false, processed)),\n      {}\n    ));\n  }\n  cacheList.push([schema, result]);\n  if (cacheList.length > 100) cacheList.shift();\n  return result;\n}\nfunction hasDefinitions(schema) {\n  return \"$defs\" in schema;\n}\n\n// src/validator.ts\nvar rules2 = /* @__PURE__ */ new Map();\nrules2.set(\"Enum members and tsEnumNames must be of the same length\", (schema) => {\n  if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {\n    return false;\n  }\n});\nrules2.set(\"tsEnumNames must be an array of strings\", (schema) => {\n  if (schema.tsEnumNames && schema.tsEnumNames.some((_) => typeof _ !== \"string\")) {\n    return false;\n  }\n});\nrules2.set(\"When both maxItems and minItems are present, maxItems >= minItems\", (schema) => {\n  const { maxItems, minItems } = schema;\n  if (typeof maxItems === \"number\" && typeof minItems === \"number\") {\n    return maxItems >= minItems;\n  }\n});\nrules2.set(\"When maxItems exists, maxItems >= 0\", (schema) => {\n  const { maxItems } = schema;\n  if (typeof maxItems === \"number\") {\n    return maxItems >= 0;\n  }\n});\nrules2.set(\"When minItems exists, minItems >= 0\", (schema) => {\n  const { minItems } = schema;\n  if (typeof minItems === \"number\") {\n    return minItems >= 0;\n  }\n});\nrules2.set(\"deprecated must be a boolean\", (schema) => {\n  const typeOfDeprecated = typeof schema.deprecated;\n  return typeOfDeprecated === \"boolean\" || typeOfDeprecated === \"undefined\";\n});\nfunction validate({ schema }, filename) {\n  const errors = [];\n  rules2.forEach((rule, ruleName) => {\n    traverse(schema, (schema2, key) => {\n      if (rule(schema2) === false) {\n        errors.push(`Error at key \"${key}\" in file \"${filename}\": ${ruleName}`);\n      }\n      return schema2;\n    });\n  });\n  return errors;\n}\n\n// src/linker.ts\nfunction link(schema, parent = null) {\n  if (!Array.isArray(schema) && !isPlainObject(schema)) {\n    return schema;\n  }\n  if (schema.hasOwnProperty(Parent)) {\n    return schema;\n  }\n  if (schema)\n    Object.assign(schema, {\n      [Parent]: parent\n    });\n  if (Array.isArray(schema)) {\n    schema.forEach((child) => link(child, schema));\n  }\n  for (const key in schema) {\n    link(schema[key], schema);\n  }\n  return schema;\n}\n\n// src/optionValidator.ts\nfunction validateOptions({ maxItems }) {\n  if (maxItems !== void 0 && maxItems < -1) {\n    throw RangeError(`Expected options.maxItems to be >= -1, but was given ${maxItems}.`);\n  }\n}\n\n// src/index.ts\nvar DEFAULT_OPTIONS = {\n  additionalProperties: false,\n  bannerComment: \"\",\n  declareExternallyReferenced: true,\n  enableConstEnums: true,\n  inferStringEnumKeysFromValues: false,\n  ignoreMinAndMaxItems: false,\n  maxItems: 20,\n  strictIndexSignatures: false,\n  plugins: [],\n  unreachableDefinitions: false,\n  unknownAny: true\n};\nfunction compileJsonFile(file, name, options = DEFAULT_OPTIONS) {\n  let schema;\n  try {\n    schema = JSON.parse(getContent(file));\n  } catch (e) {\n    throw new TypeError(`Error parsing JSON in \"${name}\"`, { cause: e });\n  }\n  return compile(schema, name, options);\n}\nfunction getContent(file) {\n  return file.toString();\n}\nfunction compileYamlFile(_0, _1) {\n  return __async(this, arguments, function* (file, name, options = DEFAULT_OPTIONS) {\n    let schema;\n    try {\n      const { load } = yield import(\"js-yaml\");\n      schema = yield load(getContent(file));\n    } catch (e) {\n      throw new TypeError(`Error parsing YML in \"${name}\"`, { cause: e });\n    }\n    return compile(schema, name, options);\n  });\n}\nfunction compile(_0, _1) {\n  return __async(this, arguments, function* (schema, name, compileOptions = {}) {\n    var _a, _b, _c, _d, _e, _f;\n    validateOptions(compileOptions);\n    let options = deepMerge({}, DEFAULT_OPTIONS, compileOptions);\n    for (const plugin of options.plugins) {\n      options = (_b = yield (_a = plugin.config) == null ? void 0 : _a.call(plugin, options)) != null ? _b : options;\n    }\n    let input = { schema, schemaToId: options.schemaToId };\n    for (const plugin of options.plugins) {\n      input = (_d = yield (_c = plugin.input) == null ? void 0 : _c.call(plugin, input)) != null ? _d : input;\n    }\n    const linked = { schema: link(input.schema), schemaToId: input.schemaToId };\n    const errors = validate(linked, name);\n    if (errors.length) {\n      errors.forEach((_) => error(_));\n      throw new ValidationError();\n    }\n    const normalized = normalize(linked, name, options);\n    const parsed = parse(normalized, options);\n    const optimized = optimize(parsed, options);\n    let output = generate(optimized, options);\n    for (const plugin of options.plugins) {\n      output = (_f = yield (_e = plugin.output) == null ? void 0 : _e.call(plugin, output)) != null ? _f : output;\n    }\n    return output;\n  });\n}\nvar ValidationError = class extends Error {\n};\nexport {\n  DEFAULT_OPTIONS,\n  ValidationError,\n  compile,\n  compileJsonFile,\n  compileYamlFile\n};\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}