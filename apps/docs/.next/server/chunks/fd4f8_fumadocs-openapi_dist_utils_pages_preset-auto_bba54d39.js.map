{"version":3,"sources":["../../../../../apps/docs/node_modules/.pnpm/fumadocs-openapi%4010.0.11_%40types%2Breact-dom%4019.2.3_%40types%2Breact%4019.2.6__%40types%2Breact%4019.2_9ef6bace3a0bb159887c545478466d7a/node_modules/fumadocs-openapi/dist/utils/pages/preset-auto.js","../../../../../apps/docs/node_modules/.pnpm/fumadocs-openapi%4010.0.11_%40types%2Breact-dom%4019.2.3_%40types%2Breact%4019.2.6__%40types%2Breact%4019.2_9ef6bace3a0bb159887c545478466d7a/node_modules/fumadocs-openapi/dist/utils/url.js"],"sourcesContent":["import * as path from 'node:path';\nimport { isUrl } from '../../utils/url.js';\nexport function createAutoPreset(options) {\n    if (options.per === 'custom')\n        return options;\n    const { slugify = (s) => {\n        return s.replace(/\\s+/g, '-').toLowerCase();\n    }, } = options;\n    let nameFn;\n    if (typeof options.name === 'function') {\n        nameFn = options.name;\n    }\n    else {\n        const { algorithm = 'v2' } = options.name ?? {};\n        nameFn = function (result, document) {\n            if (result.type === 'tag') {\n                return slugify(result.tag);\n            }\n            if (result.type === 'group') {\n                const schemaId = result.schemaId;\n                return isUrl(schemaId)\n                    ? 'index'\n                    : path.basename(schemaId, path.extname(schemaId));\n            }\n            if (result.type === 'operation') {\n                const operation = document.paths[result.item.path][result.item.method];\n                if (algorithm === 'v2' && operation.operationId) {\n                    return operation.operationId;\n                }\n                return path.join(this.routePathToFilePath(result.item.path), result.item.method.toLowerCase());\n            }\n            const hook = document.webhooks[result.item.name][result.item.method];\n            if (algorithm === 'v2' && hook.operationId) {\n                return hook.operationId;\n            }\n            return slugify(result.item.name);\n        };\n    }\n    function groupOutput(builder, entry) {\n        const { dereferenced } = builder.document;\n        const { groupBy = 'none' } = options;\n        if (groupBy === 'route') {\n            return [\n                path.join(builder.routePathToFilePath(entry.type === 'operation' ? entry.item.path : entry.item.name), `${entry.item.method.toLowerCase()}.mdx`),\n            ];\n        }\n        const file = nameFn.call(builder, entry, dereferenced);\n        if (groupBy === 'tag') {\n            let tags = entry.type === 'operation'\n                ? dereferenced.paths[entry.item.path][entry.item.method].tags\n                : dereferenced.webhooks[entry.item.name][entry.item.method].tags;\n            if (!tags || tags.length === 0) {\n                console.warn('When `groupBy` is set to `tag`, make sure a `tags` is defined for every operation schema.');\n                tags = ['unknown'];\n            }\n            return tags.map((tag) => path.join(slugify(tag), `${file}.mdx`));\n        }\n        if (typeof groupBy === 'function') {\n            return [path.join(slugify(groupBy(entry)), `${file}.mdx`)];\n        }\n        return [`${file}.mdx`];\n    }\n    return {\n        toPages(builder) {\n            const { dereferenced } = builder.document;\n            const items = builder.extract();\n            if (options.per === 'file') {\n                const entry = {\n                    type: 'group',\n                    schemaId: builder.id,\n                    path: '',\n                    info: {\n                        title: dereferenced.info.title,\n                        description: dereferenced.info.description,\n                    },\n                    ...items,\n                };\n                entry.path = nameFn.call(builder, entry, dereferenced) + '.mdx';\n                builder.create(entry);\n                return;\n            }\n            if (options.per === 'tag') {\n                const tags = dereferenced.tags ?? [];\n                for (const tag of tags) {\n                    const { displayName } = builder.fromTag(tag);\n                    const entry = {\n                        type: 'tag',\n                        path: '',\n                        schemaId: builder.id,\n                        info: {\n                            title: displayName,\n                            description: tag.description,\n                        },\n                        webhooks: items.webhooks.filter((webhook) => webhook.tags?.includes(tag.name)),\n                        operations: items.operations.filter((op) => op.tags?.includes(tag.name)),\n                        tag: tag.name,\n                        rawTag: tag,\n                    };\n                    entry.path = nameFn.call(builder, entry, dereferenced) + '.mdx';\n                    builder.create(entry);\n                }\n                return;\n            }\n            for (const op of items.operations) {\n                const { pathItem, operation, displayName } = builder.fromExtractedOperation(op);\n                const entry = {\n                    type: 'operation',\n                    schemaId: builder.id,\n                    item: op,\n                    path: '',\n                    info: {\n                        title: displayName,\n                        description: operation.description ?? pathItem.description,\n                    },\n                };\n                for (const outputPath of groupOutput(builder, entry)) {\n                    builder.create({ ...entry, path: outputPath });\n                }\n            }\n            for (const webhook of items.webhooks) {\n                const { pathItem, operation, displayName } = builder.fromExtractedWebhook(webhook);\n                const entry = {\n                    type: 'webhook',\n                    schemaId: builder.id,\n                    info: {\n                        title: displayName,\n                        description: operation.description ?? pathItem.description,\n                    },\n                    item: webhook,\n                    path: '',\n                };\n                for (const outputPath of groupOutput(builder, entry)) {\n                    builder.create({ ...entry, path: outputPath });\n                }\n            }\n        },\n    };\n}\n","export function isUrl(schemaId) {\n    return schemaId.startsWith('https://') || schemaId.startsWith('http://');\n}\nexport function joinURL(base, pathname) {\n    if (pathname.startsWith('/'))\n        pathname = pathname.slice(1);\n    if (base.endsWith('/'))\n        base = base.slice(0, -1);\n    if (pathname.length > 0)\n        return base + '/' + pathname;\n    else\n        return base;\n}\n/**\n * @param url - URL (can be relative)\n * @param base - the base URL (must be absolute)\n */\nexport function withBase(url, base) {\n    if (!url.startsWith('https://') && !url.startsWith('http://')) {\n        return joinURL(base, url);\n    }\n    return url;\n}\nexport function resolveServerUrl(template, variables) {\n    for (const [key, value] of Object.entries(variables)) {\n        template = template.replaceAll(`{${key}}`, value);\n    }\n    return template;\n}\nexport function resolveRequestData(pathname, { path, query }) {\n    // First, resolve path parameters in the pathname\n    for (const key in path) {\n        const param = path[key];\n        if (Array.isArray(param.value)) {\n            pathname = pathname.replace(`{${key}}`, param.value.join('/'));\n        }\n        else {\n            pathname = pathname.replace(`{${key}}`, param.value);\n        }\n    }\n    // Check if pathname already contains query parameters (legacy API support)\n    const [pathPart, existingQueryString] = pathname.split('?', 2);\n    // Parse existing query parameters from the pathname if they exist\n    const searchParams = new URLSearchParams(existingQueryString || '');\n    // Add new query parameters from the RequestData\n    for (const key in query) {\n        const param = query[key];\n        if (Array.isArray(param.value)) {\n            // Remove existing parameter first to avoid duplicates\n            searchParams.delete(key);\n            for (const item of param.value) {\n                searchParams.append(key, item);\n            }\n        }\n        else {\n            // Set (replace if exists) the parameter value\n            searchParams.set(key, param.value);\n        }\n    }\n    // Return the reconstructed URL\n    return searchParams.size > 0 ? `${pathPart}?${searchParams}` : pathPart;\n}\n"],"names":[],"mappings":"uCAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAEO,SAAS,EAAiB,CAAO,MAMhC,EALJ,GAAI,AAAgB,aAAR,GAAG,CACX,OAAO,EACX,GAAM,SAAE,EAAU,AAAC,GACR,EAAE,OAAO,CAAC,OAAQ,KAAK,WAAW,EAC5C,CAAG,CAAG,EAEP,GAA4B,YAAxB,AAAoC,OAA7B,EAAQ,IAAI,CACnB,EAAS,EAAQ,IAAI,KAEpB,CACD,GAAM,WAAE,EAAY,IAAI,CAAE,CAAG,EAAQ,IAAI,EAAI,CAAC,EAC9C,EAAS,SAAU,CAAM,CAAE,CAAQ,EAC/B,GAAoB,OAAO,CAAvB,EAAO,IAAI,CACX,OAAO,EAAQ,EAAO,GAAG,EAE7B,GAAoB,UAAhB,EAAO,IAAI,CAAc,CACzB,IAAM,EAAW,EAAO,QAAQ,CAChC,OAAO,ACnBZ,EAAS,UAAU,CAAC,aDmBF,ACnBiB,EAAS,UAAU,CAAC,WDoB5C,QACA,EAAA,QAAa,CAAC,EAAU,EAAA,OAAY,CAAC,GAC/C,CACA,GAAoB,cAAhB,EAAO,IAAI,CAAkB,CAC7B,IAAM,EAAY,EAAS,KAAK,CAAC,EAAO,IAAI,CAAC,IAAI,CAAC,CAAC,EAAO,IAAI,CAAC,MAAM,CAAC,OACtE,AAAkB,OAAd,GAAsB,EAAU,WAAW,CACpC,CADsC,CAC5B,WAAW,CAEzB,EAAA,IAAS,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAO,IAAI,CAAC,IAAI,EAAG,EAAO,IAAI,CAAC,MAAM,CAAC,WAAW,GAC/F,CACA,IAAM,EAAO,EAAS,QAAQ,CAAC,EAAO,IAAI,CAAC,IAAI,CAAC,CAAC,EAAO,IAAI,CAAC,MAAM,CAAC,OACpE,AAAkB,OAAd,GAAsB,EAAK,WAAW,CAC/B,CADiC,CAC5B,WAAW,CAEpB,EAAQ,EAAO,IAAI,CAAC,IAAI,CACnC,CACJ,CACA,SAAS,EAAY,CAAO,CAAE,CAAK,EAC/B,GAAM,cAAE,CAAY,CAAE,CAAG,EAAQ,QAAQ,CACnC,CAAE,UAAU,MAAM,CAAE,CAAG,EAC7B,GAAgB,SAAS,CAArB,EACA,MAAO,CACH,EAAA,IAAS,CAAC,EAAQ,mBAAmB,CAAgB,cAAf,EAAM,IAAI,CAAmB,EAAM,IAAI,CAAC,IAAI,CAAG,EAAM,IAAI,CAAC,IAAI,EAAG,CAAA,EAAG,EAAM,IAAI,CAAC,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC,EAClJ,CAEL,IAAM,EAAO,EAAO,IAAI,CAAC,EAAS,EAAO,GACzC,GAAgB,QAAZ,EAAmB,CACnB,IAAI,EAAsB,cAAf,EAAM,IAAI,CACf,EAAa,KAAK,CAAC,EAAM,IAAI,CAAC,IAAI,CAAC,CAAC,EAAM,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAC3D,EAAa,QAAQ,CAAC,EAAM,IAAI,CAAC,IAAI,CAAC,CAAC,EAAM,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAKpE,OAJK,GAAwB,GAAG,CAAnB,EAAK,MAAM,GACpB,QAAQ,IAAI,CAAC,6FACb,EAAO,CAAC,UAAU,EAEf,EAAK,GAAG,CAAE,AAAD,GAAS,EAAA,IAAS,CAAC,EAAQ,GAAM,CAAA,EAAG,EAAK,IAAI,CAAC,EAClE,OACA,AAAuB,YAAY,AAA/B,OAAO,EACA,CAAC,EAAA,IAAS,CAAC,EAAQ,EAAQ,IAAS,CAAA,EAAG,EAAK,IAAI,CAAC,EAAE,CAEvD,CAAC,CAAA,EAAG,EAAK,IAAI,CAAC,CAAC,AAC1B,CACA,MAAO,CACH,QAAQ,CAAO,EACX,GAAM,cAAE,CAAY,CAAE,CAAG,EAAQ,QAAQ,CACnC,EAAQ,EAAQ,OAAO,GAC7B,GAAoB,SAAhB,EAAQ,GAAG,CAAa,CACxB,IAAM,EAAQ,CACV,KAAM,QACN,SAAU,EAAQ,EAAE,CACpB,KAAM,GACN,KAAM,CACF,MAAO,EAAa,IAAI,CAAC,KAAK,CAC9B,YAAa,EAAa,IAAI,CAAC,WAAW,AAC9C,EACA,GAAG,CAAK,AACZ,EACA,EAAM,IAAI,CAAG,EAAO,IAAI,CAAC,EAAS,EAAO,GAAgB,OACzD,EAAQ,MAAM,CAAC,GACf,MACJ,CACA,GAAoB,QAAhB,EAAQ,GAAG,CAAY,CAEvB,IAAK,IAAM,KADE,EACK,AADQ,IAAI,EAAI,EAAE,CACZ,CACpB,GAAM,aAAE,CAAW,CAAE,CAAG,EAAQ,OAAO,CAAC,GAClC,EAAQ,CACV,KAAM,MACN,KAAM,GACN,SAAU,EAAQ,EAAE,CACpB,KAAM,CACF,MAAO,EACP,YAAa,EAAI,WAAW,AAChC,EACA,SAAU,EAAM,QAAQ,CAAC,MAAM,CAAC,AAAC,GAAY,EAAQ,IAAI,EAAE,SAAS,EAAI,IAAI,GAC5E,WAAY,EAAM,UAAU,CAAC,MAAM,CAAC,AAAC,GAAO,EAAG,IAAI,EAAE,SAAS,EAAI,IAAI,GACtE,IAAK,EAAI,IAAI,CACb,OAAQ,CACZ,EACA,EAAM,IAAI,CAAG,EAAO,IAAI,CAAC,EAAS,EAAO,GAAgB,OACzD,EAAQ,MAAM,CAAC,EACnB,CACA,MACJ,CACA,IAAK,IAAM,KAAM,EAAM,UAAU,CAAE,CAC/B,GAAM,CAAE,UAAQ,WAAE,CAAS,aAAE,CAAW,CAAE,CAAG,EAAQ,sBAAsB,CAAC,GACtE,EAAQ,CACV,KAAM,YACN,SAAU,EAAQ,EAAE,CACpB,KAAM,EACN,KAAM,GACN,KAAM,CACF,MAAO,EACP,YAAa,EAAU,WAAW,EAAI,EAAS,WAAW,AAC9D,CACJ,EACA,IAAK,IAAM,KAAc,EAAY,EAAS,GAC1C,EAAQ,EAD0C,IACpC,CAAC,CAAE,GAAG,CAAK,CAAE,KAAM,CAAW,EAEpD,CACA,IAAK,IAAM,KAAW,EAAM,QAAQ,CAAE,CAClC,GAAM,UAAE,CAAQ,WAAE,CAAS,aAAE,CAAW,CAAE,CAAG,EAAQ,oBAAoB,CAAC,GACpE,EAAQ,CACV,KAAM,UACN,SAAU,EAAQ,EAAE,CACpB,KAAM,CACF,MAAO,EACP,YAAa,EAAU,WAAW,EAAI,EAAS,WAAW,AAC9D,EACA,KAAM,EACN,KAAM,EACV,EACA,IAAK,IAAM,KAAc,EAAY,EAAS,GAC1C,EAAQ,EAD0C,IACpC,CAAC,CAAE,GAAG,CAAK,CAAE,KAAM,CAAW,EAEpD,CACJ,CACJ,CACJ","ignoreList":[0,1]}