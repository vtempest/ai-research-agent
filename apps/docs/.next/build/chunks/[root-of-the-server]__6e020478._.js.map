{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack-node]/transforms/transforms.ts"],"sourcesContent":["/**\n * Shared utilities for our 2 transform implementations.\n */\n\nimport type { Ipc } from '../ipc/evaluate'\nimport { relative, isAbsolute, join, sep } from 'path'\nimport { type StructuredError } from '../ipc'\nimport { type StackFrame } from '../compiled/stacktrace-parser'\n\nexport type IpcInfoMessage =\n  | {\n      type: 'dependencies'\n      envVariables?: string[]\n      directories?: Array<[string, string]>\n      filePaths?: string[]\n      buildFilePaths?: string[]\n    }\n  | {\n      type: 'emittedError'\n      severity: 'warning' | 'error'\n      error: StructuredError\n    }\n  | {\n      type: 'log'\n      logs: Array<{\n        time: number\n        logType: string\n        args: any[]\n        trace?: StackFrame[]\n      }>\n    }\n\nexport type IpcRequestMessage =\n  | {\n      type: 'resolve'\n      options: any\n      lookupPath: string\n      request: string\n    }\n  | {\n      type: 'trackFileRead'\n      file: string\n    }\n\nexport type TransformIpc = Ipc<IpcInfoMessage, IpcRequestMessage>\n\nconst contextDir = process.cwd()\nexport const toPath = (file: string) => {\n  const relPath = relative(contextDir, file)\n  if (isAbsolute(relPath)) {\n    throw new Error(\n      `Cannot depend on path (${file}) outside of root directory (${contextDir})`\n    )\n  }\n  return sep !== '/' ? relPath.replaceAll(sep, '/') : relPath\n}\nexport const fromPath = (path: string) => {\n  return join(\n    /* turbopackIgnore: true */ contextDir,\n    sep !== '/' ? path.replaceAll('/', sep) : path\n  )\n}\n\n// Patch process.env to track which env vars are read\nconst originalEnv = process.env\nconst readEnvVars = new Set<string>()\nprocess.env = new Proxy(originalEnv, {\n  get(target, prop) {\n    if (typeof prop === 'string') {\n      // We register the env var as dependency on the\n      // current transform and all future transforms\n      // since the env var might be cached in module scope\n      // and influence them all\n      readEnvVars.add(prop)\n    }\n    return Reflect.get(target, prop)\n  },\n  set(target, prop, value) {\n    return Reflect.set(target, prop, value)\n  },\n})\n\nexport function getReadEnvVariables(): string[] {\n  return Array.from(readEnvVars)\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AAGD;;AAyCA,MAAM,aAAa,QAAQ,GAAG;AACvB,MAAM,SAAS,CAAC;IACrB,MAAM,UAAU,IAAA,6GAAQ,EAAC,YAAY;IACrC,IAAI,IAAA,+GAAU,EAAC,UAAU;QACvB,MAAM,IAAI,MACR,CAAC,uBAAuB,EAAE,KAAK,6BAA6B,EAAE,WAAW,CAAC,CAAC;IAE/E;IACA,OAAO,wGAAG,KAAK,MAAM,QAAQ,UAAU,CAAC,wGAAG,EAAE,OAAO;AACtD;AACO,MAAM,WAAW,CAAC;IACvB,OAAO,IAAA,yGAAI,EACT,yBAAyB,GAAG,YAC5B,wGAAG,KAAK,MAAM,KAAK,UAAU,CAAC,KAAK,wGAAG,IAAI;AAE9C;AAEA,qDAAqD;AACrD,MAAM,cAAc,QAAQ,GAAG;AAC/B,MAAM,cAAc,IAAI;AACxB,QAAQ,GAAG,GAAG,IAAI,MAAM,aAAa;IACnC,KAAI,MAAM,EAAE,IAAI;QACd,IAAI,OAAO,SAAS,UAAU;YAC5B,+CAA+C;YAC/C,8CAA8C;YAC9C,oDAAoD;YACpD,yBAAyB;YACzB,YAAY,GAAG,CAAC;QAClB;QACA,OAAO,QAAQ,GAAG,CAAC,QAAQ;IAC7B;IACA,KAAI,MAAM,EAAE,IAAI,EAAE,KAAK;QACrB,OAAO,QAAQ,GAAG,CAAC,QAAQ,MAAM;IACnC;AACF;AAEO,SAAS;IACd,OAAO,MAAM,IAAI,CAAC;AACpB"}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack-node]/transforms/webpack-loaders.ts"],"sourcesContent":["declare const __turbopack_external_require__: {\n  resolve: (name: string, opt: { paths: string[] }) => string\n} & ((id: string, thunk: () => any, esm?: boolean) => any)\n\nimport type { Ipc } from '../ipc/evaluate'\nimport { dirname, resolve as pathResolve, relative } from 'path'\nimport {\n  StackFrame,\n  parse as parseStackTrace,\n} from '../compiled/stacktrace-parser'\nimport { structuredError, type StructuredError } from '../ipc'\nimport {\n  fromPath,\n  getReadEnvVariables,\n  toPath,\n  type TransformIpc,\n} from './transforms'\nimport fs from 'fs'\nimport path from 'path'\n\nexport type IpcInfoMessage =\n  | {\n      type: 'dependencies'\n      envVariables?: string[]\n      directories?: Array<[string, string]>\n      filePaths?: string[]\n      buildFilePaths?: string[]\n    }\n  | {\n      type: 'emittedError'\n      severity: 'warning' | 'error'\n      error: StructuredError\n    }\n  | {\n      type: 'log'\n      logs: Array<{\n        time: number\n        logType: string\n        args: any[]\n        trace?: StackFrame[]\n      }>\n    }\n\nexport type IpcRequestMessage = {\n  type: 'resolve'\n  options: any\n  lookupPath: string\n  request: string\n}\n\ntype LoaderConfig =\n  | string\n  | {\n      loader: string\n      options: { [k: string]: unknown }\n    }\n\nconst {\n  runLoaders,\n}: typeof import('loader-runner') = require('@vercel/turbopack/loader-runner')\n\nconst contextDir = process.cwd()\n\nconst LogType = Object.freeze({\n  error: 'error',\n  warn: 'warn',\n  info: 'info',\n  log: 'log',\n  debug: 'debug',\n\n  trace: 'trace',\n\n  group: 'group',\n  groupCollapsed: 'groupCollapsed',\n  groupEnd: 'groupEnd',\n\n  profile: 'profile',\n  profileEnd: 'profileEnd',\n\n  time: 'time',\n\n  clear: 'clear',\n  status: 'status',\n})\n\nconst loaderFlag = 'LOADER_EXECUTION'\n\nconst cutOffByFlag = (stack: string, flag: string): string => {\n  const errorStack = stack.split('\\n')\n  for (let i = 0; i < errorStack.length; i++) {\n    if (errorStack[i].includes(flag)) {\n      errorStack.length = i\n    }\n  }\n  return errorStack.join('\\n')\n}\n\n/**\n * @param stack stack trace\n * @returns stack trace without the loader execution flag included\n */\nconst cutOffLoaderExecution = (stack: string): string =>\n  cutOffByFlag(stack, loaderFlag)\n\nclass DummySpan {\n  traceChild() {\n    return new DummySpan()\n  }\n\n  traceFn<T>(fn: (span: DummySpan) => T): T {\n    return fn(this)\n  }\n\n  async traceAsyncFn<T>(fn: (span: DummySpan) => T | Promise<T>): Promise<T> {\n    return await fn(this)\n  }\n\n  stop() {\n    return\n  }\n}\n\ntype ResolveOptions = {\n  dependencyType?: string\n  alias?: Record<string, string[]> | unknown[]\n  aliasFields?: string[]\n  cacheWithContext?: boolean\n  conditionNames?: string[]\n  descriptionFiles?: string[]\n  enforceExtension?: boolean\n  extensionAlias: Record<string, string[]>\n  extensions?: string[]\n  fallback?: Record<string, string[]>\n  mainFields?: string[]\n  mainFiles?: string[]\n  exportsFields?: string[]\n  modules?: string[]\n  plugins?: unknown[]\n  symlinks?: boolean\n  unsafeCache?: boolean\n  useSyncFileSystemCalls?: boolean\n  preferRelative?: boolean\n  preferAbsolute?: boolean\n  restrictions?: unknown[]\n  roots?: string[]\n  importFields?: string[]\n}\n\nconst transform = (\n  ipc: TransformIpc,\n  content: string | { binary: string },\n  name: string,\n  query: string,\n  loaders: LoaderConfig[],\n  sourceMap: boolean\n) => {\n  return new Promise((resolve, reject) => {\n    const resource = pathResolve(contextDir, name)\n    const resourceDir = dirname(resource)\n\n    const loadersWithOptions = loaders.map((loader) =>\n      typeof loader === 'string' ? { loader, options: {} } : loader\n    )\n\n    const logs: Array<{\n      time: number\n      logType: string\n      args: unknown[]\n      trace: StackFrame[] | undefined\n    }> = []\n\n    runLoaders(\n      {\n        resource: resource + query,\n        context: {\n          _module: {\n            // For debugging purpose, if someone find context is not full compatible to\n            // webpack they can guess this comes from turbopack\n            __reserved: 'TurbopackContext',\n          },\n          currentTraceSpan: new DummySpan(),\n          rootContext: contextDir,\n          sourceMap,\n          getOptions() {\n            const entry = this.loaders[this.loaderIndex]\n            return entry.options && typeof entry.options === 'object'\n              ? entry.options\n              : {}\n          },\n          fs: {\n            readFile(p: string, optionsOrCb: any, maybeCb: any) {\n              ipc\n                .sendRequest({\n                  type: 'trackFileRead',\n                  file: relative(contextDir, pathResolve(p)),\n                })\n                .then(\n                  () => {\n                    fs.readFile(p, optionsOrCb, maybeCb)\n                  },\n                  (err) => {\n                    ipc.sendError(err)\n                    // sendError is going to stop the process, no need to call callback\n                  }\n                )\n            },\n          },\n          getResolve: (options: ResolveOptions) => {\n            const rustOptions = {\n              aliasFields: undefined as undefined | string[],\n              conditionNames: undefined as undefined | string[],\n              noPackageJson: false,\n              extensions: undefined as undefined | string[],\n              mainFields: undefined as undefined | string[],\n              noExportsField: false,\n              mainFiles: undefined as undefined | string[],\n              noModules: false,\n              preferRelative: false,\n            }\n            if (options.alias) {\n              if (!Array.isArray(options.alias) || options.alias.length > 0) {\n                throw new Error('alias resolve option is not supported')\n              }\n            }\n            if (options.aliasFields) {\n              if (!Array.isArray(options.aliasFields)) {\n                throw new Error('aliasFields resolve option must be an array')\n              }\n              rustOptions.aliasFields = options.aliasFields\n            }\n            if (options.conditionNames) {\n              if (!Array.isArray(options.conditionNames)) {\n                throw new Error(\n                  'conditionNames resolve option must be an array'\n                )\n              }\n              rustOptions.conditionNames = options.conditionNames\n            }\n            if (options.descriptionFiles) {\n              if (\n                !Array.isArray(options.descriptionFiles) ||\n                options.descriptionFiles.length > 0\n              ) {\n                throw new Error(\n                  'descriptionFiles resolve option is not supported'\n                )\n              }\n              rustOptions.noPackageJson = true\n            }\n            if (options.extensions) {\n              if (!Array.isArray(options.extensions)) {\n                throw new Error('extensions resolve option must be an array')\n              }\n              rustOptions.extensions = options.extensions\n            }\n            if (options.mainFields) {\n              if (!Array.isArray(options.mainFields)) {\n                throw new Error('mainFields resolve option must be an array')\n              }\n              rustOptions.mainFields = options.mainFields\n            }\n            if (options.exportsFields) {\n              if (\n                !Array.isArray(options.exportsFields) ||\n                options.exportsFields.length > 0\n              ) {\n                throw new Error('exportsFields resolve option is not supported')\n              }\n              rustOptions.noExportsField = true\n            }\n            if (options.mainFiles) {\n              if (!Array.isArray(options.mainFiles)) {\n                throw new Error('mainFiles resolve option must be an array')\n              }\n              rustOptions.mainFiles = options.mainFiles\n            }\n            if (options.modules) {\n              if (\n                !Array.isArray(options.modules) ||\n                options.modules.length > 0\n              ) {\n                throw new Error('modules resolve option is not supported')\n              }\n              rustOptions.noModules = true\n            }\n            if (options.restrictions) {\n              // TODO This is ignored for now\n            }\n            if (options.dependencyType) {\n              // TODO This is ignored for now\n            }\n            if (options.preferRelative) {\n              if (typeof options.preferRelative !== 'boolean') {\n                throw new Error(\n                  'preferRelative resolve option must be a boolean'\n                )\n              }\n              rustOptions.preferRelative = options.preferRelative\n            }\n            return (\n              lookupPath: string,\n              request: string,\n              callback?: (err?: Error, result?: string) => void\n            ) => {\n              if (path.isAbsolute(request)) {\n                // Relativize absolute requests. Turbopack disallow them in JS code, but here it's\n                // generated programatically and there is a smaller problem of\n                // non-cacheable/non-portable builds.\n                request = path.relative(lookupPath, request)\n\n                // On Windows, the path might be still absolute if it's on a different drive. Just\n                // let the resolver throw the error in that case.\n                if (\n                  !path.isAbsolute(request) &&\n                  request.split(path.sep)[0] !== '..'\n                ) {\n                  request = './' + request\n                }\n              }\n\n              const promise = ipc\n                .sendRequest({\n                  type: 'resolve',\n                  options: rustOptions,\n                  lookupPath: toPath(lookupPath),\n                  request,\n                })\n                .then((unknownResult) => {\n                  let result = unknownResult as { path: string }\n                  if (result && typeof result.path === 'string') {\n                    return fromPath(result.path)\n                  } else {\n                    throw Error(\n                      'Expected { path: string } from resolve request'\n                    )\n                  }\n                })\n              if (callback) {\n                promise\n                  .then(\n                    (result) => callback(undefined, result),\n                    (err) => callback(err)\n                  )\n                  .catch((err) => {\n                    ipc.sendError(err)\n                  })\n              } else {\n                return promise\n              }\n            }\n          },\n          emitWarning: makeErrorEmitter('warning', ipc),\n          emitError: makeErrorEmitter('error', ipc),\n          getLogger(name: unknown) {\n            const logFn = (logType: string, ...args: unknown[]) => {\n              let trace: StackFrame[] | undefined\n              switch (logType) {\n                case LogType.warn:\n                case LogType.error:\n                case LogType.trace:\n                case LogType.debug:\n                  trace = parseStackTrace(\n                    cutOffLoaderExecution(new Error('Trace').stack!)\n                      .split('\\n')\n                      .slice(3)\n                      .join('\\n')\n                  )\n                  break\n                default:\n                  // TODO: do we need to handle this?\n                  break\n              }\n              // Batch logs messages to be sent at the end\n              logs.push({\n                time: Date.now(),\n                logType,\n                args,\n                trace,\n              })\n            }\n            let timers: Map<string, [number, number]> | undefined\n            let timersAggregates: Map<string, [number, number]> | undefined\n\n            // See https://github.com/webpack/webpack/blob/a48c34b34d2d6c44f9b2b221d7baf278d34ac0be/lib/logging/Logger.js#L8\n            return {\n              error: logFn.bind(this, LogType.error),\n              warn: logFn.bind(this, LogType.warn),\n              info: logFn.bind(this, LogType.info),\n              log: logFn.bind(this, LogType.log),\n              debug: logFn.bind(this, LogType.debug),\n              assert: (assertion: boolean, ...args: any[]) => {\n                if (!assertion) {\n                  logFn(LogType.error, ...args)\n                }\n              },\n              trace: logFn.bind(this, LogType.trace),\n              clear: logFn.bind(this, LogType.clear),\n              status: logFn.bind(this, LogType.status),\n              group: logFn.bind(this, LogType.group),\n              groupCollapsed: logFn.bind(this, LogType.groupCollapsed),\n              groupEnd: logFn.bind(this, LogType.groupEnd),\n              profile: logFn.bind(this, LogType.profile),\n              profileEnd: logFn.bind(this, LogType.profileEnd),\n              time: (label: string) => {\n                timers = timers || new Map()\n                timers.set(label, process.hrtime())\n              },\n              timeLog: (label: string) => {\n                const prev = timers && timers.get(label)\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeLog()`\n                  )\n                }\n                const time = process.hrtime(prev)\n                logFn(LogType.time, [label, ...time])\n              },\n              timeEnd: (label: string) => {\n                const prev = timers && timers.get(label)\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeEnd()`\n                  )\n                }\n                const time = process.hrtime(prev)\n                /** @type {Map<string | undefined, [number, number]>} */\n                timers!.delete(label)\n                logFn(LogType.time, [label, ...time])\n              },\n              timeAggregate: (label: string) => {\n                const prev = timers && timers.get(label)\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeAggregate()`\n                  )\n                }\n                const time = process.hrtime(prev)\n                /** @type {Map<string | undefined, [number, number]>} */\n                timers!.delete(label)\n                /** @type {Map<string | undefined, [number, number]>} */\n                timersAggregates = timersAggregates || new Map()\n                const current = timersAggregates.get(label)\n                if (current !== undefined) {\n                  if (time[1] + current[1] > 1e9) {\n                    time[0] += current[0] + 1\n                    time[1] = time[1] - 1e9 + current[1]\n                  } else {\n                    time[0] += current[0]\n                    time[1] += current[1]\n                  }\n                }\n                timersAggregates.set(label, time)\n              },\n              timeAggregateEnd: (label: string) => {\n                if (timersAggregates === undefined) return\n                const time = timersAggregates.get(label)\n                if (time === undefined) return\n                timersAggregates.delete(label)\n                logFn(LogType.time, [label, ...time])\n              },\n            }\n          },\n        },\n\n        loaders: loadersWithOptions.map((loader) => ({\n          loader: __turbopack_external_require__.resolve(loader.loader, {\n            paths: [contextDir, resourceDir],\n          }),\n          options: loader.options,\n        })),\n        readResource: (_filename, callback) => {\n          // TODO assuming that filename === resource, but loaders might change that\n          let data =\n            typeof content === 'string'\n              ? Buffer.from(content, 'utf-8')\n              : Buffer.from(content.binary, 'base64')\n          callback(null, data)\n        },\n      },\n      (err, result) => {\n        if (logs.length) {\n          ipc.sendInfo({ type: 'log', logs: logs })\n          logs.length = 0\n        }\n        ipc.sendInfo({\n          type: 'dependencies',\n          envVariables: getReadEnvVariables(),\n          filePaths: result.fileDependencies.map(toPath),\n          directories: result.contextDependencies.map((dep) => [\n            toPath(dep),\n            '**',\n          ]),\n        })\n        if (err) return reject(err)\n        if (!result.result) return reject(new Error('No result from loaders'))\n        const [source, map] = result.result\n        resolve({\n          source: Buffer.isBuffer(source)\n            ? { binary: source.toString('base64') }\n            : source,\n          map:\n            typeof map === 'string'\n              ? map\n              : typeof map === 'object'\n                ? JSON.stringify(map)\n                : undefined,\n        })\n      }\n    )\n  })\n}\n\nexport { transform as default }\n\nfunction makeErrorEmitter(\n  severity: 'warning' | 'error',\n  ipc: Ipc<IpcInfoMessage, IpcRequestMessage>\n) {\n  return function (error: Error | string) {\n    ipc.sendInfo({\n      type: 'emittedError',\n      severity: severity,\n      error: structuredError(error),\n    })\n  }\n}\n"],"names":[],"mappings":"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"}}]
}