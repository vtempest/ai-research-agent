{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = convertPathToPosix;\nconst path_1 = __importDefault(require(\"path\"));\nfunction convertPathToPosix(filePath) {\n    const isExtendedLengthPath = filePath.startsWith(\"\\\\\\\\?\\\\\");\n    if (isExtendedLengthPath) {\n        return filePath;\n    }\n    return filePath.split(path_1.default?.win32?.sep).join(path_1.default?.posix?.sep ?? \"/\");\n}\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,SAAU,GAAG;IACjE,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,WAAW;IAAI;AAC5D;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,OAAO,GAAG;AAClB,MAAM,SAAS;AACf,SAAS,mBAAmB,QAAQ;IAChC,MAAM,uBAAuB,SAAS,UAAU,CAAC;IACjD,IAAI,sBAAsB;QACtB,OAAO;IACX;IACA,OAAO,SAAS,KAAK,CAAC,OAAO,OAAO,EAAE,OAAO,KAAK,IAAI,CAAC,OAAO,OAAO,EAAE,OAAO,OAAO;AACzF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isWindows = void 0;\nconst isWindowsConst = /^win/.test(globalThis.process ? globalThis.process.platform : \"\");\nconst isWindows = () => isWindowsConst;\nexports.isWindows = isWindows;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG,KAAK;AACzB,MAAM,iBAAiB,OAAO,IAAI,CAAC,WAAW,OAAO,GAAG,WAAW,OAAO,CAAC,QAAQ,GAAG;AACtF,MAAM,YAAY,IAAM;AACxB,QAAQ,SAAS,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/url.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = void 0;\nexports.resolve = resolve;\nexports.cwd = cwd;\nexports.getProtocol = getProtocol;\nexports.getExtension = getExtension;\nexports.stripQuery = stripQuery;\nexports.getHash = getHash;\nexports.stripHash = stripHash;\nexports.isHttp = isHttp;\nexports.isFileSystemPath = isFileSystemPath;\nexports.fromFileSystemPath = fromFileSystemPath;\nexports.toFileSystemPath = toFileSystemPath;\nexports.safePointerToPath = safePointerToPath;\nexports.relative = relative;\nconst convert_path_to_posix_1 = __importDefault(require(\"./convert-path-to-posix\"));\nconst path_1 = __importStar(require(\"path\"));\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\nconst path_2 = require(\"path\");\nconst is_windows_1 = require(\"./is-windows\");\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [\n    [/\\?/g, \"%3F\"],\n    [/#/g, \"%23\"],\n];\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [/%23/g, \"#\", /%24/g, \"$\", /%26/g, \"&\", /%2C/g, \",\", /%40/g, \"@\"];\nconst parse = (u) => new URL(u);\nexports.parse = parse;\n/**\n * Returns resolved target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF.\n *\n * @returns\n */\nfunction resolve(from, to) {\n    // we use a non-existent URL to check if its a relative URL\n    const fromUrl = new URL((0, convert_path_to_posix_1.default)(from), \"https://aaa.nonexistanturl.com\");\n    const resolvedUrl = new URL((0, convert_path_to_posix_1.default)(to), fromUrl);\n    const endSpaces = to.match(/(\\s*)$/)?.[1] || \"\";\n    if (resolvedUrl.hostname === \"aaa.nonexistanturl.com\") {\n        // `from` is a relative URL.\n        const { pathname, search, hash } = resolvedUrl;\n        return pathname + search + hash + endSpaces;\n    }\n    return resolvedUrl.toString() + endSpaces;\n}\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns\n */\nfunction cwd() {\n    if (typeof window !== \"undefined\") {\n        return location.href;\n    }\n    const path = process.cwd();\n    const lastChar = path.slice(-1);\n    if (lastChar === \"/\" || lastChar === \"\\\\\") {\n        return path;\n    }\n    else {\n        return path + \"/\";\n    }\n}\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param path\n * @returns\n */\nfunction getProtocol(path) {\n    const match = protocolPattern.exec(path || \"\");\n    if (match) {\n        return match[1].toLowerCase();\n    }\n    return undefined;\n}\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param path\n * @returns\n */\nfunction getExtension(path) {\n    const lastDot = path.lastIndexOf(\".\");\n    if (lastDot >= 0) {\n        return stripQuery(path.substr(lastDot).toLowerCase());\n    }\n    return \"\";\n}\n/**\n * Removes the query, if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripQuery(path) {\n    const queryIndex = path.indexOf(\"?\");\n    if (queryIndex >= 0) {\n        path = path.substr(0, queryIndex);\n    }\n    return path;\n}\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param path\n * @returns\n */\nfunction getHash(path) {\n    if (!path) {\n        return \"#\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        return path.substring(hashIndex);\n    }\n    return \"#\";\n}\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripHash(path) {\n    if (!path) {\n        return \"\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        path = path.substring(0, hashIndex);\n    }\n    return path;\n}\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param path\n * @returns\n */\nfunction isHttp(path) {\n    const protocol = getProtocol(path);\n    if (protocol === \"http\" || protocol === \"https\") {\n        return true;\n    }\n    else if (protocol === undefined) {\n        // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n        return typeof window !== \"undefined\";\n    }\n    else {\n        // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n        return false;\n    }\n}\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param path\n * @returns\n */\nfunction isFileSystemPath(path) {\n    // @ts-ignore\n    if (typeof window !== \"undefined\" || (typeof process !== \"undefined\" && process.browser)) {\n        // We're running in a browser, so assume that all paths are URLs.\n        // This way, even relative paths will be treated as URLs rather than as filesystem paths\n        return false;\n    }\n    const protocol = getProtocol(path);\n    return protocol === undefined || protocol === \"file\";\n}\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param path\n * @returns\n */\nfunction fromFileSystemPath(path) {\n    // Step 1: On Windows, replace backslashes with forward slashes,\n    // rather than encoding them as \"%5C\"\n    if ((0, is_windows_1.isWindows)()) {\n        const projectDir = cwd();\n        const upperPath = path.toUpperCase();\n        const projectDirPosixPath = (0, convert_path_to_posix_1.default)(projectDir);\n        const posixUpper = projectDirPosixPath.toUpperCase();\n        const hasProjectDir = upperPath.includes(posixUpper);\n        const hasProjectUri = upperPath.includes(posixUpper);\n        const isAbsolutePath = path_1.win32?.isAbsolute(path) ||\n            path.startsWith(\"http://\") ||\n            path.startsWith(\"https://\") ||\n            path.startsWith(\"file://\");\n        if (!(hasProjectDir || hasProjectUri || isAbsolutePath) && !projectDir.startsWith(\"http\")) {\n            path = (0, path_2.join)(projectDir, path);\n        }\n        path = (0, convert_path_to_posix_1.default)(path);\n    }\n    // Step 2: `encodeURI` will take care of MOST characters\n    path = encodeURI(path);\n    // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (const pattern of urlEncodePatterns) {\n        path = path.replace(pattern[0], pattern[1]);\n    }\n    return path;\n}\n/**\n * Converts a URL to a local filesystem path.\n */\nfunction toFileSystemPath(path, keepFileProtocol) {\n    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n    path = decodeURI(path);\n    // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n    }\n    // Step 3: If it's a \"file://\" URL, then format it consistently\n    // or convert it to a local filesystem path\n    let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n    if (isFileUrl) {\n        // Strip-off the protocol, and the initial \"/\", if there is one\n        path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n        // insert a colon (\":\") after the drive letter on Windows\n        if ((0, is_windows_1.isWindows)() && path[1] === \"/\") {\n            path = path[0] + \":\" + path.substr(1);\n        }\n        if (keepFileProtocol) {\n            // Return the consistently-formatted \"file://\" URL\n            path = \"file:///\" + path;\n        }\n        else {\n            // Convert the \"file://\" URL to a local filesystem path.\n            // On Windows, it will start with something like \"C:/\".\n            // On Posix, it will start with \"/\"\n            isFileUrl = false;\n            path = (0, is_windows_1.isWindows)() ? path : \"/\" + path;\n        }\n    }\n    // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n    if ((0, is_windows_1.isWindows)() && !isFileUrl) {\n        // Replace forward slashes with backslashes\n        path = path.replace(forwardSlashPattern, \"\\\\\");\n        // Capitalize the drive letter\n        if (path.substr(1, 2) === \":\\\\\") {\n            path = path[0].toUpperCase() + path.substr(1);\n        }\n    }\n    return path;\n}\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param pointer\n * @returns\n */\nfunction safePointerToPath(pointer) {\n    if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n        return [];\n    }\n    return pointer\n        .slice(2)\n        .split(\"/\")\n        .map((value) => {\n        return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n}\nfunction relative(from, to) {\n    if (!isFileSystemPath(from) || !isFileSystemPath(to)) {\n        return resolve(from, to);\n    }\n    const fromDir = path_1.default.dirname(stripHash(from));\n    const toPath = stripHash(to);\n    const result = path_1.default.relative(fromDir, toPath);\n    return result + getHash(to);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/errors.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidPointerError = exports.TimeoutError = exports.MissingPointerError = exports.UnmatchedResolverError = exports.ResolverError = exports.UnmatchedParserError = exports.ParserError = exports.JSONParserErrorGroup = exports.JSONParserError = void 0;\nexports.isHandledError = isHandledError;\nexports.normalizeError = normalizeError;\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst url_js_1 = require(\"./url.js\");\nclass JSONParserError extends Error {\n    constructor(message, source) {\n        super();\n        this.code = \"EUNKNOWN\";\n        this.name = \"JSONParserError\";\n        this.message = message;\n        this.source = source;\n        this.path = null;\n        ono_1.Ono.extend(this);\n    }\n    get footprint() {\n        return `${this.path}+${this.source}+${this.code}+${this.message}`;\n    }\n}\nexports.JSONParserError = JSONParserError;\nclass JSONParserErrorGroup extends Error {\n    constructor(parser) {\n        super();\n        this.files = parser;\n        this.name = \"JSONParserErrorGroup\";\n        this.message = `${this.errors.length} error${this.errors.length > 1 ? \"s\" : \"\"} occurred while reading '${(0, url_js_1.toFileSystemPath)(parser.$refs._root$Ref.path)}'`;\n        ono_1.Ono.extend(this);\n    }\n    static getParserErrors(parser) {\n        const errors = [];\n        for (const $ref of Object.values(parser.$refs._$refs)) {\n            if ($ref.errors) {\n                errors.push(...$ref.errors);\n            }\n        }\n        return errors;\n    }\n    get errors() {\n        return JSONParserErrorGroup.getParserErrors(this.files);\n    }\n}\nexports.JSONParserErrorGroup = JSONParserErrorGroup;\nclass ParserError extends JSONParserError {\n    constructor(message, source) {\n        super(`Error parsing ${source}: ${message}`, source);\n        this.code = \"EPARSER\";\n        this.name = \"ParserError\";\n    }\n}\nexports.ParserError = ParserError;\nclass UnmatchedParserError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find parser for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDPARSER\";\n        this.name = \"UnmatchedParserError\";\n    }\n}\nexports.UnmatchedParserError = UnmatchedParserError;\nclass ResolverError extends JSONParserError {\n    constructor(ex, source) {\n        super(ex.message || `Error reading file \"${source}\"`, source);\n        this.code = \"ERESOLVER\";\n        this.name = \"ResolverError\";\n        if (\"code\" in ex) {\n            this.ioErrorCode = String(ex.code);\n        }\n    }\n}\nexports.ResolverError = ResolverError;\nclass UnmatchedResolverError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find resolver for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"UnmatchedResolverError\";\n    }\n}\nexports.UnmatchedResolverError = UnmatchedResolverError;\nclass MissingPointerError extends JSONParserError {\n    constructor(token, path, targetRef, targetFound, parentPath) {\n        super(`Missing $ref pointer \"${(0, url_js_1.getHash)(path)}\". Token \"${token}\" does not exist.`, (0, url_js_1.stripHash)(path));\n        this.code = \"EMISSINGPOINTER\";\n        this.name = \"MissingPointerError\";\n        this.targetToken = token;\n        this.targetRef = targetRef;\n        this.targetFound = targetFound;\n        this.parentPath = parentPath;\n    }\n}\nexports.MissingPointerError = MissingPointerError;\nclass TimeoutError extends JSONParserError {\n    constructor(timeout) {\n        super(`Dereferencing timeout reached: ${timeout}ms`);\n        this.code = \"ETIMEOUT\";\n        this.name = \"TimeoutError\";\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass InvalidPointerError extends JSONParserError {\n    constructor(pointer, path) {\n        super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"InvalidPointerError\";\n    }\n}\nexports.InvalidPointerError = InvalidPointerError;\nfunction isHandledError(err) {\n    return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n}\nfunction normalizeError(err) {\n    if (err.path === null) {\n        err.path = [];\n    }\n    return err;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/pointer.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nullSymbol = void 0;\nconst ref_js_1 = __importDefault(require(\"./ref.js\"));\nconst url = __importStar(require(\"./util/url.js\"));\nconst errors_js_1 = require(\"./util/errors.js\");\nexports.nullSymbol = Symbol('null');\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\nconst safeDecodeURIComponent = (encodedURIComponent) => {\n    try {\n        return decodeURIComponent(encodedURIComponent);\n    }\n    catch {\n        return encodedURIComponent;\n    }\n};\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param $ref\n * @param path\n * @param [friendlyPath] - The original user-specified path (used for error messages)\n * @class\n */\nclass Pointer {\n    constructor($ref, path, friendlyPath) {\n        this.$ref = $ref;\n        this.path = path;\n        this.originalPath = friendlyPath || path;\n        this.value = undefined;\n        this.circular = false;\n        this.indirections = 0;\n    }\n    /**\n     * Resolves the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param options\n     * @param pathFromRoot - the path of place that initiated resolving\n     *\n     * @returns\n     * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n     * If resolving this value required resolving other JSON references, then\n     * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n     * of the resolved value.\n     */\n    resolve(obj, options, pathFromRoot) {\n        const tokens = Pointer.parse(this.path, this.originalPath);\n        const found = [];\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length; i++) {\n            if (resolveIf$Ref(this, options, pathFromRoot)) {\n                // The $ref path has changed, so append the remaining tokens to the path\n                this.path = Pointer.join(this.path, tokens.slice(i));\n            }\n            if (typeof this.value === \"object\" && this.value !== null && !isRootPath(pathFromRoot) && \"$ref\" in this.value) {\n                return this;\n            }\n            const token = tokens[i];\n            if (this.value[token] === undefined || (this.value[token] === null && i === tokens.length - 1)) {\n                // one final case is if the entry itself includes slashes, and was parsed out as a token - we can join the remaining tokens and try again\n                let didFindSubstringSlashMatch = false;\n                for (let j = tokens.length - 1; j > i; j--) {\n                    const joinedToken = tokens.slice(i, j + 1).join(\"/\");\n                    if (this.value[joinedToken] !== undefined) {\n                        this.value = this.value[joinedToken];\n                        i = j;\n                        didFindSubstringSlashMatch = true;\n                        break;\n                    }\n                }\n                if (didFindSubstringSlashMatch) {\n                    continue;\n                }\n                // If the token we're looking for ended up not containing any slashes but is\n                // actually instead pointing to an existing `null` value then we should use that\n                // `null` value.\n                if (token in this.value && this.value[token] === null) {\n                    // We use a `null` symbol for internal tracking to differntiate between a general `null`\n                    // value and our expected `null` value.\n                    this.value = exports.nullSymbol;\n                    continue;\n                }\n                this.value = null;\n                const path = this.$ref.path || \"\";\n                const targetRef = this.path.replace(path, \"\");\n                const targetFound = Pointer.join(\"\", found);\n                const parentPath = pathFromRoot?.replace(path, \"\");\n                throw new errors_js_1.MissingPointerError(token, decodeURI(this.originalPath), targetRef, targetFound, parentPath);\n            }\n            else {\n                this.value = this.value[token];\n            }\n            found.push(token);\n        }\n        // Resolve the final value\n        if (!this.value || (this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot)) {\n            resolveIf$Ref(this, options, pathFromRoot);\n        }\n        return this;\n    }\n    /**\n     * Sets the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param value - the value to assign\n     * @param options\n     *\n     * @returns\n     * Returns the modified object, or an entirely new object if the entire object is overwritten.\n     */\n    set(obj, value, options) {\n        const tokens = Pointer.parse(this.path);\n        let token;\n        if (tokens.length === 0) {\n            // There are no tokens, replace the entire object with the new value\n            this.value = value;\n            return value;\n        }\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length - 1; i++) {\n            resolveIf$Ref(this, options);\n            token = tokens[i];\n            if (this.value && this.value[token] !== undefined) {\n                // The token exists\n                this.value = this.value[token];\n            }\n            else {\n                // The token doesn't exist, so create it\n                this.value = setValue(this, token, {});\n            }\n        }\n        // Set the value of the final token\n        resolveIf$Ref(this, options);\n        token = tokens[tokens.length - 1];\n        setValue(this, token, value);\n        // Return the updated object\n        return obj;\n    }\n    /**\n     * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n     * and returns an array of the pointer's tokens.\n     * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n     *\n     * The pointer is parsed according to RFC 6901\n     * {@link https://tools.ietf.org/html/rfc6901#section-3}\n     *\n     * @param path\n     * @param [originalPath]\n     * @returns\n     */\n    static parse(path, originalPath) {\n        // Get the JSON pointer from the path's hash\n        const pointer = url.getHash(path).substring(1);\n        // If there's no pointer, then there are no tokens,\n        // so return an empty array\n        if (!pointer) {\n            return [];\n        }\n        // Split into an array\n        const split = pointer.split(\"/\");\n        // Decode each part, according to RFC 6901\n        for (let i = 0; i < split.length; i++) {\n            split[i] = safeDecodeURIComponent(split[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n        }\n        if (split[0] !== \"\") {\n            throw new errors_js_1.InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n        }\n        return split.slice(1);\n    }\n    /**\n     * Creates a JSON pointer path, by joining one or more tokens to a base path.\n     *\n     * @param base - The base path (e.g. \"schema.json#/definitions/person\")\n     * @param tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n     * @returns\n     */\n    static join(base, tokens) {\n        // Ensure that the base path contains a hash\n        if (base.indexOf(\"#\") === -1) {\n            base += \"#\";\n        }\n        // Append each token to the base path\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Encode the token, according to RFC 6901\n            base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n        }\n        return base;\n    }\n}\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param pointer\n * @param options\n * @param [pathFromRoot] - the path of place that initiated resolving\n * @returns - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer, options, pathFromRoot) {\n    // Is the value a JSON reference? (and allowed?)\n    if (ref_js_1.default.isAllowed$Ref(pointer.value, options)) {\n        const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n        if ($refPath === pointer.path && !isRootPath(pathFromRoot)) {\n            // The value is a reference to itself, so there's nothing to do.\n            pointer.circular = true;\n        }\n        else {\n            const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n            if (resolved === null) {\n                return false;\n            }\n            pointer.indirections += resolved.indirections + 1;\n            if (ref_js_1.default.isExtended$Ref(pointer.value)) {\n                // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n                // So the resolved path does NOT change.  Just the value does.\n                pointer.value = ref_js_1.default.dereference(pointer.value, resolved.value);\n                return false;\n            }\n            else {\n                // Resolve the reference\n                pointer.$ref = resolved.$ref;\n                pointer.path = resolved.path;\n                pointer.value = resolved.value;\n            }\n            return true;\n        }\n    }\n    return undefined;\n}\nexports.default = Pointer;\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param pointer - The JSON Pointer whose value will be modified\n * @param token - A JSON Pointer token that indicates how to modify `obj`\n * @param value - The value to assign\n * @returns - Returns the assigned value\n */\nfunction setValue(pointer, token, value) {\n    if (pointer.value && typeof pointer.value === \"object\") {\n        if (token === \"-\" && Array.isArray(pointer.value)) {\n            pointer.value.push(value);\n        }\n        else {\n            pointer.value[token] = value;\n        }\n    }\n    else {\n        throw new errors_js_1.JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n    }\n    return value;\n}\nfunction unwrapOrThrow(value) {\n    if ((0, errors_js_1.isHandledError)(value)) {\n        throw value;\n    }\n    return value;\n}\nfunction isRootPath(pathFromRoot) {\n    return typeof pathFromRoot == \"string\" && Pointer.parse(pathFromRoot).length == 0;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/ref.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pointer_js_1 = __importStar(require(\"./pointer.js\"));\nconst errors_js_1 = require(\"./util/errors.js\");\nconst url_js_1 = require(\"./util/url.js\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nclass $Ref {\n    constructor($refs) {\n        /**\n         * List of all errors. Undefined if no errors.\n         */\n        this.errors = [];\n        this.$refs = $refs;\n    }\n    /**\n     * Pushes an error to errors array.\n     *\n     * @param err - The error to be pushed\n     * @returns\n     */\n    addError(err) {\n        if (this.errors === undefined) {\n            this.errors = [];\n        }\n        const existingErrors = this.errors.map(({ footprint }) => footprint);\n        // the path has been almost certainly set at this point,\n        // but just in case something went wrong, normalizeError injects path if necessary\n        // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n        if (\"errors\" in err && Array.isArray(err.errors)) {\n            this.errors.push(...err.errors.map(errors_js_1.normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));\n        }\n        else if (!(\"footprint\" in err) || !existingErrors.includes(err.footprint)) {\n            this.errors.push((0, errors_js_1.normalizeError)(err));\n        }\n    }\n    /**\n     * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this.resolve(path, options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this.resolve(path, options)?.value;\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @param friendlyPath - The original user-specified path (used for error messages)\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @returns\n     */\n    resolve(path, options, friendlyPath, pathFromRoot) {\n        const pointer = new pointer_js_1.default(this, path, friendlyPath);\n        try {\n            const resolved = pointer.resolve(this.value, options, pathFromRoot);\n            if (resolved.value === pointer_js_1.nullSymbol) {\n                resolved.value = null;\n            }\n            return resolved;\n        }\n        catch (err) {\n            if (!options || !options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                throw err;\n            }\n            if (err.path === null) {\n                err.path = (0, url_js_1.safePointerToPath)((0, url_js_1.getHash)(pathFromRoot));\n            }\n            if (err instanceof errors_js_1.InvalidPointerError) {\n                err.source = decodeURI((0, url_js_1.stripHash)(pathFromRoot));\n            }\n            this.addError(err);\n            return null;\n        }\n    }\n    /**\n     * Sets the value of a nested property within this {@link $Ref#value}.\n     * If the property, or any of its parents don't exist, they will be created.\n     *\n     * @param path - The full path of the property to set, optionally with a JSON pointer in the hash\n     * @param value - The value to assign\n     */\n    set(path, value) {\n        const pointer = new pointer_js_1.default(this, path);\n        this.value = pointer.set(this.value, value);\n        if (this.value === pointer_js_1.nullSymbol) {\n            this.value = null;\n        }\n    }\n    /**\n     * Determines whether the given value is a JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static is$Ref(value) {\n        return (Boolean(value) &&\n            typeof value === \"object\" &&\n            value !== null &&\n            \"$ref\" in value &&\n            typeof value.$ref === \"string\" &&\n            value.$ref.length > 0);\n    }\n    /**\n     * Determines whether the given value is an external JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExternal$Ref(value) {\n        return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n    }\n    /**\n     * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n     * For example, if it references an external file, then options.resolve.external must be true.\n     *\n     * @param value - The value to inspect\n     * @param options\n     * @returns\n     */\n    static isAllowed$Ref(value, options) {\n        if (this.is$Ref(value)) {\n            if (value.$ref.substring(0, 2) === \"#/\" || value.$ref === \"#\") {\n                // It's a JSON Pointer reference, which is always allowed\n                return true;\n            }\n            else if (value.$ref[0] !== \"#\" && (!options || options.resolve?.external)) {\n                // It's an external reference, which is allowed by the options\n                return true;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n     * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n     * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n     * value, plus the extra properties.\n     *\n     * @example: {\n       person: {\n         properties: {\n           firstName: { type: string }\n           lastName: { type: string }\n         }\n       }\n       employee: {\n         properties: {\n           $ref: #/person/properties\n           salary: { type: number }\n         }\n       }\n     }\n     *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n     *  property (salary).  The result is a NEW value that looks like this:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExtended$Ref(value) {\n        return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n    }\n    /**\n     * Returns the resolved value of a JSON Reference.\n     * If necessary, the resolved value is merged with the JSON Reference to create a new object\n     *\n     * @example: {\n    person: {\n      properties: {\n        firstName: { type: string }\n        lastName: { type: string }\n      }\n    }\n    employee: {\n      properties: {\n        $ref: #/person/properties\n        salary: { type: number }\n      }\n    }\n    } When \"person\" and \"employee\" are merged, you end up with the following object:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param $ref - The JSON reference object (the one with the \"$ref\" property)\n     * @param resolvedValue - The resolved value, which can be any type\n     * @returns - Returns the dereferenced value\n     */\n    static dereference($ref, resolvedValue) {\n        if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n            const merged = {};\n            for (const key of Object.keys($ref)) {\n                if (key !== \"$ref\") {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = $ref[key];\n                }\n            }\n            for (const key of Object.keys(resolvedValue)) {\n                if (!(key in merged)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = resolvedValue[key];\n                }\n            }\n            return merged;\n        }\n        else {\n            // Completely replace the original reference with the resolved value\n            return resolvedValue;\n        }\n    }\n}\nexports.default = $Ref;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1083, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/refs.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst ref_js_1 = __importDefault(require(\"./ref.js\"));\nconst url = __importStar(require(\"./util/url.js\"));\nconst convert_path_to_posix_1 = __importDefault(require(\"./util/convert-path-to-posix\"));\n/**\n * When you call the resolve method, the value that gets passed to the callback function (or Promise) is a $Refs object. This same object is accessible via the parser.$refs property of $RefParser objects.\n *\n * This object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/refs.html\n */\nclass $Refs {\n    /**\n     * Returns the paths/URLs of all the files in your schema (including the main schema file).\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes\n     *\n     * @param types (optional) Optionally only return certain types of paths (\"file\", \"http\", etc.)\n     */\n    paths(...types) {\n        const paths = getPaths(this._$refs, types.flat());\n        return paths.map((path) => {\n            return (0, convert_path_to_posix_1.default)(path.decoded);\n        });\n    }\n    /**\n     * Returns a map of paths/URLs and their correspond values.\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes\n     *\n     * @param types (optional) Optionally only return values from certain locations (\"file\", \"http\", etc.)\n     */\n    values(...types) {\n        const $refs = this._$refs;\n        const paths = getPaths($refs, types.flat());\n        return paths.reduce((obj, path) => {\n            obj[(0, convert_path_to_posix_1.default)(path.decoded)] = $refs[path.encoded].value;\n            return obj;\n        }, {});\n    }\n    /**\n     * Returns `true` if the given path exists in the schema; otherwise, returns `false`\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref\n     *\n     * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n     */\n    /**\n     * Determines whether the given JSON reference exists.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param [options]\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this._resolve(path, \"\", options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference and returns the resolved value.\n     *\n     * @param path - The path being resolved, with a JSON pointer in the hash\n     * @param [options]\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this._resolve(path, \"\", options).value;\n    }\n    /**\n     * Sets the value at the given path in the schema. If the property, or any of its parents, don't exist, they will be created.\n     *\n     * @param path The JSON Reference path, optionally with a JSON Pointer in the hash\n     * @param value The value to assign. Can be anything (object, string, number, etc.)\n     */\n    set(path, value) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        $ref.set(absPath, value);\n    }\n    /**\n     * Returns the specified {@link $Ref} object, or undefined.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @returns\n     * @protected\n     */\n    _get$Ref(path) {\n        path = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(path);\n        return this._$refs[withoutHash];\n    }\n    /**\n     * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n     *\n     * @param path  - The file path or URL of the referenced file\n     */\n    _add(path) {\n        const withoutHash = url.stripHash(path);\n        const $ref = new ref_js_1.default(this);\n        $ref.path = withoutHash;\n        this._$refs[withoutHash] = $ref;\n        this._root$Ref = this._root$Ref || $ref;\n        return $ref;\n    }\n    /**\n     * Resolves the given JSON reference.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @param [options]\n     * @returns\n     * @protected\n     */\n    _resolve(path, pathFromRoot, options) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        return $ref.resolve(absPath, options, path, pathFromRoot);\n    }\n    constructor() {\n        /**\n         * A map of paths/urls to {@link $Ref} objects\n         *\n         * @type {object}\n         * @protected\n         */\n        this._$refs = {};\n        /**\n         * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n         * including the schema itself.\n         *\n         * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns the map of JSON references and their resolved values.\n         *\n         * @param [types] - Only return references of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n         *\n         * @returns {object}\n         */\n        this.toJSON = this.values;\n        /**\n         * Indicates whether the schema contains any circular references.\n         *\n         * @type {boolean}\n         */\n        this.circular = false;\n        this._$refs = {};\n        // @ts-ignore\n        this._root$Ref = null;\n    }\n}\nexports.default = $Refs;\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param $refs - The object whose keys are URL-encoded paths\n * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns\n */\nfunction getPaths($refs, types) {\n    let paths = Object.keys($refs);\n    // Filter the paths by type\n    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n    if (types.length > 0 && types[0]) {\n        paths = paths.filter((key) => {\n            return types.includes($refs[key].pathType);\n        });\n    }\n    // Decode local filesystem paths\n    return paths.map((path) => {\n        return {\n            encoded: path,\n            decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path,\n        };\n    });\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1315, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.all = all;\nexports.filter = filter;\nexports.sort = sort;\nexports.run = run;\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @returns\n */\nfunction all(plugins) {\n    return Object.keys(plugins || {})\n        .filter((key) => {\n        return typeof plugins[key] === \"object\";\n    })\n        .map((key) => {\n        plugins[key].name = key;\n        return plugins[key];\n    });\n}\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nfunction filter(plugins, method, file) {\n    return plugins.filter((plugin) => {\n        return !!getResult(plugin, method, file);\n    });\n}\n/**\n * Sorts the given plugins, in place, by their `order` property.\n */\nfunction sort(plugins) {\n    for (const plugin of plugins) {\n        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n    }\n    return plugins.sort((a, b) => {\n        return a.order - b.order;\n    });\n}\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nasync function run(plugins, method, file, $refs) {\n    let plugin;\n    let lastError;\n    let index = 0;\n    return new Promise((resolve, reject) => {\n        runNextPlugin();\n        function runNextPlugin() {\n            plugin = plugins[index++];\n            if (!plugin) {\n                // There are no more functions, so re-throw the last error\n                return reject(lastError);\n            }\n            try {\n                // console.log('  %s', plugin.name);\n                const result = getResult(plugin, method, file, callback, $refs);\n                if (result && typeof result.then === \"function\") {\n                    // A promise was returned\n                    result.then(onSuccess, onError);\n                }\n                else if (result !== undefined) {\n                    // A synchronous result was returned\n                    onSuccess(result);\n                }\n                else if (index === plugins.length) {\n                    throw new Error(\"No promise has been returned or callback has been called.\");\n                }\n            }\n            catch (e) {\n                onError(e);\n            }\n        }\n        function callback(err, result) {\n            if (err) {\n                onError(err);\n            }\n            else {\n                onSuccess(result);\n            }\n        }\n        function onSuccess(result) {\n            // console.log('    success');\n            resolve({\n                plugin,\n                result,\n            });\n        }\n        function onError(error) {\n            // console.log('    %s', err.message || err);\n            lastError = {\n                plugin,\n                error,\n            };\n            runNextPlugin();\n        }\n    });\n}\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an array, then it will be compared against the file extension.\n */\nfunction getResult(obj, prop, file, callback, $refs) {\n    const value = obj[prop];\n    if (typeof value === \"function\") {\n        return value.apply(obj, [file, callback, $refs]);\n    }\n    if (!callback) {\n        // The synchronous plugin functions (canParse and canRead)\n        // allow a \"shorthand\" syntax, where the user can match\n        // files by RegExp or by file extension.\n        if (value instanceof RegExp) {\n            return value.test(file.url);\n        }\n        else if (typeof value === \"string\") {\n            return value === file.extension;\n        }\n        else if (Array.isArray(value)) {\n            return value.indexOf(file.extension) !== -1;\n        }\n    }\n    return value;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,GAAG,GAAG;AACd,QAAQ,MAAM,GAAG;AACjB,QAAQ,IAAI,GAAG;AACf,QAAQ,GAAG,GAAG;AACd;;;;;CAKC,GACD,SAAS,IAAI,OAAO;IAChB,OAAO,OAAO,IAAI,CAAC,WAAW,CAAC,GAC1B,MAAM,CAAC,CAAC;QACT,OAAO,OAAO,OAAO,CAAC,IAAI,KAAK;IACnC,GACK,GAAG,CAAC,CAAC;QACN,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG;QACpB,OAAO,OAAO,CAAC,IAAI;IACvB;AACJ;AACA;;CAEC,GACD,SAAS,OAAO,OAAO,EAAE,MAAM,EAAE,IAAI;IACjC,OAAO,QAAQ,MAAM,CAAC,CAAC;QACnB,OAAO,CAAC,CAAC,UAAU,QAAQ,QAAQ;IACvC;AACJ;AACA;;CAEC,GACD,SAAS,KAAK,OAAO;IACjB,KAAK,MAAM,UAAU,QAAS;QAC1B,OAAO,KAAK,GAAG,OAAO,KAAK,IAAI,OAAO,gBAAgB;IAC1D;IACA,OAAO,QAAQ,IAAI,CAAC,CAAC,GAAG;QACpB,OAAO,EAAE,KAAK,GAAG,EAAE,KAAK;IAC5B;AACJ;AACA;;;;;;;CAOC,GACD,eAAe,IAAI,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK;IAC3C,IAAI;IACJ,IAAI;IACJ,IAAI,QAAQ;IACZ,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB;QACA,SAAS;YACL,SAAS,OAAO,CAAC,QAAQ;YACzB,IAAI,CAAC,QAAQ;gBACT,0DAA0D;gBAC1D,OAAO,OAAO;YAClB;YACA,IAAI;gBACA,oCAAoC;gBACpC,MAAM,SAAS,UAAU,QAAQ,QAAQ,MAAM,UAAU;gBACzD,IAAI,UAAU,OAAO,OAAO,IAAI,KAAK,YAAY;oBAC7C,yBAAyB;oBACzB,OAAO,IAAI,CAAC,WAAW;gBAC3B,OACK,IAAI,WAAW,WAAW;oBAC3B,oCAAoC;oBACpC,UAAU;gBACd,OACK,IAAI,UAAU,QAAQ,MAAM,EAAE;oBAC/B,MAAM,IAAI,MAAM;gBACpB;YACJ,EACA,OAAO,GAAG;gBACN,QAAQ;YACZ;QACJ;QACA,SAAS,SAAS,GAAG,EAAE,MAAM;YACzB,IAAI,KAAK;gBACL,QAAQ;YACZ,OACK;gBACD,UAAU;YACd;QACJ;QACA,SAAS,UAAU,MAAM;YACrB,8BAA8B;YAC9B,QAAQ;gBACJ;gBACA;YACJ;QACJ;QACA,SAAS,QAAQ,KAAK;YAClB,6CAA6C;YAC7C,YAAY;gBACR;gBACA;YACJ;YACA;QACJ;IACJ;AACJ;AACA;;;;;CAKC,GACD,SAAS,UAAU,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK;IAC/C,MAAM,QAAQ,GAAG,CAAC,KAAK;IACvB,IAAI,OAAO,UAAU,YAAY;QAC7B,OAAO,MAAM,KAAK,CAAC,KAAK;YAAC;YAAM;YAAU;SAAM;IACnD;IACA,IAAI,CAAC,UAAU;QACX,0DAA0D;QAC1D,uDAAuD;QACvD,wCAAwC;QACxC,IAAI,iBAAiB,QAAQ;YACzB,OAAO,MAAM,IAAI,CAAC,KAAK,GAAG;QAC9B,OACK,IAAI,OAAO,UAAU,UAAU;YAChC,OAAO,UAAU,KAAK,SAAS;QACnC,OACK,IAAI,MAAM,OAAO,CAAC,QAAQ;YAC3B,OAAO,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,CAAC;QAC9C;IACJ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/parse.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst url = __importStar(require(\"./util/url.js\"));\nconst plugins = __importStar(require(\"./util/plugins.js\"));\nconst errors_js_1 = require(\"./util/errors.js\");\n/**\n * Reads and parses the specified file path or URL.\n */\nasync function parse(path, $refs, options) {\n    // Remove the URL fragment, if any\n    const hashIndex = path.indexOf(\"#\");\n    let hash = \"\";\n    if (hashIndex >= 0) {\n        hash = path.substring(hashIndex);\n        // Remove the URL fragment, if any\n        path = path.substring(0, hashIndex);\n    }\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    const $ref = $refs._add(path);\n    // This \"file object\" will be passed to all resolvers and parsers.\n    const file = {\n        url: path,\n        hash,\n        extension: url.getExtension(path),\n    };\n    // Read the file and then parse the data\n    try {\n        const resolver = await readFile(file, options, $refs);\n        $ref.pathType = resolver.plugin.name;\n        file.data = resolver.result;\n        const parser = await parseFile(file, options, $refs);\n        $ref.value = parser.result;\n        return parser.result;\n    }\n    catch (err) {\n        if ((0, errors_js_1.isHandledError)(err)) {\n            $ref.value = err;\n        }\n        throw err;\n    }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param options\n * @param $refs\n * @returns\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nasync function readFile(file, options, $refs) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    try {\n        const data = await plugins.run(resolvers, \"read\", file, $refs);\n        return data;\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedResolverError(file.url);\n        }\n        else if (!err || !(\"error\" in err)) {\n            // Throw a generic, friendly error.\n            throw ono_1.ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`);\n        }\n        // Throw the original error, if it's one of our own (user-friendly) errors.\n        else if (err.error instanceof errors_js_1.ResolverError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ResolverError(err, file.url);\n        }\n    }\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param options\n * @param $refs\n *\n * @returns\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nasync function parseFile(file, options, $refs) {\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    try {\n        const parser = await plugins.run(parsers, \"parse\", file, $refs);\n        if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n            throw ono_1.ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`);\n        }\n        else {\n            return parser;\n        }\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedParserError(file.url);\n        }\n        else if (err && err.message && err.message.startsWith(\"Error parsing\")) {\n            throw err;\n        }\n        else if (!err || !(\"error\" in err)) {\n            throw ono_1.ono.syntax(`Unable to parse ${file.url}`);\n        }\n        else if (err.error instanceof errors_js_1.ParserError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ParserError(err.error.message, file.url);\n        }\n    }\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param value\n * @returns\n */\nfunction isEmpty(value) {\n    return (value === undefined ||\n        (typeof value === \"object\" && Object.keys(value).length === 0) ||\n        (typeof value === \"string\" && value.trim().length === 0) ||\n        (Buffer.isBuffer(value) && value.length === 0));\n}\nexports.default = parse;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1618, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_js_1 = require(\"../util/errors.js\");\nexports.default = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 100,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: \".json\",\n    /**\n     * Allow JSON files with byte order marks (BOM)\n     */\n    allowBOM: true,\n    /**\n     * Parses the given file as JSON\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            if (data.trim().length === 0) {\n                return; // This mirrors the YAML behavior\n            }\n            else {\n                try {\n                    return JSON.parse(data);\n                }\n                catch (e) {\n                    if (this.allowBOM) {\n                        try {\n                            // find the first curly brace\n                            const firstCurlyBrace = data.indexOf(\"{\");\n                            // remove any characters before the first curly brace\n                            data = data.slice(firstCurlyBrace);\n                            return JSON.parse(data);\n                        }\n                        catch (e) {\n                            throw new errors_js_1.ParserError(e.message, file.url);\n                        }\n                    }\n                    throw new errors_js_1.ParserError(e.message, file.url);\n                }\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;KAEC,GACD,YAAY;IACZ;;;;;KAKC,GACD,UAAU;IACV;;KAEC,GACD,UAAU;IACV;;KAEC,GACD,MAAM,OAAM,IAAI;QACZ,IAAI,OAAO,KAAK,IAAI;QACpB,IAAI,OAAO,QAAQ,CAAC,OAAO;YACvB,OAAO,KAAK,QAAQ;QACxB;QACA,IAAI,OAAO,SAAS,UAAU;YAC1B,IAAI,KAAK,IAAI,GAAG,MAAM,KAAK,GAAG;gBAC1B,QAAQ,iCAAiC;YAC7C,OACK;gBACD,IAAI;oBACA,OAAO,KAAK,KAAK,CAAC;gBACtB,EACA,OAAO,GAAG;oBACN,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,IAAI;4BACA,6BAA6B;4BAC7B,MAAM,kBAAkB,KAAK,OAAO,CAAC;4BACrC,qDAAqD;4BACrD,OAAO,KAAK,KAAK,CAAC;4BAClB,OAAO,KAAK,KAAK,CAAC;wBACtB,EACA,OAAO,GAAG;4BACN,MAAM,IAAI,YAAY,WAAW,CAAC,EAAE,OAAO,EAAE,KAAK,GAAG;wBACzD;oBACJ;oBACA,MAAM,IAAI,YAAY,WAAW,CAAC,EAAE,OAAO,EAAE,KAAK,GAAG;gBACzD;YACJ;QACJ,OACK;YACD,8EAA8E;YAC9E,OAAO;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1676, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_js_1 = require(\"../util/errors.js\");\nconst js_yaml_1 = __importDefault(require(\"js-yaml\"));\nconst js_yaml_2 = require(\"js-yaml\");\nexports.default = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 200,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: [\".yaml\", \".yml\", \".json\"], // JSON is valid YAML\n    /**\n     * Parses the given file as YAML\n     *\n     * @param file           - An object containing information about the referenced file\n     * @param file.url       - The full URL of the referenced file\n     * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n     * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n     * @returns\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            try {\n                return js_yaml_1.default.load(data, { schema: js_yaml_2.JSON_SCHEMA });\n            }\n            catch (e) {\n                throw new errors_js_1.ParserError(e?.message || \"Parser Error\", file.url);\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,SAAU,GAAG;IACjE,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,WAAW;IAAI;AAC5D;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,MAAM,YAAY;AAClB,MAAM;AACN,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;KAEC,GACD,YAAY;IACZ;;;;;KAKC,GACD,UAAU;QAAC;QAAS;QAAQ;KAAQ;IACpC;;;;;;;;KAQC,GACD,MAAM,OAAM,IAAI;QACZ,IAAI,OAAO,KAAK,IAAI;QACpB,IAAI,OAAO,QAAQ,CAAC,OAAO;YACvB,OAAO,KAAK,QAAQ;QACxB;QACA,IAAI,OAAO,SAAS,UAAU;YAC1B,IAAI;gBACA,OAAO,UAAU,OAAO,CAAC,IAAI,CAAC,MAAM;oBAAE,QAAQ,UAAU,WAAW;gBAAC;YACxE,EACA,OAAO,GAAG;gBACN,MAAM,IAAI,YAAY,WAAW,CAAC,GAAG,WAAW,gBAAgB,KAAK,GAAG;YAC5E;QACJ,OACK;YACD,8EAA8E;YAC9E,OAAO;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1735, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_js_1 = require(\"../util/errors.js\");\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nexports.default = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 300,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * The encoding that the text is expected to be in.\n     */\n    encoding: \"utf8\",\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a string or Buffer, and has a known text-based extension\n        return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given file as text\n     */\n    parse(file) {\n        if (typeof file.data === \"string\") {\n            return file.data;\n        }\n        else if (Buffer.isBuffer(file.data)) {\n            return file.data.toString(this.encoding);\n        }\n        else {\n            throw new errors_js_1.ParserError(\"data is not text\", file.url);\n        }\n    },\n};\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,MAAM,cAAc;AACpB,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;KAEC,GACD,YAAY;IACZ;;KAEC,GACD,UAAU;IACV;;;;;KAKC,GACD,UAAS,IAAI;QACT,0FAA0F;QAC1F,OAAO,CAAC,OAAO,KAAK,IAAI,KAAK,YAAY,OAAO,QAAQ,CAAC,KAAK,IAAI,CAAC,KAAK,YAAY,IAAI,CAAC,KAAK,GAAG;IACrG;IACA;;KAEC,GACD,OAAM,IAAI;QACN,IAAI,OAAO,KAAK,IAAI,KAAK,UAAU;YAC/B,OAAO,KAAK,IAAI;QACpB,OACK,IAAI,OAAO,QAAQ,CAAC,KAAK,IAAI,GAAG;YACjC,OAAO,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ;QAC3C,OACK;YACD,MAAM,IAAI,YAAY,WAAW,CAAC,oBAAoB,KAAK,GAAG;QAClE;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1775, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nexports.default = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 400,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a Buffer, and has a known binary extension\n        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given data as a Buffer (byte array).\n     */\n    parse(file) {\n        if (Buffer.isBuffer(file.data)) {\n            return file.data;\n        }\n        else {\n            // This will reject if data is anything other than a string or typed array\n            return Buffer.from(file.data);\n        }\n    },\n};\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM,gBAAgB;AACtB,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;KAEC,GACD,YAAY;IACZ;;;;;KAKC,GACD,UAAS,IAAI;QACT,4EAA4E;QAC5E,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI,KAAK,cAAc,IAAI,CAAC,KAAK,GAAG;IACpE;IACA;;KAEC,GACD,OAAM,IAAI;QACN,IAAI,OAAO,QAAQ,CAAC,KAAK,IAAI,GAAG;YAC5B,OAAO,KAAK,IAAI;QACpB,OACK;YACD,0EAA0E;YAC1E,OAAO,OAAO,IAAI,CAAC,KAAK,IAAI;QAChC;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst url = __importStar(require(\"../util/url.js\"));\nconst errors_js_1 = require(\"../util/errors.js\");\nexports.default = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 100,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isFileSystemPath(file.url);\n    },\n    /**\n     * Reads the given file and returns its raw contents as a Buffer.\n     */\n    async read(file) {\n        let path;\n        try {\n            path = url.toFileSystemPath(file.url);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError(ono_1.ono.uri(err, `Malformed URI: ${file.url}`), file.url);\n        }\n        try {\n            return await fs_1.default.promises.readFile(path);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error opening file \"${path}\"`), path);\n        }\n    },\n};\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,CAAC,OAAO,MAAM,GAAI,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IAC1F,IAAI,OAAO,WAAW,KAAK;IAC3B,IAAI,OAAO,OAAO,wBAAwB,CAAC,GAAG;IAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,OAAO,CAAC,EAAE,UAAU,GAAG,KAAK,QAAQ,IAAI,KAAK,YAAY,GAAG;QACjF,OAAO;YAAE,YAAY;YAAM,KAAK;gBAAa,OAAO,CAAC,CAAC,EAAE;YAAE;QAAE;IAC9D;IACA,OAAO,cAAc,CAAC,GAAG,IAAI;AACjC,IAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IACtB,IAAI,OAAO,WAAW,KAAK;IAC3B,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;AAChB,CAAE;AACF,IAAI,qBAAqB,4DAAS,yDAAK,kBAAkB,IAAK,CAAC,OAAO,MAAM,GAAI,SAAS,CAAC,EAAE,CAAC;IACzF,OAAO,cAAc,CAAC,GAAG,WAAW;QAAE,YAAY;QAAM,OAAO;IAAE;AACrE,IAAK,SAAS,CAAC,EAAE,CAAC;IACd,CAAC,CAAC,UAAU,GAAG;AACnB,CAAC;AACD,IAAI,eAAe,4DAAS,yDAAK,YAAY,IAAK,AAAC;IAC/C,IAAI,UAAU,SAAS,CAAC;QACpB,UAAU,OAAO,mBAAmB,IAAI,SAAU,CAAC;YAC/C,IAAI,KAAK,EAAE;YACX,IAAK,IAAI,KAAK,EAAG,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,GAAG;YACjF,OAAO;QACX;QACA,OAAO,QAAQ;IACnB;IACA,OAAO,SAAU,GAAG;QAChB,IAAI,OAAO,IAAI,UAAU,EAAE,OAAO;QAClC,IAAI,SAAS,CAAC;QACd,IAAI,OAAO,MAAM;YAAA,IAAK,IAAI,IAAI,QAAQ,MAAM,IAAI,GAAG,IAAI,EAAE,MAAM,EAAE,IAAK,IAAI,CAAC,CAAC,EAAE,KAAK,WAAW,gBAAgB,QAAQ,KAAK,CAAC,CAAC,EAAE;QAAC;QAChI,mBAAmB,QAAQ;QAC3B,OAAO;IACX;AACJ;AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,SAAU,GAAG;IACjE,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,WAAW;IAAI;AAC5D;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM,OAAO;AACb,MAAM;AACN,MAAM,MAAM;AACZ,MAAM;AACN,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;;;KAIC,GACD,SAAQ,IAAI;QACR,OAAO,IAAI,gBAAgB,CAAC,KAAK,GAAG;IACxC;IACA;;KAEC,GACD,MAAM,MAAK,IAAI;QACX,IAAI;QACJ,IAAI;YACA,OAAO,IAAI,gBAAgB,CAAC,KAAK,GAAG;QACxC,EACA,OAAO,KAAK;YACR,MAAM,IAAI,YAAY,aAAa,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,GAAG,EAAE,GAAG,KAAK,GAAG;QAClG;QACA,IAAI;YACA,OAAO,MAAM,KAAK,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAChD,EACA,OAAO,KAAK;YACR,MAAM,IAAI,YAAY,aAAa,CAAC,CAAC,GAAG,MAAM,GAAG,EAAE,KAAK,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC,GAAG;QAC7F;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1896, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst url = __importStar(require(\"../util/url.js\"));\nconst errors_js_1 = require(\"../util/errors.js\");\nexports.default = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 200,\n    /**\n     * HTTP headers to send when downloading files.\n     *\n     * @example:\n     * {\n     *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n     *   Accept: \"application/json\"\n     * }\n     */\n    headers: null,\n    /**\n     * HTTP request timeout (in milliseconds).\n     */\n    timeout: 60000, // 60 seconds\n    /**\n     * The maximum number of HTTP redirects to follow.\n     * To disable automatic following of redirects, set this to zero.\n     */\n    redirects: 5,\n    /**\n     * The `withCredentials` option of XMLHttpRequest.\n     * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n     */\n    withCredentials: false,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isHttp(file.url);\n    },\n    /**\n     * Reads the given URL and returns its raw contents as a Buffer.\n     */\n    read(file) {\n        const u = url.parse(file.url);\n        if (typeof window !== \"undefined\" && !u.protocol) {\n            // Use the protocol of the current page\n            u.protocol = url.parse(location.href).protocol;\n        }\n        return download(u, this);\n    },\n};\n/**\n * Downloads the given file.\n * @returns\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nasync function download(u, httpOptions, _redirects) {\n    u = url.parse(u);\n    const redirects = _redirects || [];\n    redirects.push(u.href);\n    try {\n        const res = await get(u, httpOptions);\n        if (res.status >= 400) {\n            throw (0, ono_1.ono)({ status: res.status }, `HTTP ERROR ${res.status}`);\n        }\n        else if (res.status >= 300) {\n            if (!Number.isNaN(httpOptions.redirects) && redirects.length > httpOptions.redirects) {\n                throw new errors_js_1.ResolverError((0, ono_1.ono)({ status: res.status }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`));\n            }\n            else if (!(\"location\" in res.headers) || !res.headers.location) {\n                throw (0, ono_1.ono)({ status: res.status }, `HTTP ${res.status} redirect with no location header`);\n            }\n            else {\n                const redirectTo = url.resolve(u.href, res.headers.location);\n                return download(redirectTo, httpOptions, redirects);\n            }\n        }\n        else {\n            if (res.body) {\n                const buf = await res.arrayBuffer();\n                return Buffer.from(buf);\n            }\n            return Buffer.alloc(0);\n        }\n    }\n    catch (err) {\n        throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error downloading ${u.href}`), u.href);\n    }\n}\n/**\n * Sends an HTTP GET request.\n * The promise resolves with the HTTP Response object.\n */\nasync function get(u, httpOptions) {\n    let controller;\n    let timeoutId;\n    if (httpOptions.timeout) {\n        controller = new AbortController();\n        timeoutId = setTimeout(() => controller.abort(), httpOptions.timeout);\n    }\n    const response = await fetch(u, {\n        method: \"GET\",\n        headers: httpOptions.headers || {},\n        credentials: httpOptions.withCredentials ? \"include\" : \"same-origin\",\n        signal: controller ? controller.signal : null,\n    });\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    return response;\n}\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,CAAC,OAAO,MAAM,GAAI,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IAC1F,IAAI,OAAO,WAAW,KAAK;IAC3B,IAAI,OAAO,OAAO,wBAAwB,CAAC,GAAG;IAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,OAAO,CAAC,EAAE,UAAU,GAAG,KAAK,QAAQ,IAAI,KAAK,YAAY,GAAG;QACjF,OAAO;YAAE,YAAY;YAAM,KAAK;gBAAa,OAAO,CAAC,CAAC,EAAE;YAAE;QAAE;IAC9D;IACA,OAAO,cAAc,CAAC,GAAG,IAAI;AACjC,IAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IACtB,IAAI,OAAO,WAAW,KAAK;IAC3B,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;AAChB,CAAE;AACF,IAAI,qBAAqB,4DAAS,yDAAK,kBAAkB,IAAK,CAAC,OAAO,MAAM,GAAI,SAAS,CAAC,EAAE,CAAC;IACzF,OAAO,cAAc,CAAC,GAAG,WAAW;QAAE,YAAY;QAAM,OAAO;IAAE;AACrE,IAAK,SAAS,CAAC,EAAE,CAAC;IACd,CAAC,CAAC,UAAU,GAAG;AACnB,CAAC;AACD,IAAI,eAAe,4DAAS,yDAAK,YAAY,IAAK,AAAC;IAC/C,IAAI,UAAU,SAAS,CAAC;QACpB,UAAU,OAAO,mBAAmB,IAAI,SAAU,CAAC;YAC/C,IAAI,KAAK,EAAE;YACX,IAAK,IAAI,KAAK,EAAG,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,GAAG;YACjF,OAAO;QACX;QACA,OAAO,QAAQ;IACnB;IACA,OAAO,SAAU,GAAG;QAChB,IAAI,OAAO,IAAI,UAAU,EAAE,OAAO;QAClC,IAAI,SAAS,CAAC;QACd,IAAI,OAAO,MAAM;YAAA,IAAK,IAAI,IAAI,QAAQ,MAAM,IAAI,GAAG,IAAI,EAAE,MAAM,EAAE,IAAK,IAAI,CAAC,CAAC,EAAE,KAAK,WAAW,gBAAgB,QAAQ,KAAK,CAAC,CAAC,EAAE;QAAC;QAChI,mBAAmB,QAAQ;QAC3B,OAAO;IACX;AACJ;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,MAAM,MAAM;AACZ,MAAM;AACN,QAAQ,OAAO,GAAG;IACd;;KAEC,GACD,OAAO;IACP;;;;;;;;KAQC,GACD,SAAS;IACT;;KAEC,GACD,SAAS;IACT;;;KAGC,GACD,WAAW;IACX;;;KAGC,GACD,iBAAiB;IACjB;;;;KAIC,GACD,SAAQ,IAAI;QACR,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG;IAC9B;IACA;;KAEC,GACD,MAAK,IAAI;QACL,MAAM,IAAI,IAAI,KAAK,CAAC,KAAK,GAAG;QAC5B;;QAIA,OAAO,SAAS,GAAG,IAAI;IAC3B;AACJ;AACA;;;;CAIC,GACD,eAAe,SAAS,CAAC,EAAE,WAAW,EAAE,UAAU;IAC9C,IAAI,IAAI,KAAK,CAAC;IACd,MAAM,YAAY,cAAc,EAAE;IAClC,UAAU,IAAI,CAAC,EAAE,IAAI;IACrB,IAAI;QACA,MAAM,MAAM,MAAM,IAAI,GAAG;QACzB,IAAI,IAAI,MAAM,IAAI,KAAK;YACnB,MAAM,CAAC,GAAG,MAAM,GAAG,EAAE;gBAAE,QAAQ,IAAI,MAAM;YAAC,GAAG,CAAC,WAAW,EAAE,IAAI,MAAM,EAAE;QAC3E,OACK,IAAI,IAAI,MAAM,IAAI,KAAK;YACxB,IAAI,CAAC,OAAO,KAAK,CAAC,YAAY,SAAS,KAAK,UAAU,MAAM,GAAG,YAAY,SAAS,EAAE;gBAClF,MAAM,IAAI,YAAY,aAAa,CAAC,CAAC,GAAG,MAAM,GAAG,EAAE;oBAAE,QAAQ,IAAI,MAAM;gBAAC,GAAG,CAAC,kBAAkB,EAAE,SAAS,CAAC,EAAE,CAAC,4BAA4B,EAAE,UAAU,IAAI,CAAC,UAAU;YACxK,OACK,IAAI,CAAC,CAAC,cAAc,IAAI,OAAO,KAAK,CAAC,IAAI,OAAO,CAAC,QAAQ,EAAE;gBAC5D,MAAM,CAAC,GAAG,MAAM,GAAG,EAAE;oBAAE,QAAQ,IAAI,MAAM;gBAAC,GAAG,CAAC,KAAK,EAAE,IAAI,MAAM,CAAC,iCAAiC,CAAC;YACtG,OACK;gBACD,MAAM,aAAa,IAAI,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,OAAO,CAAC,QAAQ;gBAC3D,OAAO,SAAS,YAAY,aAAa;YAC7C;QACJ,OACK;YACD,IAAI,IAAI,IAAI,EAAE;gBACV,MAAM,MAAM,MAAM,IAAI,WAAW;gBACjC,OAAO,OAAO,IAAI,CAAC;YACvB;YACA,OAAO,OAAO,KAAK,CAAC;QACxB;IACJ,EACA,OAAO,KAAK;QACR,MAAM,IAAI,YAAY,aAAa,CAAC,CAAC,GAAG,MAAM,GAAG,EAAE,KAAK,CAAC,kBAAkB,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI;IAClG;AACJ;AACA;;;CAGC,GACD,eAAe,IAAI,CAAC,EAAE,WAAW;IAC7B,IAAI;IACJ,IAAI;IACJ,IAAI,YAAY,OAAO,EAAE;QACrB,aAAa,IAAI;QACjB,YAAY,WAAW,IAAM,WAAW,KAAK,IAAI,YAAY,OAAO;IACxE;IACA,MAAM,WAAW,MAAM,MAAM,GAAG;QAC5B,QAAQ;QACR,SAAS,YAAY,OAAO,IAAI,CAAC;QACjC,aAAa,YAAY,eAAe,GAAG,YAAY;QACvD,QAAQ,aAAa,WAAW,MAAM,GAAG;IAC7C;IACA,IAAI,WAAW;QACX,aAAa;IACjB;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/options.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNewOptions = exports.getJsonSchemaRefParserDefaultOptions = void 0;\nconst json_js_1 = __importDefault(require(\"./parsers/json.js\"));\nconst yaml_js_1 = __importDefault(require(\"./parsers/yaml.js\"));\nconst text_js_1 = __importDefault(require(\"./parsers/text.js\"));\nconst binary_js_1 = __importDefault(require(\"./parsers/binary.js\"));\nconst file_js_1 = __importDefault(require(\"./resolvers/file.js\"));\nconst http_js_1 = __importDefault(require(\"./resolvers/http.js\"));\nconst getJsonSchemaRefParserDefaultOptions = () => {\n    const defaults = {\n        /**\n         * Determines how different types of files will be parsed.\n         *\n         * You can add additional parsers of your own, replace an existing one with\n         * your own implementation, or disable any parser by setting it to false.\n         */\n        parse: {\n            json: { ...json_js_1.default },\n            yaml: { ...yaml_js_1.default },\n            text: { ...text_js_1.default },\n            binary: { ...binary_js_1.default },\n        },\n        /**\n         * Determines how JSON References will be resolved.\n         *\n         * You can add additional resolvers of your own, replace an existing one with\n         * your own implementation, or disable any resolver by setting it to false.\n         */\n        resolve: {\n            file: { ...file_js_1.default },\n            http: { ...http_js_1.default },\n            /**\n             * Determines whether external $ref pointers will be resolved.\n             * If this option is disabled, then none of above resolvers will be called.\n             * Instead, external $ref pointers will simply be ignored.\n             *\n             * @type {boolean}\n             */\n            external: true,\n        },\n        /**\n         * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n         * causes it to keep processing as much as possible and then throw a single error that contains all errors\n         * that were encountered.\n         */\n        continueOnError: false,\n        /**\n         * Determines the types of JSON references that are allowed.\n         */\n        dereference: {\n            /**\n             * Dereference circular (recursive) JSON references?\n             * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n             * If \"ignore\", then circular references will not be dereferenced.\n             *\n             * @type {boolean|string}\n             */\n            circular: true,\n            /**\n             * A function, called for each path, which can return true to stop this path and all\n             * subpaths from being dereferenced further. This is useful in schemas where some\n             * subpaths contain literal $ref keys that should not be dereferenced.\n             *\n             * @type {function}\n             */\n            excludedPathMatcher: () => false,\n            referenceResolution: \"relative\",\n        },\n        mutateInputSchema: true,\n    };\n    return defaults;\n};\nexports.getJsonSchemaRefParserDefaultOptions = getJsonSchemaRefParserDefaultOptions;\nconst getNewOptions = (options) => {\n    const newOptions = (0, exports.getJsonSchemaRefParserDefaultOptions)();\n    if (options) {\n        merge(newOptions, options);\n    }\n    return newOptions;\n};\nexports.getNewOptions = getNewOptions;\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param target - The object that we're populating\n * @param source - The options that are being merged\n * @returns\n */\nfunction merge(target, source) {\n    if (isMergeable(source)) {\n        // prevent prototype pollution\n        const keys = Object.keys(source).filter((key) => ![\"__proto__\", \"constructor\", \"prototype\"].includes(key));\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const sourceSetting = source[key];\n            const targetSetting = target[key];\n            if (isMergeable(sourceSetting)) {\n                // It's a nested object, so merge it recursively\n                target[key] = merge(targetSetting || {}, sourceSetting);\n            }\n            else if (sourceSetting !== undefined) {\n                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n                target[key] = sourceSetting;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param val\n * @returns\n */\nfunction isMergeable(val) {\n    return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,SAAU,GAAG;IACjE,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,WAAW;IAAI;AAC5D;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,aAAa,GAAG,QAAQ,oCAAoC,GAAG,KAAK;AAC5E,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,cAAc;AACpB,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,uCAAuC;IACzC,MAAM,WAAW;QACb;;;;;SAKC,GACD,OAAO;YACH,MAAM;gBAAE,GAAG,UAAU,OAAO;YAAC;YAC7B,MAAM;gBAAE,GAAG,UAAU,OAAO;YAAC;YAC7B,MAAM;gBAAE,GAAG,UAAU,OAAO;YAAC;YAC7B,QAAQ;gBAAE,GAAG,YAAY,OAAO;YAAC;QACrC;QACA;;;;;SAKC,GACD,SAAS;YACL,MAAM;gBAAE,GAAG,UAAU,OAAO;YAAC;YAC7B,MAAM;gBAAE,GAAG,UAAU,OAAO;YAAC;YAC7B;;;;;;aAMC,GACD,UAAU;QACd;QACA;;;;SAIC,GACD,iBAAiB;QACjB;;SAEC,GACD,aAAa;YACT;;;;;;aAMC,GACD,UAAU;YACV;;;;;;aAMC,GACD,qBAAqB,IAAM;YAC3B,qBAAqB;QACzB;QACA,mBAAmB;IACvB;IACA,OAAO;AACX;AACA,QAAQ,oCAAoC,GAAG;AAC/C,MAAM,gBAAgB,CAAC;IACnB,MAAM,aAAa,CAAC,GAAG,QAAQ,oCAAoC;IACnE,IAAI,SAAS;QACT,MAAM,YAAY;IACtB;IACA,OAAO;AACX;AACA,QAAQ,aAAa,GAAG;AACxB;;;;;;CAMC,GACD,SAAS,MAAM,MAAM,EAAE,MAAM;IACzB,IAAI,YAAY,SAAS;QACrB,8BAA8B;QAC9B,MAAM,OAAO,OAAO,IAAI,CAAC,QAAQ,MAAM,CAAC,CAAC,MAAQ,CAAC;gBAAC;gBAAa;gBAAe;aAAY,CAAC,QAAQ,CAAC;QACrG,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,MAAM,MAAM,IAAI,CAAC,EAAE;YACnB,MAAM,gBAAgB,MAAM,CAAC,IAAI;YACjC,MAAM,gBAAgB,MAAM,CAAC,IAAI;YACjC,IAAI,YAAY,gBAAgB;gBAC5B,gDAAgD;gBAChD,MAAM,CAAC,IAAI,GAAG,MAAM,iBAAiB,CAAC,GAAG;YAC7C,OACK,IAAI,kBAAkB,WAAW;gBAClC,kGAAkG;gBAClG,MAAM,CAAC,IAAI,GAAG;YAClB;QACJ;IACJ;IACA,OAAO;AACX;AACA;;;;;;CAMC,GACD,SAAS,YAAY,GAAG;IACpB,OAAO,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC,eAAe,MAAM,KAAK,CAAC,CAAC,eAAe,IAAI;AACrH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2183, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeArgs = normalizeArgs;\nconst options_js_1 = require(\"./options.js\");\n/**\n * Normalizes the given arguments, accounting for optional args.\n */\nfunction normalizeArgs(_args) {\n    let path;\n    let schema;\n    let options;\n    let callback;\n    const args = Array.prototype.slice.call(_args);\n    if (typeof args[args.length - 1] === \"function\") {\n        // The last parameter is a callback function\n        callback = args.pop();\n    }\n    if (typeof args[0] === \"string\") {\n        // The first parameter is the path\n        path = args[0];\n        if (typeof args[2] === \"object\") {\n            // The second parameter is the schema, and the third parameter is the options\n            schema = args[1];\n            options = args[2];\n        }\n        else {\n            // The second parameter is the options\n            schema = undefined;\n            options = args[1];\n        }\n    }\n    else {\n        // The first parameter is the schema\n        path = \"\";\n        schema = args[0];\n        options = args[1];\n    }\n    try {\n        options = (0, options_js_1.getNewOptions)(options);\n    }\n    catch (e) {\n        console.error(`JSON Schema Ref Parser: Error normalizing options: ${e}`);\n    }\n    if (!options.mutateInputSchema && typeof schema === \"object\") {\n        // Make a deep clone of the schema, so that we don't alter the original object\n        schema = JSON.parse(JSON.stringify(schema));\n    }\n    return {\n        path,\n        schema,\n        options,\n        callback,\n    };\n}\nexports.default = normalizeArgs;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,aAAa,GAAG;AACxB,MAAM;AACN;;CAEC,GACD,SAAS,cAAc,KAAK;IACxB,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,MAAM,OAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC;IACxC,IAAI,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,KAAK,YAAY;QAC7C,4CAA4C;QAC5C,WAAW,KAAK,GAAG;IACvB;IACA,IAAI,OAAO,IAAI,CAAC,EAAE,KAAK,UAAU;QAC7B,kCAAkC;QAClC,OAAO,IAAI,CAAC,EAAE;QACd,IAAI,OAAO,IAAI,CAAC,EAAE,KAAK,UAAU;YAC7B,6EAA6E;YAC7E,SAAS,IAAI,CAAC,EAAE;YAChB,UAAU,IAAI,CAAC,EAAE;QACrB,OACK;YACD,sCAAsC;YACtC,SAAS;YACT,UAAU,IAAI,CAAC,EAAE;QACrB;IACJ,OACK;QACD,oCAAoC;QACpC,OAAO;QACP,SAAS,IAAI,CAAC,EAAE;QAChB,UAAU,IAAI,CAAC,EAAE;IACrB;IACA,IAAI;QACA,UAAU,CAAC,GAAG,aAAa,aAAa,EAAE;IAC9C,EACA,OAAO,GAAG;QACN,QAAQ,KAAK,CAAC,CAAC,mDAAmD,EAAE,GAAG;IAC3E;IACA,IAAI,CAAC,QAAQ,iBAAiB,IAAI,OAAO,WAAW,UAAU;QAC1D,8EAA8E;QAC9E,SAAS,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC;IACvC;IACA,OAAO;QACH;QACA;QACA;QACA;IACJ;AACJ;AACA,QAAQ,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2239, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ref_js_1 = __importDefault(require(\"./ref.js\"));\nconst pointer_js_1 = __importDefault(require(\"./pointer.js\"));\nconst parse_js_1 = __importDefault(require(\"./parse.js\"));\nconst url = __importStar(require(\"./util/url.js\"));\nconst errors_js_1 = require(\"./util/errors.js\");\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @returns\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal(parser, options) {\n    if (!options.resolve?.external) {\n        // Nothing to resolve, so exit early\n        return Promise.resolve();\n    }\n    try {\n        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n        const promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n        return Promise.all(promises);\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {boolean} external - Whether `obj` was found in an external document.\n * @param $refs\n * @param options\n * @param seen - Internal.\n *\n * @returns\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl(obj, path, $refs, options, seen, external) {\n    seen || (seen = new Set());\n    let promises = [];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n        seen.add(obj); // Track previously seen objects to avoid infinite recursion\n        if (ref_js_1.default.isExternal$Ref(obj)) {\n            promises.push(resolve$Ref(obj, path, $refs, options));\n        }\n        const keys = Object.keys(obj);\n        for (const key of keys) {\n            const keyPath = pointer_js_1.default.join(path, key);\n            const value = obj[key];\n            promises = promises.concat(crawl(value, keyPath, $refs, options, seen, external));\n        }\n    }\n    return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param $refs\n * @param options\n *\n * @returns\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref($ref, path, $refs, options) {\n    const shouldResolveOnCwd = options.dereference?.externalReferenceResolution === \"root\";\n    const resolvedPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const withoutHash = url.stripHash(resolvedPath);\n    // $ref.$ref = url.relative($refs._root$Ref.path, resolvedPath);\n    // Do we already have this $ref?\n    const ref = $refs._$refs[withoutHash];\n    if (ref) {\n        // We've already parsed this $ref, so use the existing value\n        return Promise.resolve(ref.value);\n    }\n    // Parse the $referenced file/url\n    try {\n        const result = await (0, parse_js_1.default)(resolvedPath, $refs, options);\n        // Crawl the parsed value\n        // console.log('Resolving $ref pointers in %s', withoutHash);\n        const promises = crawl(result, withoutHash + \"#\", $refs, options, new Set(), true);\n        return Promise.all(promises);\n    }\n    catch (err) {\n        if (!options?.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n            throw err;\n        }\n        if ($refs._$refs[withoutHash]) {\n            err.source = decodeURI(url.stripHash(path));\n            err.path = url.safePointerToPath(url.getHash(path));\n        }\n        return [];\n    }\n}\nexports.default = resolveExternal;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2394, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/bundle.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ref_js_1 = __importDefault(require(\"./ref.js\"));\nconst pointer_js_1 = __importDefault(require(\"./pointer.js\"));\nconst url = __importStar(require(\"./util/url.js\"));\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param parser\n * @param options\n */\nfunction bundle(parser, options) {\n    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n    // Build an inventory of all $ref pointers in the JSON Schema\n    const inventory = [];\n    crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n    // Remap all $ref pointers\n    remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param key - The property key of `parent` to be crawled\n * @param path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of the property being crawled, from the schema root\n * @param indirections\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const obj = key === null ? parent : parent[key];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n        if (ref_js_1.default.isAllowed$Ref(obj)) {\n            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n        }\n        else {\n            // Crawl the object in a specific order that's optimized for bundling.\n            // This is important because it determines how `pathFromRoot` gets built,\n            // which later determines which keys get dereferenced and which ones get remapped\n            const keys = Object.keys(obj).sort((a, b) => {\n                // Most people will expect references to be bundled into the the \"definitions\" property,\n                // so we always crawl that property first, if it exists.\n                if (a === \"definitions\") {\n                    return -1;\n                }\n                else if (b === \"definitions\") {\n                    return 1;\n                }\n                else {\n                    // Otherwise, crawl the keys based on their length.\n                    // This produces the shortest possible bundled references\n                    return a.length - b.length;\n                }\n            });\n            for (const key of keys) {\n                const keyPath = pointer_js_1.default.join(path, key);\n                const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                const value = obj[key];\n                if (ref_js_1.default.isAllowed$Ref(value)) {\n                    inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n                else {\n                    crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n            }\n        }\n    }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param $refParent - The object that contains a JSON Reference as one of its keys\n * @param $refKey - The key in `$refParent` that is a JSON Reference\n * @param path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param indirections - unknown\n * @param pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const $ref = $refKey === null ? $refParent : $refParent[$refKey];\n    const $refPath = url.resolve(path, $ref.$ref);\n    const pointer = $refs._resolve($refPath, pathFromRoot, options);\n    if (pointer === null) {\n        return;\n    }\n    const parsed = pointer_js_1.default.parse(pathFromRoot);\n    const depth = parsed.length;\n    const file = url.stripHash(pointer.path);\n    const hash = url.getHash(pointer.path);\n    const external = file !== $refs._root$Ref.path;\n    const extended = ref_js_1.default.isExtended$Ref($ref);\n    indirections += pointer.indirections;\n    const existingEntry = findInInventory(inventory, $refParent, $refKey);\n    if (existingEntry) {\n        // This $Ref has already been inventoried, so we don't need to process it again\n        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n            removeFromInventory(inventory, existingEntry);\n        }\n        else {\n            return;\n        }\n    }\n    inventory.push({\n        $ref, // The JSON Reference (e.g. {$ref: string})\n        parent: $refParent, // The object that contains this $ref pointer\n        key: $refKey, // The key in `parent` that is the $ref pointer\n        pathFromRoot, // The path to the $ref pointer, from the JSON Schema root\n        depth, // How far from the JSON Schema root is this $ref pointer?\n        file, // The file that the $ref pointer resolves to\n        hash, // The hash within `file` that the $ref pointer resolves to\n        value: pointer.value, // The resolved value of the $ref pointer\n        circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n        extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n        external, // Does this $ref pointer point to a file other than the main JSON Schema file?\n        indirections, // The number of indirect references that were traversed to resolve the value\n    });\n    // Recursively crawl the resolved value\n    if (!existingEntry || external) {\n        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n    }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example: {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param inventory\n */\nfunction remap(inventory) {\n    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n    inventory.sort((a, b) => {\n        if (a.file !== b.file) {\n            // Group all the $refs that point to the same file\n            return a.file < b.file ? -1 : +1;\n        }\n        else if (a.hash !== b.hash) {\n            // Group all the $refs that point to the same part of the file\n            return a.hash < b.hash ? -1 : +1;\n        }\n        else if (a.circular !== b.circular) {\n            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n            return a.circular ? -1 : +1;\n        }\n        else if (a.extended !== b.extended) {\n            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n            return a.extended ? +1 : -1;\n        }\n        else if (a.indirections !== b.indirections) {\n            // Sort direct references higher than indirect references\n            return a.indirections - b.indirections;\n        }\n        else if (a.depth !== b.depth) {\n            // Sort $refs by how close they are to the JSON Schema root\n            return a.depth - b.depth;\n        }\n        else {\n            // Determine how far each $ref is from the \"definitions\" property.\n            // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n            const aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n            const bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n            if (aDefinitionsIndex !== bDefinitionsIndex) {\n                // Give higher priority to the $ref that's closer to the \"definitions\" property\n                return bDefinitionsIndex - aDefinitionsIndex;\n            }\n            else {\n                // All else is equal, so use the shorter path, which will produce the shortest possible reference\n                return a.pathFromRoot.length - b.pathFromRoot.length;\n            }\n        }\n    });\n    let file, hash, pathFromRoot;\n    for (const entry of inventory) {\n        // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n        if (!entry.external) {\n            // This $ref already resolves to the main JSON Schema file\n            entry.$ref.$ref = entry.hash;\n        }\n        else if (entry.file === file && entry.hash === hash) {\n            // This $ref points to the same value as the prevous $ref, so remap it to the same path\n            entry.$ref.$ref = pathFromRoot;\n        }\n        else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n            // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n            entry.$ref.$ref = pointer_js_1.default.join(pathFromRoot, pointer_js_1.default.parse(entry.hash.replace(hash, \"#\")));\n        }\n        else {\n            // We've moved to a new file or new hash\n            file = entry.file;\n            hash = entry.hash;\n            pathFromRoot = entry.pathFromRoot;\n            // This is the first $ref to point to this value, so dereference the value.\n            // Any other $refs that point to the same value will point to this $ref instead\n            entry.$ref = entry.parent[entry.key] = ref_js_1.default.dereference(entry.$ref, entry.value);\n            if (entry.circular) {\n                // This $ref points to itself\n                entry.$ref.$ref = entry.pathFromRoot;\n            }\n        }\n    }\n    // we want to ensure that any $refs that point to another $ref are remapped to point to the final value\n    // let hadChange = true;\n    // while (hadChange) {\n    //   hadChange = false;\n    //   for (const entry of inventory) {\n    //     if (entry.$ref && typeof entry.$ref === \"object\" && \"$ref\" in entry.$ref) {\n    //       const resolved = inventory.find((e: InventoryEntry) => e.pathFromRoot === entry.$ref.$ref);\n    //       if (resolved) {\n    //         const resolvedPointsToAnotherRef =\n    //           resolved.$ref && typeof resolved.$ref === \"object\" && \"$ref\" in resolved.$ref;\n    //         if (resolvedPointsToAnotherRef && entry.$ref.$ref !== resolved.$ref.$ref) {\n    //           // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n    //           entry.$ref.$ref = resolved.$ref.$ref;\n    //           hadChange = true;\n    //         }\n    //       }\n    //     }\n    //   }\n    // }\n}\n/**\n * TODO\n */\nfunction findInInventory(inventory, $refParent, $refKey) {\n    for (const existingEntry of inventory) {\n        if (existingEntry && existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n            return existingEntry;\n        }\n    }\n    return undefined;\n}\nfunction removeFromInventory(inventory, entry) {\n    const index = inventory.indexOf(entry);\n    inventory.splice(index, 1);\n}\nexports.default = bundle;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2684, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/dereference.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ref_js_1 = __importDefault(require(\"./ref.js\"));\nconst pointer_js_1 = __importDefault(require(\"./pointer.js\"));\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst url = __importStar(require(\"./util/url.js\"));\nconst errors_1 = require(\"./util/errors\");\nexports.default = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param parser\n * @param options\n */\nfunction dereference(parser, options) {\n    const start = Date.now();\n    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n    const dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options, start);\n    parser.$refs.circular = dereferenced.circular;\n    parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `obj` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been processed\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @param startTime - The time when the dereferencing started\n * @returns\n */\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    let dereferenced;\n    const result = {\n        value: obj,\n        circular: false,\n    };\n    if (options && options.timeoutMs) {\n        if (Date.now() - startTime > options.timeoutMs) {\n            throw new errors_1.TimeoutError(options.timeoutMs);\n        }\n    }\n    const derefOptions = (options.dereference || {});\n    const isExcludedPath = derefOptions.excludedPathMatcher || (() => false);\n    if (derefOptions?.circular === \"ignore\" || !processedObjects.has(obj)) {\n        if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {\n            parents.add(obj);\n            processedObjects.add(obj);\n            if (ref_js_1.default.isAllowed$Ref(obj, options)) {\n                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                result.circular = dereferenced.circular;\n                result.value = dereferenced.value;\n            }\n            else {\n                for (const key of Object.keys(obj)) {\n                    const keyPath = pointer_js_1.default.join(path, key);\n                    const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                    if (isExcludedPath(keyPathFromRoot)) {\n                        continue;\n                    }\n                    const value = obj[key];\n                    let circular = false;\n                    if (ref_js_1.default.isAllowed$Ref(value, options)) {\n                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                        circular = dereferenced.circular;\n                        // Avoid pointless mutations; breaks frozen objects to no profit\n                        if (obj[key] !== dereferenced.value) {\n                            // If we have properties we want to preserve from our dereferenced schema then we need\n                            // to copy them over to our new object.\n                            const preserved = new Map();\n                            if (derefOptions?.preservedProperties) {\n                                if (typeof obj[key] === \"object\" && !Array.isArray(obj[key])) {\n                                    derefOptions?.preservedProperties.forEach((prop) => {\n                                        if (prop in obj[key]) {\n                                            preserved.set(prop, obj[key][prop]);\n                                        }\n                                    });\n                                }\n                            }\n                            obj[key] = dereferenced.value;\n                            // If we have data to preserve and our dereferenced object is still an object then\n                            // we need copy back our preserved data into our dereferenced schema.\n                            if (derefOptions?.preservedProperties) {\n                                if (preserved.size && typeof obj[key] === \"object\" && !Array.isArray(obj[key])) {\n                                    preserved.forEach((value, prop) => {\n                                        obj[key][prop] = value;\n                                    });\n                                }\n                            }\n                            derefOptions?.onDereference?.(value.$ref, obj[key], obj, key);\n                        }\n                    }\n                    else {\n                        if (!parents.has(value)) {\n                            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                            circular = dereferenced.circular;\n                            // Avoid pointless mutations; breaks frozen objects to no profit\n                            if (obj[key] !== dereferenced.value) {\n                                obj[key] = dereferenced.value;\n                            }\n                        }\n                        else {\n                            circular = foundCircularReference(keyPath, $refs, options);\n                        }\n                    }\n                    // Set the \"isCircular\" flag if this or any other property is circular\n                    result.circular = result.circular || circular;\n                }\n            }\n            parents.delete(obj);\n        }\n    }\n    return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `$ref` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been dereferenced\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    const isExternalRef = ref_js_1.default.isExternal$Ref($ref);\n    const shouldResolveOnCwd = isExternalRef && options?.dereference?.externalReferenceResolution === \"root\";\n    const $refPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const cache = dereferencedCache.get($refPath);\n    if (cache && !cache.circular) {\n        const refKeys = Object.keys($ref);\n        if (refKeys.length > 1) {\n            const extraKeys = {};\n            for (const key of refKeys) {\n                if (key !== \"$ref\" && !(key in cache.value)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    extraKeys[key] = $ref[key];\n                }\n            }\n            return {\n                circular: cache.circular,\n                value: Object.assign({}, cache.value, extraKeys),\n            };\n        }\n        return cache;\n    }\n    const pointer = $refs._resolve($refPath, path, options);\n    if (pointer === null) {\n        return {\n            circular: false,\n            value: null,\n        };\n    }\n    // Check for circular references\n    const directCircular = pointer.circular;\n    let circular = directCircular || parents.has(pointer.value);\n    if (circular) {\n        foundCircularReference(path, $refs, options);\n    }\n    // Dereference the JSON reference\n    let dereferencedValue = ref_js_1.default.dereference($ref, pointer.value);\n    // Crawl the dereferenced value (unless it's circular)\n    if (!circular) {\n        // Determine if the dereferenced value is circular\n        const dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n        circular = dereferenced.circular;\n        dereferencedValue = dereferenced.value;\n    }\n    if (circular && !directCircular && options.dereference?.circular === \"ignore\") {\n        // The user has chosen to \"ignore\" circular references, so don't change the value\n        dereferencedValue = $ref;\n    }\n    if (directCircular) {\n        // The pointer is a DIRECT circular reference (i.e. it references itself).\n        // So replace the $ref path with the absolute path from the JSON Schema root\n        dereferencedValue.$ref = pathFromRoot;\n    }\n    const dereferencedObject = {\n        circular,\n        value: dereferencedValue,\n    };\n    // only cache if no extra properties than $ref\n    if (Object.keys($ref).length === 1) {\n        dereferencedCache.set($refPath, dereferencedObject);\n    }\n    return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, executes the options.dereference.onCircular callback,\n * and throws an error if options.dereference.circular is false.\n *\n * @param keyPath - The JSON Reference path of the circular reference\n * @param $refs\n * @param options\n * @returns - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath, $refs, options) {\n    $refs.circular = true;\n    options?.dereference?.onCircular?.(keyPath);\n    if (!options.dereference.circular) {\n        throw ono_1.ono.reference(`Circular $ref pointer found at ${keyPath}`);\n    }\n    return true;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2943, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/next.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction makeNext() {\n    if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n        return process.nextTick;\n    }\n    else if (typeof setImmediate === \"function\") {\n        return setImmediate;\n    }\n    else {\n        return function next(f) {\n            setTimeout(f, 0);\n        };\n    }\n}\nexports.default = makeNext();\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,SAAS;IACL,IAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,QAAQ,KAAK,YAAY;QACvE,OAAO,QAAQ,QAAQ;IAC3B,OACK,IAAI,OAAO,iBAAiB,YAAY;QACzC,OAAO;IACX,OACK;QACD,OAAO,SAAS,KAAK,CAAC;YAClB,WAAW,GAAG;QAClB;IACJ;AACJ;AACA,QAAQ,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2962, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = maybe;\nconst next_js_1 = __importDefault(require(\"./next.js\"));\nfunction maybe(cb, promise) {\n    if (cb) {\n        promise.then(function (result) {\n            (0, next_js_1.default)(function () {\n                cb(null, result);\n            });\n        }, function (err) {\n            (0, next_js_1.default)(function () {\n                cb(err);\n            });\n        });\n        return undefined;\n    }\n    else {\n        return promise;\n    }\n}\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,SAAU,GAAG;IACjE,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,WAAW;IAAI;AAC5D;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,OAAO,GAAG;AAClB,MAAM,YAAY;AAClB,SAAS,MAAM,EAAE,EAAE,OAAO;IACtB,IAAI,IAAI;QACJ,QAAQ,IAAI,CAAC,SAAU,MAAM;YACzB,CAAC,GAAG,UAAU,OAAO,EAAE;gBACnB,GAAG,MAAM;YACb;QACJ,GAAG,SAAU,GAAG;YACZ,CAAC,GAAG,UAAU,OAAO,EAAE;gBACnB,GAAG;YACP;QACJ;QACA,OAAO;IACX,OACK;QACD,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2992, "column": 0}, "map": {"version":3,"sources":["file:///mnt/data/Projects/grab-url/docs/node_modules/%40apidevtools/json-schema-ref-parser/dist/lib/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getJsonSchemaRefParserDefaultOptions = exports.jsonSchemaParserNormalizeArgs = exports.dereferenceInternal = exports.JSONParserErrorGroup = exports.isHandledError = exports.UnmatchedParserError = exports.ParserError = exports.ResolverError = exports.MissingPointerError = exports.InvalidPointerError = exports.JSONParserError = exports.UnmatchedResolverError = exports.dereference = exports.bundle = exports.resolve = exports.parse = exports.$RefParser = void 0;\nconst refs_js_1 = __importDefault(require(\"./refs.js\"));\nconst parse_js_1 = __importDefault(require(\"./parse.js\"));\nconst normalize_args_js_1 = __importDefault(require(\"./normalize-args.js\"));\nexports.jsonSchemaParserNormalizeArgs = normalize_args_js_1.default;\nconst resolve_external_js_1 = __importDefault(require(\"./resolve-external.js\"));\nconst bundle_js_1 = __importDefault(require(\"./bundle.js\"));\nconst dereference_js_1 = __importDefault(require(\"./dereference.js\"));\nexports.dereferenceInternal = dereference_js_1.default;\nconst url = __importStar(require(\"./util/url.js\"));\nconst errors_js_1 = require(\"./util/errors.js\");\nObject.defineProperty(exports, \"JSONParserError\", { enumerable: true, get: function () { return errors_js_1.JSONParserError; } });\nObject.defineProperty(exports, \"InvalidPointerError\", { enumerable: true, get: function () { return errors_js_1.InvalidPointerError; } });\nObject.defineProperty(exports, \"MissingPointerError\", { enumerable: true, get: function () { return errors_js_1.MissingPointerError; } });\nObject.defineProperty(exports, \"ResolverError\", { enumerable: true, get: function () { return errors_js_1.ResolverError; } });\nObject.defineProperty(exports, \"ParserError\", { enumerable: true, get: function () { return errors_js_1.ParserError; } });\nObject.defineProperty(exports, \"UnmatchedParserError\", { enumerable: true, get: function () { return errors_js_1.UnmatchedParserError; } });\nObject.defineProperty(exports, \"UnmatchedResolverError\", { enumerable: true, get: function () { return errors_js_1.UnmatchedResolverError; } });\nObject.defineProperty(exports, \"isHandledError\", { enumerable: true, get: function () { return errors_js_1.isHandledError; } });\nObject.defineProperty(exports, \"JSONParserErrorGroup\", { enumerable: true, get: function () { return errors_js_1.JSONParserErrorGroup; } });\nconst ono_1 = require(\"@jsdevtools/ono\");\nconst maybe_js_1 = __importDefault(require(\"./util/maybe.js\"));\nconst options_js_1 = require(\"./options.js\");\nObject.defineProperty(exports, \"getJsonSchemaRefParserDefaultOptions\", { enumerable: true, get: function () { return options_js_1.getJsonSchemaRefParserDefaultOptions; } });\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @class\n */\nclass $RefParser {\n    constructor() {\n        /**\n         * The parsed (and possibly dereferenced) JSON schema object\n         *\n         * @type {object}\n         * @readonly\n         */\n        this.schema = null;\n        /**\n         * The resolved JSON references\n         *\n         * @type {$Refs}\n         * @readonly\n         */\n        this.$refs = new refs_js_1.default();\n    }\n    async parse() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        let promise;\n        if (!args.path && !args.schema) {\n            const err = (0, ono_1.ono)(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n        // Reset everything\n        this.schema = null;\n        this.$refs = new refs_js_1.default();\n        // If the path is a filesystem path, then convert it to a URL.\n        // NOTE: According to the JSON Reference spec, these should already be URLs,\n        // but, in practice, many people use local filesystem paths instead.\n        // So we're being generous here and doing the conversion automatically.\n        // This is not intended to be a 100% bulletproof solution.\n        // If it doesn't work for your use-case, then use a URL instead.\n        let pathType = \"http\";\n        if (url.isFileSystemPath(args.path)) {\n            args.path = url.fromFileSystemPath(args.path);\n            pathType = \"file\";\n        }\n        else if (!args.path && args.schema && \"$id\" in args.schema && args.schema.$id) {\n            // when schema id has defined an URL should use that hostname to request the references,\n            // instead of using the current page URL\n            const params = url.parse(args.schema.$id);\n            const port = params.protocol === \"https:\" ? 443 : 80;\n            args.path = `${params.protocol}//${params.hostname}:${port}`;\n        }\n        // Resolve the absolute path of the schema\n        args.path = url.resolve(url.cwd(), args.path);\n        if (args.schema && typeof args.schema === \"object\") {\n            // A schema object was passed-in.\n            // So immediately add a new $Ref with the schema object as its value\n            const $ref = this.$refs._add(args.path);\n            $ref.value = args.schema;\n            $ref.pathType = pathType;\n            promise = Promise.resolve(args.schema);\n        }\n        else {\n            // Parse the schema file/url\n            promise = (0, parse_js_1.default)(args.path, this.$refs, args.options);\n        }\n        try {\n            const result = await promise;\n            if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n                this.schema = result;\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else if (args.options.continueOnError) {\n                this.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else {\n                throw ono_1.ono.syntax(`\"${this.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n            }\n        }\n        catch (err) {\n            if (!args.options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n            }\n            if (this.$refs._$refs[url.stripHash(args.path)]) {\n                this.$refs._$refs[url.stripHash(args.path)].addError(err);\n            }\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(null));\n        }\n    }\n    static parse() {\n        const parser = new $RefParser();\n        return parser.parse.apply(parser, arguments);\n    }\n    async resolve() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.parse(args.path, args.schema, args.options);\n            await (0, resolve_external_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.$refs));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static resolve() {\n        const instance = new $RefParser();\n        return instance.resolve.apply(instance, arguments);\n    }\n    static bundle() {\n        const instance = new $RefParser();\n        return instance.bundle.apply(instance, arguments);\n    }\n    async bundle() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, bundle_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static dereference() {\n        const instance = new $RefParser();\n        return instance.dereference.apply(instance, arguments);\n    }\n    async dereference() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, dereference_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n}\nexports.$RefParser = $RefParser;\nexports.default = $RefParser;\nfunction finalize(parser) {\n    const errors = errors_js_1.JSONParserErrorGroup.getParserErrors(parser);\n    if (errors.length > 0) {\n        throw new errors_js_1.JSONParserErrorGroup(parser);\n    }\n}\nexports.parse = $RefParser.parse;\nexports.resolve = $RefParser.resolve;\nexports.bundle = $RefParser.bundle;\nexports.dereference = $RefParser.dereference;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}