(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/shiki/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
;
;
;
;
}),
"[project]/node_modules/@shikijs/types/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShikiError",
    ()=>ShikiError
]);
class ShikiError extends Error {
    constructor(message){
        super(message);
        this.name = "ShikiError";
    }
}
;
}),
"[project]/node_modules/@shikijs/vscode-textmate/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils.ts
__turbopack_context__.s([
    "EncodedTokenMetadata",
    ()=>EncodedTokenMetadata,
    "FindOption",
    ()=>FindOption,
    "FontStyle",
    ()=>FontStyle,
    "INITIAL",
    ()=>INITIAL,
    "Registry",
    ()=>Registry,
    "Theme",
    ()=>Theme,
    "disposeOnigString",
    ()=>disposeOnigString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
var __BasicScopeAttributesProvider, __StateStackImpl;
function clone(something) {
    return doClone(something);
}
function doClone(something) {
    if (Array.isArray(something)) {
        return cloneArray(something);
    }
    if (something instanceof RegExp) {
        return something;
    }
    if (typeof something === "object") {
        return cloneObj(something);
    }
    return something;
}
function cloneArray(arr) {
    let r = [];
    for(let i = 0, len = arr.length; i < len; i++){
        r[i] = doClone(arr[i]);
    }
    return r;
}
function cloneObj(obj) {
    let r = {};
    for(let key in obj){
        r[key] = doClone(obj[key]);
    }
    return r;
}
function mergeObjects(target) {
    for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        sources[_key - 1] = arguments[_key];
    }
    sources.forEach((source)=>{
        for(let key in source){
            target[key] = source[key];
        }
    });
    return target;
}
function basename(path) {
    const idx = ~path.lastIndexOf("/") || ~path.lastIndexOf("\\");
    if (idx === 0) {
        return path;
    } else if (~idx === path.length - 1) {
        return basename(path.substring(0, path.length - 1));
    } else {
        return path.substr(~idx + 1);
    }
}
var CAPTURING_REGEX_SOURCE = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
var RegexSource = class {
    static hasCaptures(regexSource) {
        if (regexSource === null) {
            return false;
        }
        CAPTURING_REGEX_SOURCE.lastIndex = 0;
        return CAPTURING_REGEX_SOURCE.test(regexSource);
    }
    static replaceCaptures(regexSource, captureSource, captureIndices) {
        return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command)=>{
            let capture = captureIndices[parseInt(index || commandIndex, 10)];
            if (capture) {
                let result = captureSource.substring(capture.start, capture.end);
                while(result[0] === "."){
                    result = result.substring(1);
                }
                switch(command){
                    case "downcase":
                        return result.toLowerCase();
                    case "upcase":
                        return result.toUpperCase();
                    default:
                        return result;
                }
            } else {
                return match;
            }
        });
    }
};
function strcmp(a, b) {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
}
function strArrCmp(a, b) {
    if (a === null && b === null) {
        return 0;
    }
    if (!a) {
        return -1;
    }
    if (!b) {
        return 1;
    }
    let len1 = a.length;
    let len2 = b.length;
    if (len1 === len2) {
        for(let i = 0; i < len1; i++){
            let res = strcmp(a[i], b[i]);
            if (res !== 0) {
                return res;
            }
        }
        return 0;
    }
    return len1 - len2;
}
function isValidHexColor(hex) {
    if (/^#[0-9a-f]{6}$/i.test(hex)) {
        return true;
    }
    if (/^#[0-9a-f]{8}$/i.test(hex)) {
        return true;
    }
    if (/^#[0-9a-f]{3}$/i.test(hex)) {
        return true;
    }
    if (/^#[0-9a-f]{4}$/i.test(hex)) {
        return true;
    }
    return false;
}
function escapeRegExpCharacters(value) {
    return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var CachedFn = class {
    get(key) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        const value = this.fn(key);
        this.cache.set(key, value);
        return value;
    }
    constructor(fn){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "cache", /* @__PURE__ */ new Map());
        this.fn = fn;
    }
};
// src/theme.ts
var Theme = class {
    static createFromRawTheme(source, colorMap) {
        return this.createFromParsedTheme(parseTheme(source), colorMap);
    }
    static createFromParsedTheme(source, colorMap) {
        return resolveParsedThemeRules(source, colorMap);
    }
    getColorMap() {
        return this._colorMap.getColorMap();
    }
    getDefaults() {
        return this._defaults;
    }
    match(scopePath) {
        if (scopePath === null) {
            return this._defaults;
        }
        const scopeName = scopePath.scopeName;
        const matchingTrieElements = this._cachedMatchRoot.get(scopeName);
        const effectiveRule = matchingTrieElements.find((v)=>_scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));
        if (!effectiveRule) {
            return null;
        }
        return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);
    }
    constructor(_colorMap, _defaults, _root){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedMatchRoot", new CachedFn((scopeName)=>this._root.match(scopeName)));
        this._colorMap = _colorMap;
        this._defaults = _defaults;
        this._root = _root;
    }
};
var ScopeStack = class _ScopeStack {
    static push(path, scopeNames) {
        for (const name of scopeNames){
            path = new _ScopeStack(path, name);
        }
        return path;
    }
    static from() {
        for(var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++){
            segments[_key] = arguments[_key];
        }
        let result = null;
        for(let i = 0; i < segments.length; i++){
            result = new _ScopeStack(result, segments[i]);
        }
        return result;
    }
    push(scopeName) {
        return new _ScopeStack(this, scopeName);
    }
    getSegments() {
        let item = this;
        const result = [];
        while(item){
            result.push(item.scopeName);
            item = item.parent;
        }
        result.reverse();
        return result;
    }
    toString() {
        return this.getSegments().join(" ");
    }
    extends(other) {
        if (this === other) {
            return true;
        }
        if (this.parent === null) {
            return false;
        }
        return this.parent.extends(other);
    }
    getExtensionIfDefined(base) {
        const result = [];
        let item = this;
        while(item && item !== base){
            result.push(item.scopeName);
            item = item.parent;
        }
        return item === base ? result.reverse() : void 0;
    }
    constructor(parent, scopeName){
        this.parent = parent;
        this.scopeName = scopeName;
    }
};
function _scopePathMatchesParentScopes(scopePath, parentScopes) {
    if (parentScopes.length === 0) {
        return true;
    }
    for(let index = 0; index < parentScopes.length; index++){
        let scopePattern = parentScopes[index];
        let scopeMustMatch = false;
        if (scopePattern === ">") {
            if (index === parentScopes.length - 1) {
                return false;
            }
            scopePattern = parentScopes[++index];
            scopeMustMatch = true;
        }
        while(scopePath){
            if (_matchesScope(scopePath.scopeName, scopePattern)) {
                break;
            }
            if (scopeMustMatch) {
                return false;
            }
            scopePath = scopePath.parent;
        }
        if (!scopePath) {
            return false;
        }
        scopePath = scopePath.parent;
    }
    return true;
}
function _matchesScope(scopeName, scopePattern) {
    return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === ".";
}
var StyleAttributes = class {
    constructor(fontStyle, foregroundId, backgroundId){
        this.fontStyle = fontStyle;
        this.foregroundId = foregroundId;
        this.backgroundId = backgroundId;
    }
};
function parseTheme(source) {
    if (!source) {
        return [];
    }
    if (!source.settings || !Array.isArray(source.settings)) {
        return [];
    }
    let settings = source.settings;
    let result = [], resultLen = 0;
    for(let i = 0, len = settings.length; i < len; i++){
        let entry = settings[i];
        if (!entry.settings) {
            continue;
        }
        let scopes;
        if (typeof entry.scope === "string") {
            let _scope = entry.scope;
            _scope = _scope.replace(/^[,]+/, "");
            _scope = _scope.replace(/[,]+$/, "");
            scopes = _scope.split(",");
        } else if (Array.isArray(entry.scope)) {
            scopes = entry.scope;
        } else {
            scopes = [
                ""
            ];
        }
        let fontStyle = -1 /* NotSet */ ;
        if (typeof entry.settings.fontStyle === "string") {
            fontStyle = 0 /* None */ ;
            let segments = entry.settings.fontStyle.split(" ");
            for(let j = 0, lenJ = segments.length; j < lenJ; j++){
                let segment = segments[j];
                switch(segment){
                    case "italic":
                        fontStyle = fontStyle | 1 /* Italic */ ;
                        break;
                    case "bold":
                        fontStyle = fontStyle | 2 /* Bold */ ;
                        break;
                    case "underline":
                        fontStyle = fontStyle | 4 /* Underline */ ;
                        break;
                    case "strikethrough":
                        fontStyle = fontStyle | 8 /* Strikethrough */ ;
                        break;
                }
            }
        }
        let foreground = null;
        if (typeof entry.settings.foreground === "string" && isValidHexColor(entry.settings.foreground)) {
            foreground = entry.settings.foreground;
        }
        let background = null;
        if (typeof entry.settings.background === "string" && isValidHexColor(entry.settings.background)) {
            background = entry.settings.background;
        }
        for(let j = 0, lenJ = scopes.length; j < lenJ; j++){
            let _scope = scopes[j].trim();
            let segments = _scope.split(" ");
            let scope = segments[segments.length - 1];
            let parentScopes = null;
            if (segments.length > 1) {
                parentScopes = segments.slice(0, segments.length - 1);
                parentScopes.reverse();
            }
            result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);
        }
    }
    return result;
}
var ParsedThemeRule = class {
    constructor(scope, parentScopes, index, fontStyle, foreground, background){
        this.scope = scope;
        this.parentScopes = parentScopes;
        this.index = index;
        this.fontStyle = fontStyle;
        this.foreground = foreground;
        this.background = background;
    }
};
var FontStyle = /* @__PURE__ */ ((FontStyle2)=>{
    FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
    FontStyle2[FontStyle2["None"] = 0] = "None";
    FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
    FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
    FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
    FontStyle2[FontStyle2["Strikethrough"] = 8] = "Strikethrough";
    return FontStyle2;
})(FontStyle || {});
function resolveParsedThemeRules(parsedThemeRules, _colorMap) {
    parsedThemeRules.sort((a, b)=>{
        let r = strcmp(a.scope, b.scope);
        if (r !== 0) {
            return r;
        }
        r = strArrCmp(a.parentScopes, b.parentScopes);
        if (r !== 0) {
            return r;
        }
        return a.index - b.index;
    });
    let defaultFontStyle = 0 /* None */ ;
    let defaultForeground = "#000000";
    let defaultBackground = "#ffffff";
    while(parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === ""){
        let incomingDefaults = parsedThemeRules.shift();
        if (incomingDefaults.fontStyle !== -1 /* NotSet */ ) {
            defaultFontStyle = incomingDefaults.fontStyle;
        }
        if (incomingDefaults.foreground !== null) {
            defaultForeground = incomingDefaults.foreground;
        }
        if (incomingDefaults.background !== null) {
            defaultBackground = incomingDefaults.background;
        }
    }
    let colorMap = new ColorMap(_colorMap);
    let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));
    let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */ , 0, 0), []);
    for(let i = 0, len = parsedThemeRules.length; i < len; i++){
        let rule = parsedThemeRules[i];
        root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
    }
    return new Theme(colorMap, defaults, root);
}
var ColorMap = class {
    getId(color) {
        if (color === null) {
            return 0;
        }
        color = color.toUpperCase();
        let value = this._color2id[color];
        if (value) {
            return value;
        }
        if (this._isFrozen) {
            throw new Error("Missing color in color map - ".concat(color));
        }
        value = ++this._lastColorId;
        this._color2id[color] = value;
        this._id2color[value] = color;
        return value;
    }
    getColorMap() {
        return this._id2color.slice(0);
    }
    constructor(_colorMap){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_isFrozen", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lastColorId", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_id2color", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_color2id", void 0);
        this._lastColorId = 0;
        this._id2color = [];
        this._color2id = /* @__PURE__ */ Object.create(null);
        if (Array.isArray(_colorMap)) {
            this._isFrozen = true;
            for(let i = 0, len = _colorMap.length; i < len; i++){
                this._color2id[_colorMap[i]] = i;
                this._id2color[i] = _colorMap[i];
            }
        } else {
            this._isFrozen = false;
        }
    }
};
var emptyParentScopes = Object.freeze([]);
var ThemeTrieElementRule = class _ThemeTrieElementRule {
    clone() {
        return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
    }
    static cloneArr(arr) {
        let r = [];
        for(let i = 0, len = arr.length; i < len; i++){
            r[i] = arr[i].clone();
        }
        return r;
    }
    acceptOverwrite(scopeDepth, fontStyle, foreground, background) {
        if (this.scopeDepth > scopeDepth) {
            console.log("how did this happen?");
        } else {
            this.scopeDepth = scopeDepth;
        }
        if (fontStyle !== -1 /* NotSet */ ) {
            this.fontStyle = fontStyle;
        }
        if (foreground !== 0) {
            this.foreground = foreground;
        }
        if (background !== 0) {
            this.background = background;
        }
    }
    constructor(scopeDepth, parentScopes, fontStyle, foreground, background){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "scopeDepth", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "parentScopes", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "fontStyle", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "foreground", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "background", void 0);
        this.scopeDepth = scopeDepth;
        this.parentScopes = parentScopes || emptyParentScopes;
        this.fontStyle = fontStyle;
        this.foreground = foreground;
        this.background = background;
    }
};
var ThemeTrieElement = class _ThemeTrieElement {
    static _cmpBySpecificity(a, b) {
        if (a.scopeDepth !== b.scopeDepth) {
            return b.scopeDepth - a.scopeDepth;
        }
        let aParentIndex = 0;
        let bParentIndex = 0;
        while(true){
            if (a.parentScopes[aParentIndex] === ">") {
                aParentIndex++;
            }
            if (b.parentScopes[bParentIndex] === ">") {
                bParentIndex++;
            }
            if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {
                break;
            }
            const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;
            if (parentScopeLengthDiff !== 0) {
                return parentScopeLengthDiff;
            }
            aParentIndex++;
            bParentIndex++;
        }
        return b.parentScopes.length - a.parentScopes.length;
    }
    match(scope) {
        if (scope !== "") {
            let dotIndex = scope.indexOf(".");
            let head;
            let tail;
            if (dotIndex === -1) {
                head = scope;
                tail = "";
            } else {
                head = scope.substring(0, dotIndex);
                tail = scope.substring(dotIndex + 1);
            }
            if (this._children.hasOwnProperty(head)) {
                return this._children[head].match(tail);
            }
        }
        const rules = this._rulesWithParentScopes.concat(this._mainRule);
        rules.sort(_ThemeTrieElement._cmpBySpecificity);
        return rules;
    }
    insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {
        if (scope === "") {
            this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);
            return;
        }
        let dotIndex = scope.indexOf(".");
        let head;
        let tail;
        if (dotIndex === -1) {
            head = scope;
            tail = "";
        } else {
            head = scope.substring(0, dotIndex);
            tail = scope.substring(dotIndex + 1);
        }
        let child;
        if (this._children.hasOwnProperty(head)) {
            child = this._children[head];
        } else {
            child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));
            this._children[head] = child;
        }
        child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);
    }
    _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {
        if (parentScopes === null) {
            this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
            return;
        }
        for(let i = 0, len = this._rulesWithParentScopes.length; i < len; i++){
            let rule = this._rulesWithParentScopes[i];
            if (strArrCmp(rule.parentScopes, parentScopes) === 0) {
                rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
                return;
            }
        }
        if (fontStyle === -1 /* NotSet */ ) {
            fontStyle = this._mainRule.fontStyle;
        }
        if (foreground === 0) {
            foreground = this._mainRule.foreground;
        }
        if (background === 0) {
            background = this._mainRule.background;
        }
        this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));
    }
    constructor(_mainRule, rulesWithParentScopes = [], _children = {}){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_rulesWithParentScopes", void 0);
        this._mainRule = _mainRule;
        this._children = _children;
        this._rulesWithParentScopes = rulesWithParentScopes;
    }
};
// src/encodedTokenAttributes.ts
var EncodedTokenMetadata = class _EncodedTokenMetadata {
    static toBinaryStr(encodedTokenAttributes) {
        return encodedTokenAttributes.toString(2).padStart(32, "0");
    }
    static print(encodedTokenAttributes) {
        const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);
        const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);
        const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);
        const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);
        const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);
        console.log({
            languageId,
            tokenType,
            fontStyle,
            foreground,
            background
        });
    }
    static getLanguageId(encodedTokenAttributes) {
        return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */ ) >>> 0 /* LANGUAGEID_OFFSET */ ;
    }
    static getTokenType(encodedTokenAttributes) {
        return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */ ) >>> 8 /* TOKEN_TYPE_OFFSET */ ;
    }
    static containsBalancedBrackets(encodedTokenAttributes) {
        return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */ ) !== 0;
    }
    static getFontStyle(encodedTokenAttributes) {
        return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */ ) >>> 11 /* FONT_STYLE_OFFSET */ ;
    }
    static getForeground(encodedTokenAttributes) {
        return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */ ) >>> 15 /* FOREGROUND_OFFSET */ ;
    }
    static getBackground(encodedTokenAttributes) {
        return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */ ) >>> 24 /* BACKGROUND_OFFSET */ ;
    }
    /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */ static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {
        let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);
        let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);
        let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;
        let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);
        let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);
        let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);
        if (languageId !== 0) {
            _languageId = languageId;
        }
        if (tokenType !== 8 /* NotSet */ ) {
            _tokenType = fromOptionalTokenType(tokenType);
        }
        if (containsBalancedBrackets !== null) {
            _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;
        }
        if (fontStyle !== -1 /* NotSet */ ) {
            _fontStyle = fontStyle;
        }
        if (foreground !== 0) {
            _foreground = foreground;
        }
        if (background !== 0) {
            _background = background;
        }
        return (_languageId << 0 /* LANGUAGEID_OFFSET */  | _tokenType << 8 /* TOKEN_TYPE_OFFSET */  | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */  | _fontStyle << 11 /* FONT_STYLE_OFFSET */  | _foreground << 15 /* FOREGROUND_OFFSET */  | _background << 24 /* BACKGROUND_OFFSET */ ) >>> 0;
    }
};
function toOptionalTokenType(standardType) {
    return standardType;
}
function fromOptionalTokenType(standardType) {
    return standardType;
}
// src/matcher.ts
function createMatchers(selector, matchesName) {
    const results = [];
    const tokenizer = newTokenizer(selector);
    let token = tokenizer.next();
    while(token !== null){
        let priority = 0;
        if (token.length === 2 && token.charAt(1) === ":") {
            switch(token.charAt(0)){
                case "R":
                    priority = 1;
                    break;
                case "L":
                    priority = -1;
                    break;
                default:
                    console.log("Unknown priority ".concat(token, " in scope selector"));
            }
            token = tokenizer.next();
        }
        let matcher = parseConjunction();
        results.push({
            matcher,
            priority
        });
        if (token !== ",") {
            break;
        }
        token = tokenizer.next();
    }
    return results;
    //TURBOPACK unreachable
    ;
    function parseOperand() {
        if (token === "-") {
            token = tokenizer.next();
            const expressionToNegate = parseOperand();
            return (matcherInput)=>!!expressionToNegate && !expressionToNegate(matcherInput);
        }
        if (token === "(") {
            token = tokenizer.next();
            const expressionInParents = parseInnerExpression();
            if (token === ")") {
                token = tokenizer.next();
            }
            return expressionInParents;
        }
        if (isIdentifier(token)) {
            const identifiers = [];
            do {
                identifiers.push(token);
                token = tokenizer.next();
            }while (isIdentifier(token))
            return (matcherInput)=>matchesName(identifiers, matcherInput);
        }
        return null;
    }
    function parseConjunction() {
        const matchers = [];
        let matcher = parseOperand();
        while(matcher){
            matchers.push(matcher);
            matcher = parseOperand();
        }
        return (matcherInput)=>matchers.every((matcher2)=>matcher2(matcherInput));
    }
    function parseInnerExpression() {
        const matchers = [];
        let matcher = parseConjunction();
        while(matcher){
            matchers.push(matcher);
            if (token === "|" || token === ",") {
                do {
                    token = tokenizer.next();
                }while (token === "|" || token === ",")
            } else {
                break;
            }
            matcher = parseConjunction();
        }
        return (matcherInput)=>matchers.some((matcher2)=>matcher2(matcherInput));
    }
}
function isIdentifier(token) {
    return !!token && !!token.match(/[\w\.:]+/);
}
function newTokenizer(input) {
    let regex = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g;
    let match = regex.exec(input);
    return {
        next: ()=>{
            if (!match) {
                return null;
            }
            const res = match[0];
            match = regex.exec(input);
            return res;
        }
    };
}
// src/onigLib.ts
var FindOption = /* @__PURE__ */ ((FindOption2)=>{
    FindOption2[FindOption2["None"] = 0] = "None";
    FindOption2[FindOption2["NotBeginString"] = 1] = "NotBeginString";
    FindOption2[FindOption2["NotEndString"] = 2] = "NotEndString";
    FindOption2[FindOption2["NotBeginPosition"] = 4] = "NotBeginPosition";
    FindOption2[FindOption2["DebugCall"] = 8] = "DebugCall";
    return FindOption2;
})(FindOption || {});
function disposeOnigString(str) {
    if (typeof str.dispose === "function") {
        str.dispose();
    }
}
// src/grammar/grammarDependencies.ts
var TopLevelRuleReference = class {
    toKey() {
        return this.scopeName;
    }
    constructor(scopeName){
        this.scopeName = scopeName;
    }
};
var TopLevelRepositoryRuleReference = class {
    toKey() {
        return "".concat(this.scopeName, "#").concat(this.ruleName);
    }
    constructor(scopeName, ruleName){
        this.scopeName = scopeName;
        this.ruleName = ruleName;
    }
};
var ExternalReferenceCollector = class {
    get references() {
        return this._references;
    }
    add(reference) {
        const key = reference.toKey();
        if (this._seenReferenceKeys.has(key)) {
            return;
        }
        this._seenReferenceKeys.add(key);
        this._references.push(reference);
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_references", []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_seenReferenceKeys", /* @__PURE__ */ new Set());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "visitedRule", /* @__PURE__ */ new Set());
    }
};
var ScopeDependencyProcessor = class {
    processQueue() {
        const q = this.Q;
        this.Q = [];
        const deps = new ExternalReferenceCollector();
        for (const dep of q){
            collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);
        }
        for (const dep of deps.references){
            if (dep instanceof TopLevelRuleReference) {
                if (this.seenFullScopeRequests.has(dep.scopeName)) {
                    continue;
                }
                this.seenFullScopeRequests.add(dep.scopeName);
                this.Q.push(dep);
            } else {
                if (this.seenFullScopeRequests.has(dep.scopeName)) {
                    continue;
                }
                if (this.seenPartialScopeRequests.has(dep.toKey())) {
                    continue;
                }
                this.seenPartialScopeRequests.add(dep.toKey());
                this.Q.push(dep);
            }
        }
    }
    constructor(repo, initialScopeName){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "seenFullScopeRequests", /* @__PURE__ */ new Set());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "seenPartialScopeRequests", /* @__PURE__ */ new Set());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "Q", void 0);
        this.repo = repo;
        this.initialScopeName = initialScopeName;
        this.seenFullScopeRequests.add(this.initialScopeName);
        this.Q = [
            new TopLevelRuleReference(this.initialScopeName)
        ];
    }
};
function collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {
    const selfGrammar = repo.lookup(reference.scopeName);
    if (!selfGrammar) {
        if (reference.scopeName === baseGrammarScopeName) {
            throw new Error("No grammar provided for <".concat(baseGrammarScopeName, ">"));
        }
        return;
    }
    const baseGrammar = repo.lookup(baseGrammarScopeName);
    if (reference instanceof TopLevelRuleReference) {
        collectExternalReferencesInTopLevelRule({
            baseGrammar,
            selfGrammar
        }, result);
    } else {
        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, {
            baseGrammar,
            selfGrammar,
            repository: selfGrammar.repository
        }, result);
    }
    const injections = repo.injections(reference.scopeName);
    if (injections) {
        for (const injection of injections){
            result.add(new TopLevelRuleReference(injection));
        }
    }
}
function collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {
    if (context.repository && context.repository[ruleName]) {
        const rule = context.repository[ruleName];
        collectExternalReferencesInRules([
            rule
        ], context, result);
    }
}
function collectExternalReferencesInTopLevelRule(context, result) {
    if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {
        collectExternalReferencesInRules(context.selfGrammar.patterns, {
            ...context,
            repository: context.selfGrammar.repository
        }, result);
    }
    if (context.selfGrammar.injections) {
        collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), {
            ...context,
            repository: context.selfGrammar.repository
        }, result);
    }
}
function collectExternalReferencesInRules(rules, context, result) {
    for (const rule of rules){
        if (result.visitedRule.has(rule)) {
            continue;
        }
        result.visitedRule.add(rule);
        const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;
        if (Array.isArray(rule.patterns)) {
            collectExternalReferencesInRules(rule.patterns, {
                ...context,
                repository: patternRepository
            }, result);
        }
        const include = rule.include;
        if (!include) {
            continue;
        }
        const reference = parseInclude(include);
        switch(reference.kind){
            case 0 /* Base */ :
                collectExternalReferencesInTopLevelRule({
                    ...context,
                    selfGrammar: context.baseGrammar
                }, result);
                break;
            case 1 /* Self */ :
                collectExternalReferencesInTopLevelRule(context, result);
                break;
            case 2 /* RelativeReference */ :
                collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, {
                    ...context,
                    repository: patternRepository
                }, result);
                break;
            case 3 /* TopLevelReference */ :
            case 4 /* TopLevelRepositoryReference */ :
                const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;
                if (selfGrammar) {
                    const newContext = {
                        baseGrammar: context.baseGrammar,
                        selfGrammar,
                        repository: patternRepository
                    };
                    if (reference.kind === 4 /* TopLevelRepositoryReference */ ) {
                        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);
                    } else {
                        collectExternalReferencesInTopLevelRule(newContext, result);
                    }
                } else {
                    if (reference.kind === 4 /* TopLevelRepositoryReference */ ) {
                        result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));
                    } else {
                        result.add(new TopLevelRuleReference(reference.scopeName));
                    }
                }
                break;
        }
    }
}
var BaseReference = class {
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "kind", 0 /* Base */ );
    }
};
var SelfReference = class {
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "kind", 1 /* Self */ );
    }
};
var RelativeReference = class {
    constructor(ruleName){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "kind", 2 /* RelativeReference */ );
        this.ruleName = ruleName;
    }
};
var TopLevelReference = class {
    constructor(scopeName){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "kind", 3 /* TopLevelReference */ );
        this.scopeName = scopeName;
    }
};
var TopLevelRepositoryReference = class {
    constructor(scopeName, ruleName){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "kind", 4 /* TopLevelRepositoryReference */ );
        this.scopeName = scopeName;
        this.ruleName = ruleName;
    }
};
function parseInclude(include) {
    if (include === "$base") {
        return new BaseReference();
    } else if (include === "$self") {
        return new SelfReference();
    }
    const indexOfSharp = include.indexOf("#");
    if (indexOfSharp === -1) {
        return new TopLevelReference(include);
    } else if (indexOfSharp === 0) {
        return new RelativeReference(include.substring(1));
    } else {
        const scopeName = include.substring(0, indexOfSharp);
        const ruleName = include.substring(indexOfSharp + 1);
        return new TopLevelRepositoryReference(scopeName, ruleName);
    }
}
// src/rule.ts
var HAS_BACK_REFERENCES = /\\(\d+)/;
var BACK_REFERENCING_END = /\\(\d+)/g;
var ruleIdSymbol = Symbol("RuleId");
var endRuleId = -1;
var whileRuleId = -2;
function ruleIdFromNumber(id) {
    return id;
}
function ruleIdToNumber(id) {
    return id;
}
var Rule = class {
    get debugName() {
        const location = this.$location ? "".concat(basename(this.$location.filename), ":").concat(this.$location.line) : "unknown";
        return "".concat(this.constructor.name, "#").concat(this.id, " @ ").concat(location);
    }
    getName(lineText, captureIndices) {
        if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {
            return this._name;
        }
        return RegexSource.replaceCaptures(this._name, lineText, captureIndices);
    }
    getContentName(lineText, captureIndices) {
        if (!this._contentNameIsCapturing || this._contentName === null) {
            return this._contentName;
        }
        return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);
    }
    constructor($location, id, name, contentName){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "$location", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_nameIsCapturing", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_name", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_contentNameIsCapturing", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_contentName", void 0);
        this.$location = $location;
        this.id = id;
        this._name = name || null;
        this._nameIsCapturing = RegexSource.hasCaptures(this._name);
        this._contentName = contentName || null;
        this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);
    }
};
var CaptureRule = class extends Rule {
    dispose() {}
    collectPatterns(grammar, out) {
        throw new Error("Not supported!");
    }
    compile(grammar, endRegexSource) {
        throw new Error("Not supported!");
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
        throw new Error("Not supported!");
    }
    constructor($location, id, name, contentName, retokenizeCapturedWithRuleId){
        super($location, id, name, contentName), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "retokenizeCapturedWithRuleId", void 0);
        this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;
    }
};
var MatchRule = class extends Rule {
    dispose() {
        if (this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns.dispose();
            this._cachedCompiledPatterns = null;
        }
    }
    get debugMatchRegExp() {
        return "".concat(this._match.source);
    }
    collectPatterns(grammar, out) {
        out.push(this._match);
    }
    compile(grammar, endRegexSource) {
        return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new RegExpSourceList();
            this.collectPatterns(grammar, this._cachedCompiledPatterns);
        }
        return this._cachedCompiledPatterns;
    }
    constructor($location, id, name, match, captures){
        super($location, id, name, null), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_match", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "captures", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedCompiledPatterns", void 0);
        this._match = new RegExpSource(match, this.id);
        this.captures = captures;
        this._cachedCompiledPatterns = null;
    }
};
var IncludeOnlyRule = class extends Rule {
    dispose() {
        if (this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns.dispose();
            this._cachedCompiledPatterns = null;
        }
    }
    collectPatterns(grammar, out) {
        for (const pattern of this.patterns){
            const rule = grammar.getRule(pattern);
            rule.collectPatterns(grammar, out);
        }
    }
    compile(grammar, endRegexSource) {
        return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new RegExpSourceList();
            this.collectPatterns(grammar, this._cachedCompiledPatterns);
        }
        return this._cachedCompiledPatterns;
    }
    constructor($location, id, name, contentName, patterns){
        super($location, id, name, contentName), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hasMissingPatterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "patterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedCompiledPatterns", void 0);
        this.patterns = patterns.patterns;
        this.hasMissingPatterns = patterns.hasMissingPatterns;
        this._cachedCompiledPatterns = null;
    }
};
var BeginEndRule = class extends Rule {
    dispose() {
        if (this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns.dispose();
            this._cachedCompiledPatterns = null;
        }
    }
    get debugBeginRegExp() {
        return "".concat(this._begin.source);
    }
    get debugEndRegExp() {
        return "".concat(this._end.source);
    }
    getEndWithResolvedBackReferences(lineText, captureIndices) {
        return this._end.resolveBackReferences(lineText, captureIndices);
    }
    collectPatterns(grammar, out) {
        out.push(this._begin);
    }
    compile(grammar, endRegexSource) {
        return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
        return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar, endRegexSource) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new RegExpSourceList();
            for (const pattern of this.patterns){
                const rule = grammar.getRule(pattern);
                rule.collectPatterns(grammar, this._cachedCompiledPatterns);
            }
            if (this.applyEndPatternLast) {
                this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);
            } else {
                this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
            }
        }
        if (this._end.hasBackReferences) {
            if (this.applyEndPatternLast) {
                this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);
            } else {
                this._cachedCompiledPatterns.setSource(0, endRegexSource);
            }
        }
        return this._cachedCompiledPatterns;
    }
    constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns){
        super($location, id, name, contentName), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_begin", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "beginCaptures", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_end", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "endHasBackReferences", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "endCaptures", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "applyEndPatternLast", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hasMissingPatterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "patterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedCompiledPatterns", void 0);
        this._begin = new RegExpSource(begin, this.id);
        this.beginCaptures = beginCaptures;
        this._end = new RegExpSource(end ? end : "\uFFFF", -1);
        this.endHasBackReferences = this._end.hasBackReferences;
        this.endCaptures = endCaptures;
        this.applyEndPatternLast = applyEndPatternLast || false;
        this.patterns = patterns.patterns;
        this.hasMissingPatterns = patterns.hasMissingPatterns;
        this._cachedCompiledPatterns = null;
    }
};
var BeginWhileRule = class extends Rule {
    dispose() {
        if (this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns.dispose();
            this._cachedCompiledPatterns = null;
        }
        if (this._cachedCompiledWhilePatterns) {
            this._cachedCompiledWhilePatterns.dispose();
            this._cachedCompiledWhilePatterns = null;
        }
    }
    get debugBeginRegExp() {
        return "".concat(this._begin.source);
    }
    get debugWhileRegExp() {
        return "".concat(this._while.source);
    }
    getWhileWithResolvedBackReferences(lineText, captureIndices) {
        return this._while.resolveBackReferences(lineText, captureIndices);
    }
    collectPatterns(grammar, out) {
        out.push(this._begin);
    }
    compile(grammar, endRegexSource) {
        return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new RegExpSourceList();
            for (const pattern of this.patterns){
                const rule = grammar.getRule(pattern);
                rule.collectPatterns(grammar, this._cachedCompiledPatterns);
            }
        }
        return this._cachedCompiledPatterns;
    }
    compileWhile(grammar, endRegexSource) {
        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);
    }
    compileWhileAG(grammar, endRegexSource, allowA, allowG) {
        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledWhilePatterns(grammar, endRegexSource) {
        if (!this._cachedCompiledWhilePatterns) {
            this._cachedCompiledWhilePatterns = new RegExpSourceList();
            this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);
        }
        if (this._while.hasBackReferences) {
            this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : "\uFFFF");
        }
        return this._cachedCompiledWhilePatterns;
    }
    constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns){
        super($location, id, name, contentName), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_begin", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "beginCaptures", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "whileCaptures", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_while", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "whileHasBackReferences", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hasMissingPatterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "patterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedCompiledPatterns", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedCompiledWhilePatterns", void 0);
        this._begin = new RegExpSource(begin, this.id);
        this.beginCaptures = beginCaptures;
        this.whileCaptures = whileCaptures;
        this._while = new RegExpSource(_while, whileRuleId);
        this.whileHasBackReferences = this._while.hasBackReferences;
        this.patterns = patterns.patterns;
        this.hasMissingPatterns = patterns.hasMissingPatterns;
        this._cachedCompiledPatterns = null;
        this._cachedCompiledWhilePatterns = null;
    }
};
var RuleFactory = class _RuleFactory {
    static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {
        return helper.registerRule((id)=>{
            return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);
        });
    }
    static getCompiledRuleId(desc, helper, repository) {
        if (!desc.id) {
            helper.registerRule((id)=>{
                desc.id = id;
                if (desc.match) {
                    return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, _RuleFactory._compileCaptures(desc.captures, helper, repository));
                }
                if (typeof desc.begin === "undefined") {
                    if (desc.repository) {
                        repository = mergeObjects({}, repository, desc.repository);
                    }
                    let patterns = desc.patterns;
                    if (typeof patterns === "undefined" && desc.include) {
                        patterns = [
                            {
                                include: desc.include
                            }
                        ];
                    }
                    return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, _RuleFactory._compilePatterns(patterns, helper, repository));
                }
                if (desc.while) {
                    return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), _RuleFactory._compilePatterns(desc.patterns, helper, repository));
                }
                return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, _RuleFactory._compilePatterns(desc.patterns, helper, repository));
            });
        }
        return desc.id;
    }
    static _compileCaptures(captures, helper, repository) {
        let r = [];
        if (captures) {
            let maximumCaptureId = 0;
            for(const captureId in captures){
                if (captureId === "$vscodeTextmateLocation") {
                    continue;
                }
                const numericCaptureId = parseInt(captureId, 10);
                if (numericCaptureId > maximumCaptureId) {
                    maximumCaptureId = numericCaptureId;
                }
            }
            for(let i = 0; i <= maximumCaptureId; i++){
                r[i] = null;
            }
            for(const captureId in captures){
                if (captureId === "$vscodeTextmateLocation") {
                    continue;
                }
                const numericCaptureId = parseInt(captureId, 10);
                let retokenizeCapturedWithRuleId = 0;
                if (captures[captureId].patterns) {
                    retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);
                }
                r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);
            }
        }
        return r;
    }
    static _compilePatterns(patterns, helper, repository) {
        let r = [];
        if (patterns) {
            for(let i = 0, len = patterns.length; i < len; i++){
                const pattern = patterns[i];
                let ruleId = -1;
                if (pattern.include) {
                    const reference = parseInclude(pattern.include);
                    switch(reference.kind){
                        case 0 /* Base */ :
                        case 1 /* Self */ :
                            ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);
                            break;
                        case 2 /* RelativeReference */ :
                            let localIncludedRule = repository[reference.ruleName];
                            if (localIncludedRule) {
                                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);
                            } else {}
                            break;
                        case 3 /* TopLevelReference */ :
                        case 4 /* TopLevelRepositoryReference */ :
                            const externalGrammarName = reference.scopeName;
                            const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */  ? reference.ruleName : null;
                            const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);
                            if (externalGrammar) {
                                if (externalGrammarInclude) {
                                    let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];
                                    if (externalIncludedRule) {
                                        ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);
                                    } else {}
                                } else {
                                    ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);
                                }
                            } else {}
                            break;
                    }
                } else {
                    ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);
                }
                if (ruleId !== -1) {
                    const rule = helper.getRule(ruleId);
                    let skipRule = false;
                    if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {
                        if (rule.hasMissingPatterns && rule.patterns.length === 0) {
                            skipRule = true;
                        }
                    }
                    if (skipRule) {
                        continue;
                    }
                    r.push(ruleId);
                }
            }
        }
        return {
            patterns: r,
            hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length
        };
    }
};
var RegExpSource = class _RegExpSource {
    clone() {
        return new _RegExpSource(this.source, this.ruleId);
    }
    setSource(newSource) {
        if (this.source === newSource) {
            return;
        }
        this.source = newSource;
        if (this.hasAnchor) {
            this._anchorCache = this._buildAnchorCache();
        }
    }
    resolveBackReferences(lineText, captureIndices) {
        if (typeof this.source !== "string") {
            throw new Error("This method should only be called if the source is a string");
        }
        let capturedValues = captureIndices.map((capture)=>{
            return lineText.substring(capture.start, capture.end);
        });
        BACK_REFERENCING_END.lastIndex = 0;
        return this.source.replace(BACK_REFERENCING_END, (match, g1)=>{
            return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || "");
        });
    }
    _buildAnchorCache() {
        if (typeof this.source !== "string") {
            throw new Error("This method should only be called if the source is a string");
        }
        let A0_G0_result = [];
        let A0_G1_result = [];
        let A1_G0_result = [];
        let A1_G1_result = [];
        let pos, len, ch, nextCh;
        for(pos = 0, len = this.source.length; pos < len; pos++){
            ch = this.source.charAt(pos);
            A0_G0_result[pos] = ch;
            A0_G1_result[pos] = ch;
            A1_G0_result[pos] = ch;
            A1_G1_result[pos] = ch;
            if (ch === "\\") {
                if (pos + 1 < len) {
                    nextCh = this.source.charAt(pos + 1);
                    if (nextCh === "A") {
                        A0_G0_result[pos + 1] = "\uFFFF";
                        A0_G1_result[pos + 1] = "\uFFFF";
                        A1_G0_result[pos + 1] = "A";
                        A1_G1_result[pos + 1] = "A";
                    } else if (nextCh === "G") {
                        A0_G0_result[pos + 1] = "\uFFFF";
                        A0_G1_result[pos + 1] = "G";
                        A1_G0_result[pos + 1] = "\uFFFF";
                        A1_G1_result[pos + 1] = "G";
                    } else {
                        A0_G0_result[pos + 1] = nextCh;
                        A0_G1_result[pos + 1] = nextCh;
                        A1_G0_result[pos + 1] = nextCh;
                        A1_G1_result[pos + 1] = nextCh;
                    }
                    pos++;
                }
            }
        }
        return {
            A0_G0: A0_G0_result.join(""),
            A0_G1: A0_G1_result.join(""),
            A1_G0: A1_G0_result.join(""),
            A1_G1: A1_G1_result.join("")
        };
    }
    resolveAnchors(allowA, allowG) {
        if (!this.hasAnchor || !this._anchorCache || typeof this.source !== "string") {
            return this.source;
        }
        if (allowA) {
            if (allowG) {
                return this._anchorCache.A1_G1;
            } else {
                return this._anchorCache.A1_G0;
            }
        } else {
            if (allowG) {
                return this._anchorCache.A0_G1;
            } else {
                return this._anchorCache.A0_G0;
            }
        }
    }
    constructor(regExpSource, ruleId){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "source", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "ruleId", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hasAnchor", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hasBackReferences", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_anchorCache", void 0);
        if (regExpSource && typeof regExpSource === "string") {
            const len = regExpSource.length;
            let lastPushedPos = 0;
            let output = [];
            let hasAnchor = false;
            for(let pos = 0; pos < len; pos++){
                const ch = regExpSource.charAt(pos);
                if (ch === "\\") {
                    if (pos + 1 < len) {
                        const nextCh = regExpSource.charAt(pos + 1);
                        if (nextCh === "z") {
                            output.push(regExpSource.substring(lastPushedPos, pos));
                            output.push("$(?!\\n)(?<!\\n)");
                            lastPushedPos = pos + 2;
                        } else if (nextCh === "A" || nextCh === "G") {
                            hasAnchor = true;
                        }
                        pos++;
                    }
                }
            }
            this.hasAnchor = hasAnchor;
            if (lastPushedPos === 0) {
                this.source = regExpSource;
            } else {
                output.push(regExpSource.substring(lastPushedPos, len));
                this.source = output.join("");
            }
        } else {
            this.hasAnchor = false;
            this.source = regExpSource;
        }
        if (this.hasAnchor) {
            this._anchorCache = this._buildAnchorCache();
        } else {
            this._anchorCache = null;
        }
        this.ruleId = ruleId;
        if (typeof this.source === "string") {
            this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);
        } else {
            this.hasBackReferences = false;
        }
    }
};
var RegExpSourceList = class {
    dispose() {
        this._disposeCaches();
    }
    _disposeCaches() {
        if (this._cached) {
            this._cached.dispose();
            this._cached = null;
        }
        if (this._anchorCache.A0_G0) {
            this._anchorCache.A0_G0.dispose();
            this._anchorCache.A0_G0 = null;
        }
        if (this._anchorCache.A0_G1) {
            this._anchorCache.A0_G1.dispose();
            this._anchorCache.A0_G1 = null;
        }
        if (this._anchorCache.A1_G0) {
            this._anchorCache.A1_G0.dispose();
            this._anchorCache.A1_G0 = null;
        }
        if (this._anchorCache.A1_G1) {
            this._anchorCache.A1_G1.dispose();
            this._anchorCache.A1_G1 = null;
        }
    }
    push(item) {
        this._items.push(item);
        this._hasAnchors = this._hasAnchors || item.hasAnchor;
    }
    unshift(item) {
        this._items.unshift(item);
        this._hasAnchors = this._hasAnchors || item.hasAnchor;
    }
    length() {
        return this._items.length;
    }
    setSource(index, newSource) {
        if (this._items[index].source !== newSource) {
            this._disposeCaches();
            this._items[index].setSource(newSource);
        }
    }
    compile(onigLib) {
        if (!this._cached) {
            let regExps = this._items.map((e)=>e.source);
            this._cached = new CompiledRule(onigLib, regExps, this._items.map((e)=>e.ruleId));
        }
        return this._cached;
    }
    compileAG(onigLib, allowA, allowG) {
        if (!this._hasAnchors) {
            return this.compile(onigLib);
        } else {
            if (allowA) {
                if (allowG) {
                    if (!this._anchorCache.A1_G1) {
                        this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);
                    }
                    return this._anchorCache.A1_G1;
                } else {
                    if (!this._anchorCache.A1_G0) {
                        this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);
                    }
                    return this._anchorCache.A1_G0;
                }
            } else {
                if (allowG) {
                    if (!this._anchorCache.A0_G1) {
                        this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);
                    }
                    return this._anchorCache.A0_G1;
                } else {
                    if (!this._anchorCache.A0_G0) {
                        this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);
                    }
                    return this._anchorCache.A0_G0;
                }
            }
        }
    }
    _resolveAnchors(onigLib, allowA, allowG) {
        let regExps = this._items.map((e)=>e.resolveAnchors(allowA, allowG));
        return new CompiledRule(onigLib, regExps, this._items.map((e)=>e.ruleId));
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_items", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_hasAnchors", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cached", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_anchorCache", void 0);
        this._items = [];
        this._hasAnchors = false;
        this._cached = null;
        this._anchorCache = {
            A0_G0: null,
            A0_G1: null,
            A1_G0: null,
            A1_G1: null
        };
    }
};
var CompiledRule = class {
    dispose() {
        if (typeof this.scanner.dispose === "function") {
            this.scanner.dispose();
        }
    }
    toString() {
        const r = [];
        for(let i = 0, len = this.rules.length; i < len; i++){
            r.push("   - " + this.rules[i] + ": " + this.regExps[i]);
        }
        return r.join("\n");
    }
    findNextMatchSync(string, startPosition, options) {
        const result = this.scanner.findNextMatchSync(string, startPosition, options);
        if (!result) {
            return null;
        }
        return {
            ruleId: this.rules[result.index],
            captureIndices: result.captureIndices
        };
    }
    constructor(onigLib, regExps, rules){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "scanner", void 0);
        this.regExps = regExps;
        this.rules = rules;
        this.scanner = onigLib.createOnigScanner(regExps);
    }
};
// src/grammar/basicScopesAttributeProvider.ts
var BasicScopeAttributes = class {
    constructor(languageId, tokenType){
        this.languageId = languageId;
        this.tokenType = tokenType;
    }
};
var BasicScopeAttributesProvider = (__BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {
    getDefaultAttributes() {
        return this._defaultAttributes;
    }
    getBasicScopeAttributes(scopeName) {
        if (scopeName === null) {
            return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;
        }
        return this._getBasicScopeAttributes.get(scopeName);
    }
    /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */ _scopeToLanguage(scope) {
        return this._embeddedLanguagesMatcher.match(scope) || 0;
    }
    _toStandardTokenType(scopeName) {
        const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);
        if (!m) {
            return 8 /* NotSet */ ;
        }
        switch(m[1]){
            case "comment":
                return 1 /* Comment */ ;
            case "string":
                return 2 /* String */ ;
            case "regex":
                return 3 /* RegEx */ ;
            case "meta.embedded":
                return 0 /* Other */ ;
        }
        throw new Error("Unexpected match for standard token type!");
    }
    constructor(initialLanguageId, embeddedLanguages){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_defaultAttributes", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_embeddedLanguagesMatcher", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_getBasicScopeAttributes", new CachedFn((scopeName)=>{
            const languageId = this._scopeToLanguage(scopeName);
            const standardTokenType = this._toStandardTokenType(scopeName);
            return new BasicScopeAttributes(languageId, standardTokenType);
        }));
        this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */ );
        this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));
    }
}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__BasicScopeAttributesProvider, "_NULL_SCOPE_METADATA", new BasicScopeAttributes(0, 0)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__BasicScopeAttributesProvider, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/), __BasicScopeAttributesProvider);
var ScopeMatcher = class {
    match(scope) {
        if (!this.scopesRegExp) {
            return void 0;
        }
        const m = scope.match(this.scopesRegExp);
        if (!m) {
            return void 0;
        }
        return this.values.get(m[1]);
    }
    constructor(values){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "values", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "scopesRegExp", void 0);
        if (values.length === 0) {
            this.values = null;
            this.scopesRegExp = null;
        } else {
            this.values = new Map(values);
            const escapedScopes = values.map((param)=>{
                let [scopeName, value] = param;
                return escapeRegExpCharacters(scopeName);
            });
            escapedScopes.sort();
            escapedScopes.reverse();
            this.scopesRegExp = new RegExp("^((".concat(escapedScopes.join(")|("), "))($|\\.)"), "");
        }
    }
};
// src/debug.ts
var DebugFlags = {
    InDebugMode: typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env["VSCODE_TEXTMATE_DEBUG"]
};
var UseOnigurumaFindOptions = false;
// src/grammar/tokenizeString.ts
var TokenizeStringResult = class {
    constructor(stack, stoppedEarly){
        this.stack = stack;
        this.stoppedEarly = stoppedEarly;
    }
};
function _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {
    const lineLength = lineText.content.length;
    let STOP = false;
    let anchorPosition = -1;
    if (checkWhileConditions) {
        const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);
        stack = whileCheckResult.stack;
        linePos = whileCheckResult.linePos;
        isFirstLine = whileCheckResult.isFirstLine;
        anchorPosition = whileCheckResult.anchorPosition;
    }
    const startTime = Date.now();
    while(!STOP){
        if (timeLimit !== 0) {
            const elapsedTime = Date.now() - startTime;
            if (elapsedTime > timeLimit) {
                return new TokenizeStringResult(stack, true);
            }
        }
        scanNext();
    }
    return new TokenizeStringResult(stack, false);
    //TURBOPACK unreachable
    ;
    function scanNext() {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
        if (!r) {
            lineTokens.produce(stack, lineLength);
            STOP = true;
            return;
        }
        const captureIndices = r.captureIndices;
        const matchedRuleId = r.matchedRuleId;
        const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;
        if (matchedRuleId === endRuleId) {
            const poppedRule = stack.getRule(grammar);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            lineTokens.produce(stack, captureIndices[0].start);
            stack = stack.withContentNameScopesList(stack.nameScopesList);
            handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);
            lineTokens.produce(stack, captureIndices[0].end);
            const popped = stack;
            stack = stack.parent;
            anchorPosition = popped.getAnchorPos();
            if (!hasAdvanced && popped.getEnterPos() === linePos) {
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                stack = popped;
                lineTokens.produce(stack, lineLength);
                STOP = true;
                return;
            }
        } else {
            const _rule = grammar.getRule(matchedRuleId);
            lineTokens.produce(stack, captureIndices[0].start);
            const beforePush = stack;
            const scopeName = _rule.getName(lineText.content, captureIndices);
            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
            stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);
            if (_rule instanceof BeginEndRule) {
                const pushedRule = _rule;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
                lineTokens.produce(stack, captureIndices[0].end);
                anchorPosition = captureIndices[0].end;
                const contentName = pushedRule.getContentName(lineText.content, captureIndices);
                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
                stack = stack.withContentNameScopesList(contentNameScopesList);
                if (pushedRule.endHasBackReferences) {
                    stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));
                }
                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    stack = stack.pop();
                    lineTokens.produce(stack, lineLength);
                    STOP = true;
                    return;
                }
            } else if (_rule instanceof BeginWhileRule) {
                const pushedRule = _rule;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
                lineTokens.produce(stack, captureIndices[0].end);
                anchorPosition = captureIndices[0].end;
                const contentName = pushedRule.getContentName(lineText.content, captureIndices);
                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
                stack = stack.withContentNameScopesList(contentNameScopesList);
                if (pushedRule.whileHasBackReferences) {
                    stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));
                }
                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    stack = stack.pop();
                    lineTokens.produce(stack, lineLength);
                    STOP = true;
                    return;
                }
            } else {
                const matchingRule = _rule;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);
                lineTokens.produce(stack, captureIndices[0].end);
                stack = stack.pop();
                if (!hasAdvanced) {
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    stack = stack.safePop();
                    lineTokens.produce(stack, lineLength);
                    STOP = true;
                    return;
                }
            }
        }
        if (captureIndices[0].end > linePos) {
            linePos = captureIndices[0].end;
            isFirstLine = false;
        }
    }
}
function _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {
    let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;
    const whileRules = [];
    for(let node = stack; node; node = node.pop()){
        const nodeRule = node.getRule(grammar);
        if (nodeRule instanceof BeginWhileRule) {
            whileRules.push({
                rule: nodeRule,
                stack: node
            });
        }
    }
    for(let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()){
        const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);
        const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        if (r) {
            const matchedRuleId = r.ruleId;
            if (matchedRuleId !== whileRuleId) {
                stack = whileRule.stack.pop();
                break;
            }
            if (r.captureIndices && r.captureIndices.length) {
                lineTokens.produce(whileRule.stack, r.captureIndices[0].start);
                handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);
                lineTokens.produce(whileRule.stack, r.captureIndices[0].end);
                anchorPosition = r.captureIndices[0].end;
                if (r.captureIndices[0].end > linePos) {
                    linePos = r.captureIndices[0].end;
                    isFirstLine = false;
                }
            }
        } else {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            stack = whileRule.stack.pop();
            break;
        }
    }
    return {
        stack,
        linePos,
        anchorPosition,
        isFirstLine
    };
}
function matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
    const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
    const injections = grammar.getInjections();
    if (injections.length === 0) {
        return matchResult;
    }
    const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
    if (!injectionResult) {
        return matchResult;
    }
    if (!matchResult) {
        return injectionResult;
    }
    const matchResultScore = matchResult.captureIndices[0].start;
    const injectionResultScore = injectionResult.captureIndices[0].start;
    if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {
        return injectionResult;
    }
    return matchResult;
}
function matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
    const rule = stack.getRule(grammar);
    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);
    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (r) {
        return {
            captureIndices: r.captureIndices,
            matchedRuleId: r.ruleId
        };
    }
    return null;
}
function matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
    let bestMatchRating = Number.MAX_VALUE;
    let bestMatchCaptureIndices = null;
    let bestMatchRuleId;
    let bestMatchResultPriority = 0;
    const scopes = stack.contentNameScopesList.getScopeNames();
    for(let i = 0, len = injections.length; i < len; i++){
        const injection = injections[i];
        if (!injection.matcher(scopes)) {
            continue;
        }
        const rule = grammar.getRule(injection.ruleId);
        const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);
        const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
        if (!matchResult) {
            continue;
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const matchRating = matchResult.captureIndices[0].start;
        if (matchRating >= bestMatchRating) {
            continue;
        }
        bestMatchRating = matchRating;
        bestMatchCaptureIndices = matchResult.captureIndices;
        bestMatchRuleId = matchResult.ruleId;
        bestMatchResultPriority = injection.priority;
        if (bestMatchRating === linePos) {
            break;
        }
    }
    if (bestMatchCaptureIndices) {
        return {
            priorityMatch: bestMatchResultPriority === -1,
            captureIndices: bestMatchCaptureIndices,
            matchedRuleId: bestMatchRuleId
        };
    }
    return null;
}
function prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);
    return {
        ruleScanner,
        findOptions: 0 /* None */ 
    };
}
function prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);
    return {
        ruleScanner,
        findOptions: 0 /* None */ 
    };
}
function getFindOptions(allowA, allowG) {
    let options = 0 /* None */ ;
    if (!allowA) {
        options |= 1 /* NotBeginString */ ;
    }
    if (!allowG) {
        options |= 4 /* NotBeginPosition */ ;
    }
    return options;
}
function handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {
    if (captures.length === 0) {
        return;
    }
    const lineTextContent = lineText.content;
    const len = Math.min(captures.length, captureIndices.length);
    const localStack = [];
    const maxEnd = captureIndices[0].end;
    for(let i = 0; i < len; i++){
        const captureRule = captures[i];
        if (captureRule === null) {
            continue;
        }
        const captureIndex = captureIndices[i];
        if (captureIndex.length === 0) {
            continue;
        }
        if (captureIndex.start > maxEnd) {
            break;
        }
        while(localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start){
            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
            localStack.pop();
        }
        if (localStack.length > 0) {
            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);
        } else {
            lineTokens.produce(stack, captureIndex.start);
        }
        if (captureRule.retokenizeCapturedWithRuleId) {
            const scopeName = captureRule.getName(lineTextContent, captureIndices);
            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
            const contentName = captureRule.getContentName(lineTextContent, captureIndices);
            const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
            const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);
            const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));
            _tokenizeString(grammar, onigSubStr, isFirstLine && captureIndex.start === 0, captureIndex.start, stackClone, lineTokens, false, /* no time limit */ 0);
            disposeOnigString(onigSubStr);
            continue;
        }
        const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);
        if (captureRuleScopeName !== null) {
            const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;
            const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);
            localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));
        }
    }
    while(localStack.length > 0){
        lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
        localStack.pop();
    }
}
var LocalStackElement = class {
    constructor(scopes, endPos){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "scopes", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "endPos", void 0);
        this.scopes = scopes;
        this.endPos = endPos;
    }
};
// src/grammar/grammar.ts
function createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {
    return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib);
}
function collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {
    const matchers = createMatchers(selector, nameMatcher);
    const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);
    for (const matcher of matchers){
        result.push({
            debugSelector: selector,
            matcher: matcher.matcher,
            ruleId,
            grammar,
            priority: matcher.priority
        });
    }
}
function nameMatcher(identifers, scopes) {
    if (scopes.length < identifers.length) {
        return false;
    }
    let lastIndex = 0;
    return identifers.every((identifier)=>{
        for(let i = lastIndex; i < scopes.length; i++){
            if (scopesAreMatching(scopes[i], identifier)) {
                lastIndex = i + 1;
                return true;
            }
        }
        return false;
    });
}
function scopesAreMatching(thisScopeName, scopeName) {
    if (!thisScopeName) {
        return false;
    }
    if (thisScopeName === scopeName) {
        return true;
    }
    const len = scopeName.length;
    return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === ".";
}
var Grammar = class {
    get themeProvider() {
        return this._grammarRepository;
    }
    dispose() {
        for (const rule of this._ruleId2desc){
            if (rule) {
                rule.dispose();
            }
        }
    }
    createOnigScanner(sources) {
        return this._onigLib.createOnigScanner(sources);
    }
    createOnigString(sources) {
        return this._onigLib.createOnigString(sources);
    }
    getMetadataForScope(scope) {
        return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);
    }
    _collectInjections() {
        const grammarRepository = {
            lookup: (scopeName2)=>{
                if (scopeName2 === this._rootScopeName) {
                    return this._grammar;
                }
                return this.getExternalGrammar(scopeName2);
            },
            injections: (scopeName2)=>{
                return this._grammarRepository.injections(scopeName2);
            }
        };
        const result = [];
        const scopeName = this._rootScopeName;
        const grammar = grammarRepository.lookup(scopeName);
        if (grammar) {
            const rawInjections = grammar.injections;
            if (rawInjections) {
                for(let expression in rawInjections){
                    collectInjections(result, expression, rawInjections[expression], this, grammar);
                }
            }
            const injectionScopeNames = this._grammarRepository.injections(scopeName);
            if (injectionScopeNames) {
                injectionScopeNames.forEach((injectionScopeName)=>{
                    const injectionGrammar = this.getExternalGrammar(injectionScopeName);
                    if (injectionGrammar) {
                        const selector = injectionGrammar.injectionSelector;
                        if (selector) {
                            collectInjections(result, selector, injectionGrammar, this, injectionGrammar);
                        }
                    }
                });
            }
        }
        result.sort((i1, i2)=>i1.priority - i2.priority);
        return result;
    }
    getInjections() {
        if (this._injections === null) {
            this._injections = this._collectInjections();
        }
        return this._injections;
    }
    registerRule(factory) {
        const id = ++this._lastRuleId;
        const result = factory(ruleIdFromNumber(id));
        this._ruleId2desc[id] = result;
        return result;
    }
    getRule(ruleId) {
        return this._ruleId2desc[ruleIdToNumber(ruleId)];
    }
    getExternalGrammar(scopeName, repository) {
        if (this._includedGrammars[scopeName]) {
            return this._includedGrammars[scopeName];
        } else if (this._grammarRepository) {
            const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);
            if (rawIncludedGrammar) {
                this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);
                return this._includedGrammars[scopeName];
            }
        }
        return void 0;
    }
    tokenizeLine(lineText, prevState) {
        let timeLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        const r = this._tokenize(lineText, prevState, false, timeLimit);
        return {
            tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
            ruleStack: r.ruleStack,
            stoppedEarly: r.stoppedEarly
        };
    }
    tokenizeLine2(lineText, prevState) {
        let timeLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        const r = this._tokenize(lineText, prevState, true, timeLimit);
        return {
            tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
            ruleStack: r.ruleStack,
            stoppedEarly: r.stoppedEarly
        };
    }
    _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {
        if (this._rootId === -1) {
            this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);
            this.getInjections();
        }
        let isFirstLine;
        if (!prevState || prevState === StateStackImpl.NULL) {
            isFirstLine = true;
            const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();
            const defaultStyle = this.themeProvider.getDefaults();
            const defaultMetadata = EncodedTokenMetadata.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);
            const rootScopeName = this.getRule(this._rootId).getName(null, null);
            let scopeList;
            if (rootScopeName) {
                scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);
            } else {
                scopeList = AttributedScopeStack.createRoot("unknown", defaultMetadata);
            }
            prevState = new StateStackImpl(null, this._rootId, -1, -1, false, null, scopeList, scopeList);
        } else {
            isFirstLine = false;
            prevState.reset();
        }
        lineText = lineText + "\n";
        const onigLineText = this.createOnigString(lineText);
        const lineLength = onigLineText.content.length;
        const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);
        const r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);
        disposeOnigString(onigLineText);
        return {
            lineLength,
            lineTokens,
            ruleStack: r.stack,
            stoppedEarly: r.stoppedEarly
        };
    }
    constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_rootId", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lastRuleId", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_ruleId2desc", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_includedGrammars", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_grammarRepository", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_grammar", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_injections", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_basicScopeAttributesProvider", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_tokenTypeMatchers", void 0);
        this._rootScopeName = _rootScopeName;
        this.balancedBracketSelectors = balancedBracketSelectors;
        this._onigLib = _onigLib;
        this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);
        this._rootId = -1;
        this._lastRuleId = 0;
        this._ruleId2desc = [
            null
        ];
        this._includedGrammars = {};
        this._grammarRepository = grammarRepository;
        this._grammar = initGrammar(grammar, null);
        this._injections = null;
        this._tokenTypeMatchers = [];
        if (tokenTypes) {
            for (const selector of Object.keys(tokenTypes)){
                const matchers = createMatchers(selector, nameMatcher);
                for (const matcher of matchers){
                    this._tokenTypeMatchers.push({
                        matcher: matcher.matcher,
                        type: tokenTypes[selector]
                    });
                }
            }
        }
    }
};
function initGrammar(grammar, base) {
    grammar = clone(grammar);
    grammar.repository = grammar.repository || {};
    grammar.repository.$self = {
        $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,
        patterns: grammar.patterns,
        name: grammar.scopeName
    };
    grammar.repository.$base = base || grammar.repository.$self;
    return grammar;
}
var AttributedScopeStack = class _AttributedScopeStack {
    static fromExtension(namesScopeList, contentNameScopesList) {
        let current = namesScopeList;
        var _namesScopeList_scopePath;
        let scopeNames = (_namesScopeList_scopePath = namesScopeList === null || namesScopeList === void 0 ? void 0 : namesScopeList.scopePath) !== null && _namesScopeList_scopePath !== void 0 ? _namesScopeList_scopePath : null;
        for (const frame of contentNameScopesList){
            scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);
            current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);
        }
        return current;
    }
    static createRoot(scopeName, tokenAttributes) {
        return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);
    }
    static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {
        const rawRootMetadata = grammar.getMetadataForScope(scopeName);
        const scopePath = new ScopeStack(null, scopeName);
        const rootStyle = grammar.themeProvider.themeMatch(scopePath);
        const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);
        return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);
    }
    get scopeName() {
        return this.scopePath.scopeName;
    }
    toString() {
        return this.getScopeNames().join(" ");
    }
    equals(other) {
        return _AttributedScopeStack.equals(this, other);
    }
    static equals(a, b) {
        do {
            if (a === b) {
                return true;
            }
            if (!a && !b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {
                return false;
            }
            a = a.parent;
            b = b.parent;
        }while (true)
    }
    static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {
        let fontStyle = -1 /* NotSet */ ;
        let foreground = 0;
        let background = 0;
        if (styleAttributes !== null) {
            fontStyle = styleAttributes.fontStyle;
            foreground = styleAttributes.foregroundId;
            background = styleAttributes.backgroundId;
        }
        return EncodedTokenMetadata.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);
    }
    pushAttributed(scopePath, grammar) {
        if (scopePath === null) {
            return this;
        }
        if (scopePath.indexOf(" ") === -1) {
            return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);
        }
        const scopes = scopePath.split(/ /g);
        let result = this;
        for (const scope of scopes){
            result = _AttributedScopeStack._pushAttributed(result, scope, grammar);
        }
        return result;
    }
    static _pushAttributed(target, scopeName, grammar) {
        const rawMetadata = grammar.getMetadataForScope(scopeName);
        const newPath = target.scopePath.push(scopeName);
        const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);
        const metadata = _AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);
        return new _AttributedScopeStack(target, newPath, metadata);
    }
    getScopeNames() {
        return this.scopePath.getSegments();
    }
    getExtensionIfDefined(base) {
        const result = [];
        let self = this;
        while(self && self !== base){
            var _self_parent;
            var _self_parent_scopePath;
            result.push({
                encodedTokenAttributes: self.tokenAttributes,
                scopeNames: self.scopePath.getExtensionIfDefined((_self_parent_scopePath = (_self_parent = self.parent) === null || _self_parent === void 0 ? void 0 : _self_parent.scopePath) !== null && _self_parent_scopePath !== void 0 ? _self_parent_scopePath : null)
            });
            self = self.parent;
        }
        return self === base ? result.reverse() : void 0;
    }
    /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */ constructor(parent, scopePath, tokenAttributes){
        this.parent = parent;
        this.scopePath = scopePath;
        this.tokenAttributes = tokenAttributes;
    }
};
var StateStackImpl = (__StateStackImpl = class _StateStackImpl {
    equals(other) {
        if (other === null) {
            return false;
        }
        return _StateStackImpl._equals(this, other);
    }
    static _equals(a, b) {
        if (a === b) {
            return true;
        }
        if (!this._structuralEquals(a, b)) {
            return false;
        }
        return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);
    }
    /**
   * A structural equals check. Does not take into account `scopes`.
   */ static _structuralEquals(a, b) {
        do {
            if (a === b) {
                return true;
            }
            if (!a && !b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {
                return false;
            }
            a = a.parent;
            b = b.parent;
        }while (true)
    }
    clone() {
        return this;
    }
    static _reset(el) {
        while(el){
            el._enterPos = -1;
            el._anchorPos = -1;
            el = el.parent;
        }
    }
    reset() {
        _StateStackImpl._reset(this);
    }
    pop() {
        return this.parent;
    }
    safePop() {
        if (this.parent) {
            return this.parent;
        }
        return this;
    }
    push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
        return new _StateStackImpl(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);
    }
    getEnterPos() {
        return this._enterPos;
    }
    getAnchorPos() {
        return this._anchorPos;
    }
    getRule(grammar) {
        return grammar.getRule(this.ruleId);
    }
    toString() {
        const r = [];
        this._writeString(r, 0);
        return "[" + r.join(",") + "]";
    }
    _writeString(res, outIndex) {
        var _this_nameScopesList, _this_contentNameScopesList;
        if (this.parent) {
            outIndex = this.parent._writeString(res, outIndex);
        }
        res[outIndex++] = "(".concat(this.ruleId, ", ").concat((_this_nameScopesList = this.nameScopesList) === null || _this_nameScopesList === void 0 ? void 0 : _this_nameScopesList.toString(), ", ").concat((_this_contentNameScopesList = this.contentNameScopesList) === null || _this_contentNameScopesList === void 0 ? void 0 : _this_contentNameScopesList.toString(), ")");
        return outIndex;
    }
    withContentNameScopesList(contentNameScopeStack) {
        if (this.contentNameScopesList === contentNameScopeStack) {
            return this;
        }
        return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);
    }
    withEndRule(endRule) {
        if (this.endRule === endRule) {
            return this;
        }
        return new _StateStackImpl(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);
    }
    // Used to warn of endless loops
    hasSameRuleAs(other) {
        let el = this;
        while(el && el._enterPos === other._enterPos){
            if (el.ruleId === other.ruleId) {
                return true;
            }
            el = el.parent;
        }
        return false;
    }
    toStateStackFrame() {
        var _this_parent, _this_nameScopesList, _this_contentNameScopesList;
        var _this_parent_nameScopesList, _this_nameScopesList_getExtensionIfDefined, _this_contentNameScopesList_getExtensionIfDefined;
        return {
            ruleId: ruleIdToNumber(this.ruleId),
            beginRuleCapturedEOL: this.beginRuleCapturedEOL,
            endRule: this.endRule,
            nameScopesList: (_this_nameScopesList_getExtensionIfDefined = (_this_nameScopesList = this.nameScopesList) === null || _this_nameScopesList === void 0 ? void 0 : _this_nameScopesList.getExtensionIfDefined((_this_parent_nameScopesList = (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.nameScopesList) !== null && _this_parent_nameScopesList !== void 0 ? _this_parent_nameScopesList : null)) !== null && _this_nameScopesList_getExtensionIfDefined !== void 0 ? _this_nameScopesList_getExtensionIfDefined : [],
            contentNameScopesList: (_this_contentNameScopesList_getExtensionIfDefined = (_this_contentNameScopesList = this.contentNameScopesList) === null || _this_contentNameScopesList === void 0 ? void 0 : _this_contentNameScopesList.getExtensionIfDefined(this.nameScopesList)) !== null && _this_contentNameScopesList_getExtensionIfDefined !== void 0 ? _this_contentNameScopesList_getExtensionIfDefined : []
        };
    }
    static pushFrame(self, frame) {
        var _self_nameScopesList;
        const namesScopeList = AttributedScopeStack.fromExtension((_self_nameScopesList = self === null || self === void 0 ? void 0 : self.nameScopesList) !== null && _self_nameScopesList !== void 0 ? _self_nameScopesList : null, frame.nameScopesList);
        var _frame_enterPos, _frame_anchorPos;
        return new _StateStackImpl(self, ruleIdFromNumber(frame.ruleId), (_frame_enterPos = frame.enterPos) !== null && _frame_enterPos !== void 0 ? _frame_enterPos : -1, (_frame_anchorPos = frame.anchorPos) !== null && _frame_anchorPos !== void 0 ? _frame_anchorPos : -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));
    }
    /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */ constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_stackElementBrand", void 0);
        /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_enterPos", void 0);
        /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_anchorPos", void 0);
        /**
   * The depth of the stack.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "depth", void 0);
        this.parent = parent;
        this.ruleId = ruleId;
        this.beginRuleCapturedEOL = beginRuleCapturedEOL;
        this.endRule = endRule;
        this.nameScopesList = nameScopesList;
        this.contentNameScopesList = contentNameScopesList;
        this.depth = this.parent ? this.parent.depth + 1 : 1;
        this._enterPos = enterPos;
        this._anchorPos = anchorPos;
    }
}, // TODO remove me
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__StateStackImpl, "NULL", new __StateStackImpl(null, 0, 0, 0, false, null, null, null)), __StateStackImpl);
var BalancedBracketSelectors = class {
    get matchesAlways() {
        return this.allowAny && this.unbalancedBracketScopes.length === 0;
    }
    get matchesNever() {
        return this.balancedBracketScopes.length === 0 && !this.allowAny;
    }
    match(scopes) {
        for (const excluder of this.unbalancedBracketScopes){
            if (excluder(scopes)) {
                return false;
            }
        }
        for (const includer of this.balancedBracketScopes){
            if (includer(scopes)) {
                return true;
            }
        }
        return this.allowAny;
    }
    constructor(balancedBracketScopes, unbalancedBracketScopes){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "balancedBracketScopes", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "unbalancedBracketScopes", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "allowAny", false);
        this.balancedBracketScopes = balancedBracketScopes.flatMap((selector)=>{
            if (selector === "*") {
                this.allowAny = true;
                return [];
            }
            return createMatchers(selector, nameMatcher).map((m)=>m.matcher);
        });
        this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector)=>createMatchers(selector, nameMatcher).map((m)=>m.matcher));
    }
};
var LineTokens = class {
    produce(stack, endIndex) {
        this.produceFromScopes(stack.contentNameScopesList, endIndex);
    }
    produceFromScopes(scopesList, endIndex) {
        if (this._lastTokenEndIndex >= endIndex) {
            return;
        }
        if (this._emitBinaryTokens) {
            var _this_balancedBracketSelectors;
            var _scopesList_tokenAttributes;
            let metadata = (_scopesList_tokenAttributes = scopesList === null || scopesList === void 0 ? void 0 : scopesList.tokenAttributes) !== null && _scopesList_tokenAttributes !== void 0 ? _scopesList_tokenAttributes : 0;
            let containsBalancedBrackets = false;
            if ((_this_balancedBracketSelectors = this.balancedBracketSelectors) === null || _this_balancedBracketSelectors === void 0 ? void 0 : _this_balancedBracketSelectors.matchesAlways) {
                containsBalancedBrackets = true;
            }
            if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
                var _scopesList_getScopeNames;
                const scopes2 = (_scopesList_getScopeNames = scopesList === null || scopesList === void 0 ? void 0 : scopesList.getScopeNames()) !== null && _scopesList_getScopeNames !== void 0 ? _scopesList_getScopeNames : [];
                for (const tokenType of this._tokenTypeOverrides){
                    if (tokenType.matcher(scopes2)) {
                        metadata = EncodedTokenMetadata.set(metadata, 0, toOptionalTokenType(tokenType.type), null, -1 /* NotSet */ , 0, 0);
                    }
                }
                if (this.balancedBracketSelectors) {
                    containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);
                }
            }
            if (containsBalancedBrackets) {
                metadata = EncodedTokenMetadata.set(metadata, 0, 8 /* NotSet */ , containsBalancedBrackets, -1 /* NotSet */ , 0, 0);
            }
            if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {
                this._lastTokenEndIndex = endIndex;
                return;
            }
            this._binaryTokens.push(this._lastTokenEndIndex);
            this._binaryTokens.push(metadata);
            this._lastTokenEndIndex = endIndex;
            return;
        }
        var _scopesList_getScopeNames1;
        const scopes = (_scopesList_getScopeNames1 = scopesList === null || scopesList === void 0 ? void 0 : scopesList.getScopeNames()) !== null && _scopesList_getScopeNames1 !== void 0 ? _scopesList_getScopeNames1 : [];
        this._tokens.push({
            startIndex: this._lastTokenEndIndex,
            endIndex,
            // value: lineText.substring(lastTokenEndIndex, endIndex),
            scopes
        });
        this._lastTokenEndIndex = endIndex;
    }
    getResult(stack, lineLength) {
        if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {
            this._tokens.pop();
        }
        if (this._tokens.length === 0) {
            this._lastTokenEndIndex = -1;
            this.produce(stack, lineLength);
            this._tokens[this._tokens.length - 1].startIndex = 0;
        }
        return this._tokens;
    }
    getBinaryResult(stack, lineLength) {
        if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {
            this._binaryTokens.pop();
            this._binaryTokens.pop();
        }
        if (this._binaryTokens.length === 0) {
            this._lastTokenEndIndex = -1;
            this.produce(stack, lineLength);
            this._binaryTokens[this._binaryTokens.length - 2] = 0;
        }
        const result = new Uint32Array(this._binaryTokens.length);
        for(let i = 0, len = this._binaryTokens.length; i < len; i++){
            result[i] = this._binaryTokens[i];
        }
        return result;
    }
    constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_emitBinaryTokens", void 0);
        /**
   * defined only if `false`.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lineText", void 0);
        /**
   * used only if `_emitBinaryTokens` is false.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_tokens", void 0);
        /**
   * used only if `_emitBinaryTokens` is true.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_binaryTokens", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lastTokenEndIndex", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_tokenTypeOverrides", void 0);
        this.balancedBracketSelectors = balancedBracketSelectors;
        this._emitBinaryTokens = emitBinaryTokens;
        this._tokenTypeOverrides = tokenTypeOverrides;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            this._lineText = null;
        }
        this._tokens = [];
        this._binaryTokens = [];
        this._lastTokenEndIndex = 0;
    }
};
// src/registry.ts
var SyncRegistry = class {
    dispose() {
        for (const grammar of this._grammars.values()){
            grammar.dispose();
        }
    }
    setTheme(theme) {
        this._theme = theme;
    }
    getColorMap() {
        return this._theme.getColorMap();
    }
    /**
   * Add `grammar` to registry and return a list of referenced scope names
   */ addGrammar(grammar, injectionScopeNames) {
        this._rawGrammars.set(grammar.scopeName, grammar);
        if (injectionScopeNames) {
            this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);
        }
    }
    /**
   * Lookup a raw grammar.
   */ lookup(scopeName) {
        return this._rawGrammars.get(scopeName);
    }
    /**
   * Returns the injections for the given grammar
   */ injections(targetScope) {
        return this._injectionGrammars.get(targetScope);
    }
    /**
   * Get the default theme settings
   */ getDefaults() {
        return this._theme.getDefaults();
    }
    /**
   * Match a scope in the theme.
   */ themeMatch(scopePath) {
        return this._theme.match(scopePath);
    }
    /**
   * Lookup a grammar.
   */ grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
        if (!this._grammars.has(scopeName)) {
            let rawGrammar = this._rawGrammars.get(scopeName);
            if (!rawGrammar) {
                return null;
            }
            this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, this._onigLib));
        }
        return this._grammars.get(scopeName);
    }
    constructor(theme, _onigLib){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_grammars", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_rawGrammars", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_injectionGrammars", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_theme", void 0);
        this._onigLib = _onigLib;
        this._theme = theme;
    }
};
// src/index.ts
var Registry = class {
    dispose() {
        this._syncRegistry.dispose();
    }
    /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */ setTheme(theme, colorMap) {
        this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));
    }
    /**
   * Returns a lookup array for color ids.
   */ getColorMap() {
        return this._syncRegistry.getColorMap();
    }
    /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */ loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {
        return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, {
            embeddedLanguages
        });
    }
    /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */ loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {
        return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));
    }
    /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */ loadGrammar(initialScopeName) {
        return this._loadGrammar(initialScopeName, 0, null, null, null);
    }
    _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
        const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);
        while(dependencyProcessor.Q.length > 0){
            dependencyProcessor.Q.map((request)=>this._loadSingleGrammar(request.scopeName));
            dependencyProcessor.processQueue();
        }
        return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
    }
    _loadSingleGrammar(scopeName) {
        if (!this._ensureGrammarCache.has(scopeName)) {
            this._doLoadSingleGrammar(scopeName);
            this._ensureGrammarCache.set(scopeName, true);
        }
    }
    _doLoadSingleGrammar(scopeName) {
        const grammar = this._options.loadGrammar(scopeName);
        if (grammar) {
            const injections = typeof this._options.getInjections === "function" ? this._options.getInjections(scopeName) : void 0;
            this._syncRegistry.addGrammar(grammar, injections);
        }
    }
    /**
   * Adds a rawGrammar.
   */ addGrammar(rawGrammar) {
        let injections = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], initialLanguage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, embeddedLanguages = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        this._syncRegistry.addGrammar(rawGrammar, injections);
        return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);
    }
    /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */ _grammarForScopeName(scopeName) {
        let initialLanguage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, embeddedLanguages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, tokenTypes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, balancedBracketSelectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
    }
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_options", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_syncRegistry", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_ensureGrammarCache", void 0);
        this._options = options;
        this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);
        this._ensureGrammarCache = /* @__PURE__ */ new Map();
    }
};
var INITIAL = StateStackImpl.NULL;
;
}),
"[project]/node_modules/html-void-elements/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * List of HTML void tag names.
 *
 * @type {Array<string>}
 */ __turbopack_context__.s([
    "htmlVoidElements",
    ()=>htmlVoidElements
]);
const htmlVoidElements = [
    'area',
    'base',
    'basefont',
    'bgsound',
    'br',
    'col',
    'command',
    'embed',
    'frame',
    'hr',
    'image',
    'img',
    'input',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
];
}),
"[project]/node_modules/zwitch/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @callback Handler
 *   Handle a value, with a certain ID field set to a certain value.
 *   The ID field is passed to `zwitch`, and its value is this functions
 *   place on the `handlers` record.
 * @param {...any} parameters
 *   Arbitrary parameters passed to the zwitch.
 *   The first will be an object with a certain ID field set to a certain value.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback UnknownHandler
 *   Handle values that do have a certain ID field, but its set to a value
 *   that is not listed in the `handlers` record.
 * @param {unknown} value
 *   An object with a certain ID field set to an unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback InvalidHandler
 *   Handle values that do not have a certain ID field.
 * @param {unknown} value
 *   Any unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {void|null|undefined|never}
 *   This should crash or return nothing.
 */ /**
 * @template {InvalidHandler} [Invalid=InvalidHandler]
 * @template {UnknownHandler} [Unknown=UnknownHandler]
 * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]
 * @typedef Options
 *   Configuration (required).
 * @property {Invalid} [invalid]
 *   Handler to use for invalid values.
 * @property {Unknown} [unknown]
 *   Handler to use for unknown values.
 * @property {Handlers} [handlers]
 *   Handlers to use.
 */ __turbopack_context__.s([
    "zwitch",
    ()=>zwitch
]);
const own = {}.hasOwnProperty;
function zwitch(key, options) {
    const settings = options || {};
    /**
   * Handle one value.
   *
   * Based on the bound `key`, a respective handler will be called.
   * If `value` is not an object, or doesnt have a `key` property, the special
   * invalid handler will be called.
   * If `value` has an unknown `key`, the special unknown handler will be
   * called.
   *
   * All arguments, and the context object, are passed through to the handler,
   * and its result is returned.
   *
   * @this {unknown}
   *   Any context object.
   * @param {unknown} [value]
   *   Any value.
   * @param {...unknown} parameters
   *   Arbitrary parameters passed to the zwitch.
   * @property {Handler} invalid
   *   Handle for values that do not have a certain ID field.
   * @property {Handler} unknown
   *   Handle values that do have a certain ID field, but its set to a value
   *   that is not listed in the `handlers` record.
   * @property {Handlers} handlers
   *   Record of handlers.
   * @returns {unknown}
   *   Anything.
   */ function one(value) {
        for(var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            parameters[_key - 1] = arguments[_key];
        }
        /** @type {Handler|undefined} */ let fn = one.invalid;
        const handlers = one.handlers;
        if (value && own.call(value, key)) {
            // @ts-expect-error Indexable.
            const id = String(value[key]);
            // @ts-expect-error Indexable.
            fn = own.call(handlers, id) ? handlers[id] : one.unknown;
        }
        if (fn) {
            return fn.call(this, value, ...parameters);
        }
    }
    one.handlers = settings.handlers || {};
    one.invalid = settings.invalid;
    one.unknown = settings.unknown;
    // @ts-expect-error: matches!
    return one;
}
}),
"[project]/node_modules/stringify-entities/lib/core.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @typedef CoreOptions
 * @property {ReadonlyArray<string>} [subset=[]]
 *   Whether to only escape the given subset of characters.
 * @property {boolean} [escapeOnly=false]
 *   Whether to only escape possibly dangerous characters.
 *   Those characters are `"`, `&`, `'`, `<`, `>`, and `` ` ``.
 *
 * @typedef FormatOptions
 * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format
 *   Format strategy.
 *
 * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions
 */ __turbopack_context__.s([
    "core",
    ()=>core
]);
const defaultSubsetRegex = /["&'<>`]/g;
const surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
const controlCharactersRegex = // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
const regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */ const subsetToRegexCache = new WeakMap();
function core(value, options) {
    value = value.replace(options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex, basic);
    if (options.subset || options.escapeOnly) {
        return value;
    }
    return value// Surrogate pairs.
    .replace(surrogatePairsRegex, surrogate)// BMP control characters (C0 except for LF, CR, SP; DEL; and some more
    // non-ASCII ones).
    .replace(controlCharactersRegex, basic);
    //TURBOPACK unreachable
    ;
    /**
   * @param {string} pair
   * @param {number} index
   * @param {string} all
   */ function surrogate(pair, index, all) {
        return options.format((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, all.charCodeAt(index + 2), options);
    }
    /**
   * @param {string} character
   * @param {number} index
   * @param {string} all
   */ function basic(character, index, all) {
        return options.format(character.charCodeAt(0), all.charCodeAt(index + 1), options);
    }
}
/**
 * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.
 * This can improve performance when tooling calls `charactersToExpression` repeatedly
 * with the same subset.
 *
 * @param {ReadonlyArray<string>} subset
 * @returns {RegExp}
 */ function charactersToExpressionCached(subset) {
    let cached = subsetToRegexCache.get(subset);
    if (!cached) {
        cached = charactersToExpression(subset);
        subsetToRegexCache.set(subset, cached);
    }
    return cached;
}
/**
 * @param {ReadonlyArray<string>} subset
 * @returns {RegExp}
 */ function charactersToExpression(subset) {
    /** @type {Array<string>} */ const groups = [];
    let index = -1;
    while(++index < subset.length){
        groups.push(subset[index].replace(regexEscapeRegex, '\\$&'));
    }
    return new RegExp('(?:' + groups.join('|') + ')', 'g');
}
}),
"[project]/node_modules/stringify-entities/lib/util/to-hexadecimal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toHexadecimal",
    ()=>toHexadecimal
]);
const hexadecimalRegex = /[\dA-Fa-f]/;
function toHexadecimal(code, next, omit) {
    const value = '&#x' + code.toString(16).toUpperCase();
    return omit && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value : value + ';';
}
}),
"[project]/node_modules/stringify-entities/lib/util/to-decimal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toDecimal",
    ()=>toDecimal
]);
const decimalRegex = /\d/;
function toDecimal(code, next, omit) {
    const value = '&#' + String(code);
    return omit && next && !decimalRegex.test(String.fromCharCode(next)) ? value : value + ';';
}
}),
"[project]/node_modules/character-entities-legacy/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * List of legacy HTML named character references that dont need a trailing semicolon.
 *
 * @type {Array<string>}
 */ __turbopack_context__.s([
    "characterEntitiesLegacy",
    ()=>characterEntitiesLegacy
]);
const characterEntitiesLegacy = [
    'AElig',
    'AMP',
    'Aacute',
    'Acirc',
    'Agrave',
    'Aring',
    'Atilde',
    'Auml',
    'COPY',
    'Ccedil',
    'ETH',
    'Eacute',
    'Ecirc',
    'Egrave',
    'Euml',
    'GT',
    'Iacute',
    'Icirc',
    'Igrave',
    'Iuml',
    'LT',
    'Ntilde',
    'Oacute',
    'Ocirc',
    'Ograve',
    'Oslash',
    'Otilde',
    'Ouml',
    'QUOT',
    'REG',
    'THORN',
    'Uacute',
    'Ucirc',
    'Ugrave',
    'Uuml',
    'Yacute',
    'aacute',
    'acirc',
    'acute',
    'aelig',
    'agrave',
    'amp',
    'aring',
    'atilde',
    'auml',
    'brvbar',
    'ccedil',
    'cedil',
    'cent',
    'copy',
    'curren',
    'deg',
    'divide',
    'eacute',
    'ecirc',
    'egrave',
    'eth',
    'euml',
    'frac12',
    'frac14',
    'frac34',
    'gt',
    'iacute',
    'icirc',
    'iexcl',
    'igrave',
    'iquest',
    'iuml',
    'laquo',
    'lt',
    'macr',
    'micro',
    'middot',
    'nbsp',
    'not',
    'ntilde',
    'oacute',
    'ocirc',
    'ograve',
    'ordf',
    'ordm',
    'oslash',
    'otilde',
    'ouml',
    'para',
    'plusmn',
    'pound',
    'quot',
    'raquo',
    'reg',
    'sect',
    'shy',
    'sup1',
    'sup2',
    'sup3',
    'szlig',
    'thorn',
    'times',
    'uacute',
    'ucirc',
    'ugrave',
    'uml',
    'uuml',
    'yacute',
    'yen',
    'yuml'
];
}),
"[project]/node_modules/character-entities-html4/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Map of named character references from HTML 4.
 *
 * @type {Record<string, string>}
 */ __turbopack_context__.s([
    "characterEntitiesHtml4",
    ()=>characterEntitiesHtml4
]);
const characterEntitiesHtml4 = {
    nbsp: '',
    iexcl: '',
    cent: '',
    pound: '',
    curren: '',
    yen: '',
    brvbar: '',
    sect: '',
    uml: '',
    copy: '',
    ordf: '',
    laquo: '',
    not: '',
    shy: '',
    reg: '',
    macr: '',
    deg: '',
    plusmn: '',
    sup2: '',
    sup3: '',
    acute: '',
    micro: '',
    para: '',
    middot: '',
    cedil: '',
    sup1: '',
    ordm: '',
    raquo: '',
    frac14: '',
    frac12: '',
    frac34: '',
    iquest: '',
    Agrave: '',
    Aacute: '',
    Acirc: '',
    Atilde: '',
    Auml: '',
    Aring: '',
    AElig: '',
    Ccedil: '',
    Egrave: '',
    Eacute: '',
    Ecirc: '',
    Euml: '',
    Igrave: '',
    Iacute: '',
    Icirc: '',
    Iuml: '',
    ETH: '',
    Ntilde: '',
    Ograve: '',
    Oacute: '',
    Ocirc: '',
    Otilde: '',
    Ouml: '',
    times: '',
    Oslash: '',
    Ugrave: '',
    Uacute: '',
    Ucirc: '',
    Uuml: '',
    Yacute: '',
    THORN: '',
    szlig: '',
    agrave: '',
    aacute: '',
    acirc: '',
    atilde: '',
    auml: '',
    aring: '',
    aelig: '',
    ccedil: '',
    egrave: '',
    eacute: '',
    ecirc: '',
    euml: '',
    igrave: '',
    iacute: '',
    icirc: '',
    iuml: '',
    eth: '',
    ntilde: '',
    ograve: '',
    oacute: '',
    ocirc: '',
    otilde: '',
    ouml: '',
    divide: '',
    oslash: '',
    ugrave: '',
    uacute: '',
    ucirc: '',
    uuml: '',
    yacute: '',
    thorn: '',
    yuml: '',
    fnof: '',
    Alpha: '',
    Beta: '',
    Gamma: '',
    Delta: '',
    Epsilon: '',
    Zeta: '',
    Eta: '',
    Theta: '',
    Iota: '',
    Kappa: '',
    Lambda: '',
    Mu: '',
    Nu: '',
    Xi: '',
    Omicron: '',
    Pi: '',
    Rho: '',
    Sigma: '',
    Tau: '',
    Upsilon: '',
    Phi: '',
    Chi: '',
    Psi: '',
    Omega: '',
    alpha: '',
    beta: '',
    gamma: '',
    delta: '',
    epsilon: '',
    zeta: '',
    eta: '',
    theta: '',
    iota: '',
    kappa: '',
    lambda: '',
    mu: '',
    nu: '',
    xi: '',
    omicron: '',
    pi: '',
    rho: '',
    sigmaf: '',
    sigma: '',
    tau: '',
    upsilon: '',
    phi: '',
    chi: '',
    psi: '',
    omega: '',
    thetasym: '',
    upsih: '',
    piv: '',
    bull: '',
    hellip: '',
    prime: '',
    Prime: '',
    oline: '',
    frasl: '',
    weierp: '',
    image: '',
    real: '',
    trade: '',
    alefsym: '',
    larr: '',
    uarr: '',
    rarr: '',
    darr: '',
    harr: '',
    crarr: '',
    lArr: '',
    uArr: '',
    rArr: '',
    dArr: '',
    hArr: '',
    forall: '',
    part: '',
    exist: '',
    empty: '',
    nabla: '',
    isin: '',
    notin: '',
    ni: '',
    prod: '',
    sum: '',
    minus: '',
    lowast: '',
    radic: '',
    prop: '',
    infin: '',
    ang: '',
    and: '',
    or: '',
    cap: '',
    cup: '',
    int: '',
    there4: '',
    sim: '',
    cong: '',
    asymp: '',
    ne: '',
    equiv: '',
    le: '',
    ge: '',
    sub: '',
    sup: '',
    nsub: '',
    sube: '',
    supe: '',
    oplus: '',
    otimes: '',
    perp: '',
    sdot: '',
    lceil: '',
    rceil: '',
    lfloor: '',
    rfloor: '',
    lang: '',
    rang: '',
    loz: '',
    spades: '',
    clubs: '',
    hearts: '',
    diams: '',
    quot: '"',
    amp: '&',
    lt: '<',
    gt: '>',
    OElig: '',
    oelig: '',
    Scaron: '',
    scaron: '',
    Yuml: '',
    circ: '',
    tilde: '',
    ensp: '',
    emsp: '',
    thinsp: '',
    zwnj: '',
    zwj: '',
    lrm: '',
    rlm: '',
    ndash: '',
    mdash: '',
    lsquo: '',
    rsquo: '',
    sbquo: '',
    ldquo: '',
    rdquo: '',
    bdquo: '',
    dagger: '',
    Dagger: '',
    permil: '',
    lsaquo: '',
    rsaquo: '',
    euro: ''
};
}),
"[project]/node_modules/stringify-entities/lib/constant/dangerous.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * List of legacy (that dont need a trailing `;`) named references which could,
 * depending on what follows them, turn into a different meaning
 *
 * @type {Array<string>}
 */ __turbopack_context__.s([
    "dangerous",
    ()=>dangerous
]);
const dangerous = [
    'cent',
    'copy',
    'divide',
    'gt',
    'lt',
    'not',
    'para',
    'times'
];
}),
"[project]/node_modules/stringify-entities/lib/util/to-named.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toNamed",
    ()=>toNamed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$legacy$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/character-entities-legacy/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$html4$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/character-entities-html4/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$constant$2f$dangerous$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/constant/dangerous.js [app-client] (ecmascript)");
;
;
;
const own = {}.hasOwnProperty;
/**
 * `characterEntitiesHtml4` but inverted.
 *
 * @type {Record<string, string>}
 */ const characters = {};
/** @type {string} */ let key;
for(key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$html4$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["characterEntitiesHtml4"]){
    if (own.call(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$html4$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["characterEntitiesHtml4"], key)) {
        characters[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$html4$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["characterEntitiesHtml4"][key]] = key;
    }
}
const notAlphanumericRegex = /[^\dA-Za-z]/;
function toNamed(code, next, omit, attribute) {
    const character = String.fromCharCode(code);
    if (own.call(characters, character)) {
        const name = characters[character];
        const value = '&' + name;
        if (omit && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$character$2d$entities$2d$legacy$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["characterEntitiesLegacy"].includes(name) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$constant$2f$dangerous$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dangerous"].includes(name) && (!attribute || next && next !== 61 /* `=` */  && notAlphanumericRegex.test(String.fromCharCode(next)))) {
            return value;
        }
        return value + ';';
    }
    return '';
}
}),
"[project]/node_modules/stringify-entities/lib/util/format-smart.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @typedef FormatSmartOptions
 * @property {boolean} [useNamedReferences=false]
 *   Prefer named character references (`&amp;`) where possible.
 * @property {boolean} [useShortestReferences=false]
 *   Prefer the shortest possible reference, if that results in less bytes.
 *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.
 * @property {boolean} [omitOptionalSemicolons=false]
 *   Whether to omit semicolons when possible.
 *   **Note**: This creates what HTML calls parse errors but is otherwise still valid HTML  dont use this except when building a minifier.
 *   Omitting semicolons is possible for certain named and numeric references in some cases.
 * @property {boolean} [attribute=false]
 *   Create character references which dont fail in attributes.
 *   **Note**: `attribute` only applies when operating dangerously with
 *   `omitOptionalSemicolons: true`.
 */ __turbopack_context__.s([
    "formatSmart",
    ()=>formatSmart
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$hexadecimal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/util/to-hexadecimal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$decimal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/util/to-decimal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$named$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/util/to-named.js [app-client] (ecmascript)");
;
;
;
function formatSmart(code, next, options) {
    let numeric = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$hexadecimal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHexadecimal"])(code, next, options.omitOptionalSemicolons);
    /** @type {string|undefined} */ let named;
    if (options.useNamedReferences || options.useShortestReferences) {
        named = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$named$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toNamed"])(code, next, options.omitOptionalSemicolons, options.attribute);
    }
    // Use the shortest numeric reference when requested.
    // A simple algorithm would use decimal for all code points under 100, as
    // those are shorter than hexadecimal:
    //
    // * `&#99;` vs `&#x63;` (decimal shorter)
    // * `&#100;` vs `&#x64;` (equal)
    //
    // However, because we take `next` into consideration when `omit` is used,
    // And it would be possible that decimals are shorter on bigger values as
    // well if `next` is hexadecimal but not decimal, we instead compare both.
    if ((options.useShortestReferences || !named) && options.useShortestReferences) {
        const decimal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$to$2d$decimal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toDecimal"])(code, next, options.omitOptionalSemicolons);
        if (decimal.length < numeric.length) {
            numeric = decimal;
        }
    }
    return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
}),
"[project]/node_modules/stringify-entities/lib/util/format-basic.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * The smallest way to encode a character.
 *
 * @param {number} code
 * @returns {string}
 */ __turbopack_context__.s([
    "formatBasic",
    ()=>formatBasic
]);
function formatBasic(code) {
    return '&#x' + code.toString(16).toUpperCase() + ';';
}
}),
"[project]/node_modules/stringify-entities/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options
 * @typedef {import('./core.js').CoreOptions} LightOptions
 */ __turbopack_context__.s([
    "stringifyEntities",
    ()=>stringifyEntities,
    "stringifyEntitiesLight",
    ()=>stringifyEntitiesLight
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$format$2d$smart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/util/format-smart.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$format$2d$basic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/util/format-basic.js [app-client] (ecmascript)");
;
;
;
function stringifyEntities(value, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["core"])(value, Object.assign({
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$format$2d$smart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatSmart"]
    }, options));
}
function stringifyEntitiesLight(value, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["core"])(value, Object.assign({
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$util$2f$format$2d$basic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatBasic"]
    }, options));
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/comment.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Comment, Parents} from 'hast'
 * @import {State} from '../index.js'
 */ __turbopack_context__.s([
    "comment",
    ()=>comment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/index.js [app-client] (ecmascript)");
;
const htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
// Declare arrays as variables so it can be cached by `stringifyEntities`
const bogusCommentEntitySubset = [
    '>'
];
const commentEntitySubset = [
    '<',
    '>'
];
function comment(node, _1, _2, state) {
    // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>
    return state.settings.bogusComments ? '<?' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])(node.value, Object.assign({}, state.settings.characterReferences, {
        subset: bogusCommentEntitySubset
    })) + '>' : '<!--' + node.value.replace(htmlCommentRegex, encode) + '-->';
    //TURBOPACK unreachable
    ;
    /**
   * @param {string} $0
   */ function encode($0) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])($0, Object.assign({}, state.settings.characterReferences, {
            subset: commentEntitySubset
        }));
    }
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/doctype.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Doctype, Parents} from 'hast'
 * @import {State} from '../index.js'
 */ /**
 * Serialize a doctype.
 *
 * @param {Doctype} _1
 *   Node to handle.
 * @param {number | undefined} _2
 *   Index of `node` in `parent.
 * @param {Parents | undefined} _3
 *   Parent of `node`.
 * @param {State} state
 *   Info passed around about the current state.
 * @returns {string}
 *   Serialized node.
 */ __turbopack_context__.s([
    "doctype",
    ()=>doctype
]);
function doctype(_1, _2, _3, state) {
    return '<!' + (state.settings.upperDoctype ? 'DOCTYPE' : 'doctype') + (state.settings.tightDoctype ? '' : ' ') + 'html>';
}
}),
"[project]/node_modules/ccount/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Count how often a character (or substring) is used in a string.
 *
 * @param {string} value
 *   Value to search in.
 * @param {string} character
 *   Character (or substring) to look for.
 * @return {number}
 *   Number of times `character` occurred in `value`.
 */ __turbopack_context__.s([
    "ccount",
    ()=>ccount
]);
function ccount(value, character) {
    const source = String(value);
    if (typeof character !== 'string') {
        throw new TypeError('Expected character');
    }
    let count = 0;
    let index = source.indexOf(character);
    while(index !== -1){
        count++;
        index = source.indexOf(character, index + character.length);
    }
    return count;
}
}),
"[project]/node_modules/hast-util-to-html/lib/omission/util/siblings.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Parents, RootContent} from 'hast'
 */ __turbopack_context__.s([
    "siblingAfter",
    ()=>siblingAfter,
    "siblingBefore",
    ()=>siblingBefore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-whitespace/lib/index.js [app-client] (ecmascript)");
;
const siblingAfter = siblings(1);
const siblingBefore = siblings(-1);
/** @type {Array<RootContent>} */ const emptyChildren = [];
/**
 * Factory to check siblings in a direction.
 *
 * @param {number} increment
 */ function siblings(increment) {
    return sibling;
    //TURBOPACK unreachable
    ;
    /**
   * Find applicable siblings in a direction.
   *
   * @template {Parents} Parent
   *   Parent type.
   * @param {Parent | undefined} parent
   *   Parent.
   * @param {number | undefined} index
   *   Index of child in `parent`.
   * @param {boolean | undefined} [includeWhitespace=false]
   *   Whether to include whitespace (default: `false`).
   * @returns {Parent extends {children: Array<infer Child>} ? Child | undefined : never}
   *   Child of parent.
   */ function sibling(parent, index, includeWhitespace) {
        const siblings = parent ? parent.children : emptyChildren;
        let offset = (index || 0) + increment;
        let next = siblings[offset];
        if (!includeWhitespace) {
            while(next && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["whitespace"])(next)){
                offset += increment;
                next = siblings[offset];
            }
        }
        // @ts-expect-error: its a correct child.
        return next;
    }
}
}),
"[project]/node_modules/hast-util-to-html/lib/omission/omission.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Element, Parents} from 'hast'
 */ /**
 * @callback OmitHandle
 *   Check if a tag can be omitted.
 * @param {Element} element
 *   Element to check.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether to omit a tag.
 *
 */ __turbopack_context__.s([
    "omission",
    ()=>omission
]);
const own = {}.hasOwnProperty;
function omission(handlers) {
    return omit;
    //TURBOPACK unreachable
    ;
    /**
   * Check if a given node can have a tag omitted.
   *
   * @type {OmitHandle}
   */ function omit(node, index, parent) {
        return own.call(handlers, node.tagName) && handlers[node.tagName](node, index, parent);
    }
}
}),
"[project]/node_modules/hast-util-to-html/lib/omission/closing.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Element, Parents} from 'hast'
 */ __turbopack_context__.s([
    "closing",
    ()=>closing
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-whitespace/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/util/siblings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$omission$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/omission.js [app-client] (ecmascript)");
;
;
;
const closing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$omission$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omission"])({
    body,
    caption: headOrColgroupOrCaption,
    colgroup: headOrColgroupOrCaption,
    dd,
    dt,
    head: headOrColgroupOrCaption,
    html,
    li,
    optgroup,
    option,
    p,
    rp: rubyElement,
    rt: rubyElement,
    tbody,
    td: cells,
    tfoot,
    th: cells,
    thead,
    tr
});
/**
 * Macro for `</head>`, `</colgroup>`, and `</caption>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function headOrColgroupOrCaption(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index, true);
    return !next || next.type !== 'comment' && !(next.type === 'text' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["whitespace"])(next.value.charAt(0)));
}
/**
 * Whether to omit `</html>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function html(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type !== 'comment';
}
/**
 * Whether to omit `</body>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function body(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type !== 'comment';
}
/**
 * Whether to omit `</p>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function p(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return next ? next.type === 'element' && (next.tagName === 'address' || next.tagName === 'article' || next.tagName === 'aside' || next.tagName === 'blockquote' || next.tagName === 'details' || next.tagName === 'div' || next.tagName === 'dl' || next.tagName === 'fieldset' || next.tagName === 'figcaption' || next.tagName === 'figure' || next.tagName === 'footer' || next.tagName === 'form' || next.tagName === 'h1' || next.tagName === 'h2' || next.tagName === 'h3' || next.tagName === 'h4' || next.tagName === 'h5' || next.tagName === 'h6' || next.tagName === 'header' || next.tagName === 'hgroup' || next.tagName === 'hr' || next.tagName === 'main' || next.tagName === 'menu' || next.tagName === 'nav' || next.tagName === 'ol' || next.tagName === 'p' || next.tagName === 'pre' || next.tagName === 'section' || next.tagName === 'table' || next.tagName === 'ul') : !parent || // Confusing parent.
    !(parent.type === 'element' && (parent.tagName === 'a' || parent.tagName === 'audio' || parent.tagName === 'del' || parent.tagName === 'ins' || parent.tagName === 'map' || parent.tagName === 'noscript' || parent.tagName === 'video'));
}
/**
 * Whether to omit `</li>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function li(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && next.tagName === 'li';
}
/**
 * Whether to omit `</dt>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function dt(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return Boolean(next && next.type === 'element' && (next.tagName === 'dt' || next.tagName === 'dd'));
}
/**
 * Whether to omit `</dd>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function dd(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && (next.tagName === 'dt' || next.tagName === 'dd');
}
/**
 * Whether to omit `</rt>` or `</rp>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function rubyElement(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && (next.tagName === 'rp' || next.tagName === 'rt');
}
/**
 * Whether to omit `</optgroup>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function optgroup(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && next.tagName === 'optgroup';
}
/**
 * Whether to omit `</option>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function option(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && (next.tagName === 'option' || next.tagName === 'optgroup');
}
/**
 * Whether to omit `</thead>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function thead(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return Boolean(next && next.type === 'element' && (next.tagName === 'tbody' || next.tagName === 'tfoot'));
}
/**
 * Whether to omit `</tbody>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function tbody(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && (next.tagName === 'tbody' || next.tagName === 'tfoot');
}
/**
 * Whether to omit `</tfoot>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function tfoot(_, index, parent) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
}
/**
 * Whether to omit `</tr>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function tr(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && next.tagName === 'tr';
}
/**
 * Whether to omit `</td>` or `</th>`.
 *
 * @param {Element} _
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the closing tag can be omitted.
 */ function cells(_, index, parent) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(parent, index);
    return !next || next.type === 'element' && (next.tagName === 'td' || next.tagName === 'th');
}
}),
"[project]/node_modules/hast-util-to-html/lib/omission/opening.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Element, Parents} from 'hast'
 */ __turbopack_context__.s([
    "opening",
    ()=>opening
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-whitespace/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/util/siblings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$closing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/closing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$omission$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/omission.js [app-client] (ecmascript)");
;
;
;
;
const opening = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$omission$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omission"])({
    body,
    colgroup,
    head,
    html,
    tbody
});
/**
 * Whether to omit `<html>`.
 *
 * @param {Element} node
 *   Element.
 * @returns {boolean}
 *   Whether the opening tag can be omitted.
 */ function html(node) {
    const head = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(node, -1);
    return !head || head.type !== 'comment';
}
/**
 * Whether to omit `<head>`.
 *
 * @param {Element} node
 *   Element.
 * @returns {boolean}
 *   Whether the opening tag can be omitted.
 */ function head(node) {
    /** @type {Set<string>} */ const seen = new Set();
    // Whether `srcdoc` or not,
    // make sure the content model at least doesnt have too many `base`s/`title`s.
    for (const child of node.children){
        if (child.type === 'element' && (child.tagName === 'base' || child.tagName === 'title')) {
            if (seen.has(child.tagName)) return false;
            seen.add(child.tagName);
        }
    }
    // May be omitted if the element is empty,
    // or if the first thing inside the head element is an element.
    const child = node.children[0];
    return !child || child.type === 'element';
}
/**
 * Whether to omit `<body>`.
 *
 * @param {Element} node
 *   Element.
 * @returns {boolean}
 *   Whether the opening tag can be omitted.
 */ function body(node) {
    const head = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(node, -1, true);
    return !head || head.type !== 'comment' && !(head.type === 'text' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$whitespace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["whitespace"])(head.value.charAt(0))) && !(head.type === 'element' && (head.tagName === 'meta' || head.tagName === 'link' || head.tagName === 'script' || head.tagName === 'style' || head.tagName === 'template'));
}
/**
 * Whether to omit `<colgroup>`.
 * The spec describes some logic for the opening tag, but its easier to
 * implement in the closing tag, to the same effect, so we handle it there
 * instead.
 *
 * @param {Element} node
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the opening tag can be omitted.
 */ function colgroup(node, index, parent) {
    const previous = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingBefore"])(parent, index);
    const head = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(node, -1, true);
    // Previous colgroup was already omitted.
    if (parent && previous && previous.type === 'element' && previous.tagName === 'colgroup' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$closing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["closing"])(previous, parent.children.indexOf(previous), parent)) {
        return false;
    }
    return Boolean(head && head.type === 'element' && head.tagName === 'col');
}
/**
 * Whether to omit `<tbody>`.
 *
 * @param {Element} node
 *   Element.
 * @param {number | undefined} index
 *   Index of element in parent.
 * @param {Parents | undefined} parent
 *   Parent of element.
 * @returns {boolean}
 *   Whether the opening tag can be omitted.
 */ function tbody(node, index, parent) {
    const previous = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingBefore"])(parent, index);
    const head = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$util$2f$siblings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["siblingAfter"])(node, -1);
    // Previous table section was already omitted.
    if (parent && previous && previous.type === 'element' && (previous.tagName === 'thead' || previous.tagName === 'tbody') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$closing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["closing"])(previous, parent.children.indexOf(previous), parent)) {
        return false;
    }
    return Boolean(head && head.type === 'element' && head.tagName === 'tr');
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/element.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Element, Parents, Properties} from 'hast'
 * @import {State} from '../index.js'
 */ __turbopack_context__.s([
    "element",
    ()=>element
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ccount/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$comma$2d$separated$2d$tokens$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/comma-separated-tokens/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$lib$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/property-information/lib/find.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/property-information/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$space$2d$separated$2d$tokens$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/space-separated-tokens/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$closing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/closing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$opening$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/omission/opening.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * Maps of subsets.
 *
 * Each value is a matrix of tuples.
 * The value at `0` causes parse errors, the value at `1` is valid.
 * Of both, the value at `0` is unsafe, and the value at `1` is safe.
 *
 * @type {Record<'double' | 'name' | 'single' | 'unquoted', Array<[Array<string>, Array<string>]>>}
 */ const constants = {
    // See: <https://html.spec.whatwg.org/#attribute-name-state>.
    name: [
        [
            '\t\n\f\r &/=>'.split(''),
            '\t\n\f\r "&\'/=>`'.split('')
        ],
        [
            '\0\t\n\f\r "&\'/<=>'.split(''),
            '\0\t\n\f\r "&\'/<=>`'.split('')
        ]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
    unquoted: [
        [
            '\t\n\f\r &>'.split(''),
            '\0\t\n\f\r "&\'<=>`'.split('')
        ],
        [
            '\0\t\n\f\r "&\'<=>`'.split(''),
            '\0\t\n\f\r "&\'<=>`'.split('')
        ]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
    single: [
        [
            "&'".split(''),
            '"&\'`'.split('')
        ],
        [
            "\0&'".split(''),
            '\0"&\'`'.split('')
        ]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
    double: [
        [
            '"&'.split(''),
            '"&\'`'.split('')
        ],
        [
            '\0"&'.split(''),
            '\0"&\'`'.split('')
        ]
    ]
};
function element(node, index, parent, state) {
    const schema = state.schema;
    const omit = schema.space === 'svg' ? false : state.settings.omitOptionalTags;
    let selfClosing = schema.space === 'svg' ? state.settings.closeEmptyElements : state.settings.voids.includes(node.tagName.toLowerCase());
    /** @type {Array<string>} */ const parts = [];
    /** @type {string} */ let last;
    if (schema.space === 'html' && node.tagName === 'svg') {
        state.schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["svg"];
    }
    const attributes = serializeAttributes(state, node.properties);
    const content = state.all(schema.space === 'html' && node.tagName === 'template' ? node.content : node);
    state.schema = schema;
    // If the node is categorised as void, but it has children, remove the
    // categorisation.
    // This enables for example `menuitem`s, which are void in W3C HTML but not
    // void in WHATWG HTML, to be stringified properly.
    // Note: `menuitem` has since been removed from the HTML spec, and so is no
    // longer void.
    if (content) selfClosing = false;
    if (attributes || !omit || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$opening$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["opening"])(node, index, parent)) {
        parts.push('<', node.tagName, attributes ? ' ' + attributes : '');
        if (selfClosing && (schema.space === 'svg' || state.settings.closeSelfClosing)) {
            last = attributes.charAt(attributes.length - 1);
            if (!state.settings.tightSelfClosing || last === '/' || last && last !== '"' && last !== "'") {
                parts.push(' ');
            }
            parts.push('/');
        }
        parts.push('>');
    }
    parts.push(content);
    if (!selfClosing && (!omit || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$omission$2f$closing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["closing"])(node, index, parent))) {
        parts.push('</' + node.tagName + '>');
    }
    return parts.join('');
}
/**
 * @param {State} state
 * @param {Properties | null | undefined} properties
 * @returns {string}
 */ function serializeAttributes(state, properties) {
    /** @type {Array<string>} */ const values = [];
    let index = -1;
    /** @type {string} */ let key;
    if (properties) {
        for(key in properties){
            if (properties[key] !== null && properties[key] !== undefined) {
                const value = serializeAttribute(state, key, properties[key]);
                if (value) values.push(value);
            }
        }
    }
    while(++index < values.length){
        const last = state.settings.tightAttributes ? values[index].charAt(values[index].length - 1) : undefined;
        // In tight mode, dont add a space after quoted attributes.
        if (index !== values.length - 1 && last !== '"' && last !== "'") {
            values[index] += ' ';
        }
    }
    return values.join('');
}
/**
 * @param {State} state
 * @param {string} key
 * @param {Properties[keyof Properties]} value
 * @returns {string}
 */ function serializeAttribute(state, key, value) {
    const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$lib$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["find"])(state.schema, key);
    const x = state.settings.allowParseErrors && state.schema.space === 'html' ? 0 : 1;
    const y = state.settings.allowDangerousCharacters ? 0 : 1;
    let quote = state.quote;
    /** @type {string | undefined} */ let result;
    if (info.overloadedBoolean && (value === info.attribute || value === '')) {
        value = true;
    } else if ((info.boolean || info.overloadedBoolean) && (typeof value !== 'string' || value === info.attribute || value === '')) {
        value = Boolean(value);
    }
    if (value === null || value === undefined || value === false || typeof value === 'number' && Number.isNaN(value)) {
        return '';
    }
    const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])(info.attribute, Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: constants.name[x][y]
    }));
    // No value.
    // There is currently only one boolean property in SVG: `[download]` on
    // `<a>`.
    // This property does not seem to work in browsers (Firefox, Safari, Chrome),
    // so I cant test if dropping the value works.
    // But I assume that it should:
    //
    // ```html
    // <!doctype html>
    // <svg viewBox="0 0 100 100">
    //   <a href=https://example.com download>
    //     <circle cx=50 cy=40 r=35 />
    //   </a>
    // </svg>
    // ```
    //
    // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>
    if (value === true) return name;
    // `spaces` doesnt accept a second argument, but its given here just to
    // keep the code cleaner.
    value = Array.isArray(value) ? (info.commaSeparated ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$comma$2d$separated$2d$tokens$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$space$2d$separated$2d$tokens$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(value, {
        padLeft: !state.settings.tightCommaSeparatedLists
    }) : String(value);
    if (state.settings.collapseEmptyAttributes && !value) return name;
    // Check unquoted value.
    if (state.settings.preferUnquoted) {
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])(value, Object.assign({}, state.settings.characterReferences, {
            attribute: true,
            subset: constants.unquoted[x][y]
        }));
    }
    // If we dont want unquoted, or if `value` contains character references when
    // unquoted
    if (result !== value) {
        // If the alternative is less common than `quote`, switch.
        if (state.settings.quoteSmart && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ccount"])(value, quote) > (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ccount"])(value, state.alternative)) {
            quote = state.alternative;
        }
        result = quote + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])(value, Object.assign({}, state.settings.characterReferences, {
            // Always encode without parse errors in non-HTML.
            subset: (quote === "'" ? constants.single : constants.double)[x][y],
            attribute: true
        })) + quote;
    }
    // Dont add a `=` for unquoted empties.
    return name + (result ? '=' + result : result);
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/text.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Parents, Text} from 'hast'
 * @import {Raw} from 'mdast-util-to-hast'
 * @import {State} from '../index.js'
 */ __turbopack_context__.s([
    "text",
    ()=>text
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stringify-entities/lib/index.js [app-client] (ecmascript)");
;
// Declare array as variable so it can be cached by `stringifyEntities`
const textEntitySubset = [
    '<',
    '&'
];
function text(node, _, parent, state) {
    // Check if content of `node` should be escaped.
    return parent && parent.type === 'element' && (parent.tagName === 'script' || parent.tagName === 'style') ? node.value : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stringify$2d$entities$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyEntities"])(node.value, Object.assign({}, state.settings.characterReferences, {
        subset: textEntitySubset
    }));
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/raw.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Parents} from 'hast'
 * @import {Raw} from 'mdast-util-to-hast'
 * @import {State} from '../index.js'
 */ __turbopack_context__.s([
    "raw",
    ()=>raw
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/text.js [app-client] (ecmascript)");
;
function raw(node, index, parent, state) {
    return state.settings.allowDangerousHtml ? node.value : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])(node, index, parent, state);
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/root.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Parents, Root} from 'hast'
 * @import {State} from '../index.js'
 */ /**
 * Serialize a root.
 *
 * @param {Root} node
 *   Node to handle.
 * @param {number | undefined} _1
 *   Index of `node` in `parent.
 * @param {Parents | undefined} _2
 *   Parent of `node`.
 * @param {State} state
 *   Info passed around about the current state.
 * @returns {string}
 *   Serialized node.
 */ __turbopack_context__.s([
    "root",
    ()=>root
]);
function root(node, _1, _2, state) {
    return state.all(node);
}
}),
"[project]/node_modules/hast-util-to-html/lib/handle/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Nodes, Parents} from 'hast'
 * @import {State} from '../index.js'
 */ __turbopack_context__.s([
    "handle",
    ()=>handle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zwitch$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zwitch/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$comment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/comment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$doctype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/doctype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$root$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/root.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/text.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const handle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zwitch$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zwitch"])('type', {
    invalid,
    unknown,
    handlers: {
        comment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$comment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["comment"],
        doctype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$doctype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["doctype"],
        element: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"],
        raw: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raw"],
        root: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$root$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["root"],
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"]
    }
});
/**
 * Fail when a non-node is found in the tree.
 *
 * @param {unknown} node
 *   Unknown value.
 * @returns {never}
 *   Never.
 */ function invalid(node) {
    throw new Error('Expected node, not `' + node + '`');
}
/**
 * Fail when a node with an unknown type is found in the tree.
 *
 * @param {unknown} node_
 *  Unknown node.
 * @returns {never}
 *   Never.
 */ function unknown(node_) {
    // `type` is guaranteed by runtime JS.
    const node = node_;
    throw new Error('Cannot compile unknown node `' + node.type + '`');
}
}),
"[project]/node_modules/hast-util-to-html/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @import {Nodes, Parents, RootContent} from 'hast'
 * @import {Schema} from 'property-information'
 * @import {Options as StringifyEntitiesOptions} from 'stringify-entities'
 */ /**
 * @typedef {Omit<StringifyEntitiesOptions, 'attribute' | 'escapeOnly' | 'subset'>} CharacterReferences
 *
 * @typedef Options
 *   Configuration.
 * @property {boolean | null | undefined} [allowDangerousCharacters=false]
 *   Do not encode some characters which cause XSS vulnerabilities in older
 *   browsers (default: `false`).
 *
 *   >  **Danger**: only set this if you completely trust the content.
 * @property {boolean | null | undefined} [allowDangerousHtml=false]
 *   Allow `raw` nodes and insert them as raw HTML (default: `false`).
 *
 *   When `false`, `Raw` nodes are encoded.
 *
 *   >  **Danger**: only set this if you completely trust the content.
 * @property {boolean | null | undefined} [allowParseErrors=false]
 *   Do not encode characters which cause parse errors (even though they work),
 *   to save bytes (default: `false`).
 *
 *   Not used in the SVG space.
 *
 *   >  **Note**: intentionally creates parse errors in markup (how parse
 *   > errors are handled is well defined, so this works but isnt pretty).
 * @property {boolean | null | undefined} [bogusComments=false]
 *   Use bogus comments instead of comments to save byes: `<?charlie>`
 *   instead of `<!--charlie-->` (default: `false`).
 *
 *   >  **Note**: intentionally creates parse errors in markup (how parse
 *   > errors are handled is well defined, so this works but isnt pretty).
 * @property {CharacterReferences | null | undefined} [characterReferences]
 *   Configure how to serialize character references (optional).
 * @property {boolean | null | undefined} [closeEmptyElements=false]
 *   Close SVG elements without any content with slash (`/`) on the opening tag
 *   instead of an end tag: `<circle />` instead of `<circle></circle>`
 *   (default: `false`).
 *
 *   See `tightSelfClosing` to control whether a space is used before the
 *   slash.
 *
 *   Not used in the HTML space.
 * @property {boolean | null | undefined} [closeSelfClosing=false]
 *   Close self-closing nodes with an extra slash (`/`): `<img />` instead of
 *   `<img>` (default: `false`).
 *
 *   See `tightSelfClosing` to control whether a space is used before the
 *   slash.
 *
 *   Not used in the SVG space.
 * @property {boolean | null | undefined} [collapseEmptyAttributes=false]
 *   Collapse empty attributes: get `class` instead of `class=""` (default:
 *   `false`).
 *
 *   Not used in the SVG space.
 *
 *   >  **Note**: boolean attributes (such as `hidden`) are always collapsed.
 * @property {boolean | null | undefined} [omitOptionalTags=false]
 *   Omit optional opening and closing tags (default: `false`).
 *
 *   For example, in `<ol><li>one</li><li>two</li></ol>`, both `</li>` closing
 *   tags can be omitted.
 *   The first because its followed by another `li`, the last because its
 *   followed by nothing.
 *
 *   Not used in the SVG space.
 * @property {boolean | null | undefined} [preferUnquoted=false]
 *   Leave attributes unquoted if that results in less bytes (default: `false`).
 *
 *   Not used in the SVG space.
 * @property {boolean | null | undefined} [quoteSmart=false]
 *   Use the other quote if that results in less bytes (default: `false`).
 * @property {Quote | null | undefined} [quote='"']
 *   Preferred quote to use (default: `'"'`).
 * @property {Space | null | undefined} [space='html']
 *   When an `<svg>` element is found in the HTML space, this package already
 *   automatically switches to and from the SVG space when entering and exiting
 *   it (default: `'html'`).
 *
 *   >  **Note**: hast is not XML.
 *   > It supports SVG as embedded in HTML.
 *   > It does not support the features available in XML.
 *   > Passing SVG might break but fragments of modern SVG should be fine.
 *   > Use [`xast`][xast] if you need to support SVG as XML.
 * @property {boolean | null | undefined} [tightAttributes=false]
 *   Join attributes together, without whitespace, if possible: get
 *   `class="a b"title="c d"` instead of `class="a b" title="c d"` to save
 *   bytes (default: `false`).
 *
 *   Not used in the SVG space.
 *
 *   >  **Note**: intentionally creates parse errors in markup (how parse
 *   > errors are handled is well defined, so this works but isnt pretty).
 * @property {boolean | null | undefined} [tightCommaSeparatedLists=false]
 *   Join known comma-separated attribute values with just a comma (`,`),
 *   instead of padding them on the right as well (`,`, where `` represents a
 *   space) (default: `false`).
 * @property {boolean | null | undefined} [tightDoctype=false]
 *   Drop unneeded spaces in doctypes: `<!doctypehtml>` instead of
 *   `<!doctype html>` to save bytes (default: `false`).
 *
 *   >  **Note**: intentionally creates parse errors in markup (how parse
 *   > errors are handled is well defined, so this works but isnt pretty).
 * @property {boolean | null | undefined} [tightSelfClosing=false]
 *   Do not use an extra space when closing self-closing elements: `<img/>`
 *   instead of `<img />` (default: `false`).
 *
 *   >  **Note**: only used if `closeSelfClosing: true` or
 *   > `closeEmptyElements: true`.
 * @property {boolean | null | undefined} [upperDoctype=false]
 *   Use a `<!DOCTYPE` instead of `<!doctype` (default: `false`).
 *
 *   Useless except for XHTML.
 * @property {ReadonlyArray<string> | null | undefined} [voids]
 *   Tag names of elements to serialize without closing tag (default: `html-void-elements`).
 *
 *   Not used in the SVG space.
 *
 *   >  **Note**: Its highly unlikely that you want to pass this, because
 *   > hast is not for XML, and HTML will not add more void elements.
 *
 * @typedef {'"' | "'"} Quote
 *   HTML quotes for attribute values.
 *
 * @typedef {Omit<Required<{[key in keyof Options]: Exclude<Options[key], null | undefined>}>, 'space' | 'quote'>} Settings
 *
 * @typedef {'html' | 'svg'} Space
 *   Namespace.
 *
 * @typedef State
 *   Info passed around about the current state.
 * @property {(node: Parents | undefined) => string} all
 *   Serialize the children of a parent node.
 * @property {Quote} alternative
 *   Alternative quote.
 * @property {(node: Nodes, index: number | undefined, parent: Parents | undefined) => string} one
 *   Serialize one node.
 * @property {Quote} quote
 *   Preferred quote.
 * @property {Schema} schema
 *   Current schema.
 * @property {Settings} settings
 *   User configuration.
 */ __turbopack_context__.s([
    "all",
    ()=>all,
    "toHtml",
    ()=>toHtml
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$void$2d$elements$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-void-elements/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/property-information/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/handle/index.js [app-client] (ecmascript)");
;
;
;
/** @type {Options} */ const emptyOptions = {};
/** @type {CharacterReferences} */ const emptyCharacterReferences = {};
/** @type {Array<never>} */ const emptyChildren = [];
function toHtml(tree, options) {
    const options_ = options || emptyOptions;
    const quote = options_.quote || '"';
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
        throw new Error('Invalid quote `' + quote + '`, expected `\'` or `"`');
    }
    /** @type {State} */ const state = {
        one,
        all,
        settings: {
            omitOptionalTags: options_.omitOptionalTags || false,
            allowParseErrors: options_.allowParseErrors || false,
            allowDangerousCharacters: options_.allowDangerousCharacters || false,
            quoteSmart: options_.quoteSmart || false,
            preferUnquoted: options_.preferUnquoted || false,
            tightAttributes: options_.tightAttributes || false,
            upperDoctype: options_.upperDoctype || false,
            tightDoctype: options_.tightDoctype || false,
            bogusComments: options_.bogusComments || false,
            tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
            tightSelfClosing: options_.tightSelfClosing || false,
            collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
            allowDangerousHtml: options_.allowDangerousHtml || false,
            voids: options_.voids || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$void$2d$elements$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlVoidElements"],
            characterReferences: options_.characterReferences || emptyCharacterReferences,
            closeSelfClosing: options_.closeSelfClosing || false,
            closeEmptyElements: options_.closeEmptyElements || false
        },
        schema: options_.space === 'svg' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["svg"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$property$2d$information$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["html"],
        quote,
        alternative
    };
    return state.one(Array.isArray(tree) ? {
        type: 'root',
        children: tree
    } : tree, undefined, undefined);
}
/**
 * Serialize a node.
 *
 * @this {State}
 *   Info passed around about the current state.
 * @param {Nodes} node
 *   Node to handle.
 * @param {number | undefined} index
 *   Index of `node` in `parent.
 * @param {Parents | undefined} parent
 *   Parent of `node`.
 * @returns {string}
 *   Serialized node.
 */ function one(node, index, parent) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$handle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handle"])(node, index, parent, this);
}
function all(parent) {
    /** @type {Array<string>} */ const results = [];
    const children = parent && parent.children || emptyChildren;
    let index = -1;
    while(++index < children.length){
        results[index] = this.one(children[index], index, parent);
    }
    return results.join('');
}
}),
"[project]/node_modules/@shikijs/core/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addClassToHast",
    ()=>addClassToHast,
    "applyColorReplacements",
    ()=>applyColorReplacements,
    "codeToHast",
    ()=>codeToHast,
    "codeToHtml",
    ()=>codeToHtml,
    "codeToTokens",
    ()=>codeToTokens,
    "codeToTokensBase",
    ()=>codeToTokensBase,
    "codeToTokensWithThemes",
    ()=>codeToTokensWithThemes,
    "createCssVariablesTheme",
    ()=>createCssVariablesTheme,
    "createHighlighterCore",
    ()=>createHighlighterCore,
    "createHighlighterCoreSync",
    ()=>createHighlighterCoreSync,
    "createPositionConverter",
    ()=>createPositionConverter,
    "createShikiInternal",
    ()=>createShikiInternal,
    "createShikiInternalSync",
    ()=>createShikiInternalSync,
    "createSingletonShorthands",
    ()=>createSingletonShorthands,
    "createdBundledHighlighter",
    ()=>createdBundledHighlighter,
    "enableDeprecationWarnings",
    ()=>enableDeprecationWarnings,
    "flatTokenVariants",
    ()=>flatTokenVariants,
    "getSingletonHighlighterCore",
    ()=>getSingletonHighlighterCore,
    "getTokenStyleObject",
    ()=>getTokenStyleObject,
    "guessEmbeddedLanguages",
    ()=>guessEmbeddedLanguages,
    "hastToHtml",
    ()=>hastToHtml,
    "isNoneTheme",
    ()=>isNoneTheme,
    "isPlainLang",
    ()=>isPlainLang,
    "isSpecialLang",
    ()=>isSpecialLang,
    "isSpecialTheme",
    ()=>isSpecialTheme,
    "makeSingletonHighlighter",
    ()=>makeSingletonHighlighter,
    "makeSingletonHighlighterCore",
    ()=>makeSingletonHighlighterCore,
    "normalizeGetter",
    ()=>normalizeGetter,
    "normalizeTheme",
    ()=>normalizeTheme,
    "resolveColorReplacements",
    ()=>resolveColorReplacements,
    "splitLines",
    ()=>splitLines,
    "splitToken",
    ()=>splitToken,
    "splitTokens",
    ()=>splitTokens,
    "stringifyTokenStyle",
    ()=>stringifyTokenStyle,
    "toArray",
    ()=>toArray,
    "tokenizeAnsiWithTheme",
    ()=>tokenizeAnsiWithTheme,
    "tokenizeWithTheme",
    ()=>tokenizeWithTheme,
    "tokensToHast",
    ()=>tokensToHast,
    "transformerDecorations",
    ()=>transformerDecorations,
    "warnDeprecated",
    ()=>warnDeprecated
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/vscode-textmate/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hast-util-to-html/lib/index.js [app-client] (ecmascript)");
;
;
;
;
;
function resolveColorReplacements(theme, options) {
    const replacements = typeof theme === "string" ? {} : {
        ...theme.colorReplacements
    };
    const themeName = typeof theme === "string" ? theme : theme.name;
    for (const [key, value] of Object.entries((options === null || options === void 0 ? void 0 : options.colorReplacements) || {})){
        if (typeof value === "string") replacements[key] = value;
        else if (key === themeName) Object.assign(replacements, value);
    }
    return replacements;
}
function applyColorReplacements(color, replacements) {
    if (!color) return color;
    return (replacements === null || replacements === void 0 ? void 0 : replacements[color === null || color === void 0 ? void 0 : color.toLowerCase()]) || color;
}
function toArray(x) {
    return Array.isArray(x) ? x : [
        x
    ];
}
async function normalizeGetter(p) {
    return Promise.resolve(typeof p === "function" ? p() : p).then((r)=>r.default || r);
}
function isPlainLang(lang) {
    return !lang || [
        "plaintext",
        "txt",
        "text",
        "plain"
    ].includes(lang);
}
function isSpecialLang(lang) {
    return lang === "ansi" || isPlainLang(lang);
}
function isNoneTheme(theme) {
    return theme === "none";
}
function isSpecialTheme(theme) {
    return isNoneTheme(theme);
}
function addClassToHast(node, className) {
    var _node, _node_properties;
    if (!className) return node;
    (_node = node).properties || (_node.properties = {});
    (_node_properties = node.properties).class || (_node_properties.class = []);
    if (typeof node.properties.class === "string") node.properties.class = node.properties.class.split(/\s+/g);
    if (!Array.isArray(node.properties.class)) node.properties.class = [];
    const targets = Array.isArray(className) ? className : className.split(/\s+/g);
    for (const c of targets){
        if (c && !node.properties.class.includes(c)) node.properties.class.push(c);
    }
    return node;
}
function splitLines(code) {
    let preserveEnding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const parts = code.split(/(\r?\n)/g);
    let index = 0;
    const lines = [];
    for(let i = 0; i < parts.length; i += 2){
        var _parts_;
        const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
        lines.push([
            line,
            index
        ]);
        index += parts[i].length;
        index += ((_parts_ = parts[i + 1]) === null || _parts_ === void 0 ? void 0 : _parts_.length) || 0;
    }
    return lines;
}
function createPositionConverter(code) {
    const lines = splitLines(code, true).map((param)=>{
        let [line] = param;
        return line;
    });
    function indexToPos(index) {
        if (index === code.length) {
            return {
                line: lines.length - 1,
                character: lines[lines.length - 1].length
            };
        }
        let character = index;
        let line = 0;
        for (const lineText of lines){
            if (character < lineText.length) break;
            character -= lineText.length;
            line++;
        }
        return {
            line,
            character
        };
    }
    function posToIndex(line, character) {
        let index = 0;
        for(let i = 0; i < line; i++)index += lines[i].length;
        index += character;
        return index;
    }
    return {
        lines,
        indexToPos,
        posToIndex
    };
}
function guessEmbeddedLanguages(code, _lang, highlighter) {
    const langs = /* @__PURE__ */ new Set();
    for (const match of code.matchAll(/lang=["']([\w-]+)["']/g)){
        langs.add(match[1]);
    }
    for (const match of code.matchAll(/(?:```|~~~)([\w-]+)/g)){
        langs.add(match[1]);
    }
    for (const match of code.matchAll(/\\begin\{([\w-]+)\}/g)){
        langs.add(match[1]);
    }
    if (!highlighter) return Array.from(langs);
    const bundle = highlighter.getBundledLanguages();
    return Array.from(langs).filter((l)=>l && bundle[l]);
}
const DEFAULT_COLOR_LIGHT_DARK = "light-dark()";
const COLOR_KEYS = [
    "color",
    "background-color"
];
function splitToken(token, offsets) {
    let lastOffset = 0;
    const tokens = [];
    for (const offset of offsets){
        if (offset > lastOffset) {
            tokens.push({
                ...token,
                content: token.content.slice(lastOffset, offset),
                offset: token.offset + lastOffset
            });
        }
        lastOffset = offset;
    }
    if (lastOffset < token.content.length) {
        tokens.push({
            ...token,
            content: token.content.slice(lastOffset),
            offset: token.offset + lastOffset
        });
    }
    return tokens;
}
function splitTokens(tokens, breakpoints) {
    const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b)=>a - b);
    if (!sorted.length) return tokens;
    return tokens.map((line)=>{
        return line.flatMap((token)=>{
            const breakpointsInToken = sorted.filter((i)=>token.offset < i && i < token.offset + token.content.length).map((i)=>i - token.offset).sort((a, b)=>a - b);
            if (!breakpointsInToken.length) return token;
            return splitToken(token, breakpointsInToken);
        });
    });
}
function flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor) {
    let colorsRendering = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "css-vars";
    const token = {
        content: merged.content,
        explanation: merged.explanation,
        offset: merged.offset
    };
    const styles = variantsOrder.map((t)=>getTokenStyleObject(merged.variants[t]));
    const styleKeys = new Set(styles.flatMap((t)=>Object.keys(t)));
    const mergedStyles = {};
    const varKey = (idx, key)=>{
        const keyName = key === "color" ? "" : key === "background-color" ? "-bg" : "-".concat(key);
        return cssVariablePrefix + variantsOrder[idx] + (key === "color" ? "" : keyName);
    };
    styles.forEach((cur, idx)=>{
        for (const key of styleKeys){
            const value = cur[key] || "inherit";
            if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {
                if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {
                    const lightIndex = variantsOrder.findIndex((t)=>t === "light");
                    const darkIndex = variantsOrder.findIndex((t)=>t === "dark");
                    if (lightIndex === -1 || darkIndex === -1) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
                    const lightValue = styles[lightIndex][key] || "inherit";
                    const darkValue = styles[darkIndex][key] || "inherit";
                    mergedStyles[key] = "light-dark(".concat(lightValue, ", ").concat(darkValue, ")");
                    if (colorsRendering === "css-vars") mergedStyles[varKey(idx, key)] = value;
                } else {
                    mergedStyles[key] = value;
                }
            } else {
                if (colorsRendering === "css-vars") mergedStyles[varKey(idx, key)] = value;
            }
        }
    });
    token.htmlStyle = mergedStyles;
    return token;
}
function getTokenStyleObject(token) {
    const styles = {};
    if (token.color) styles.color = token.color;
    if (token.bgColor) styles["background-color"] = token.bgColor;
    if (token.fontStyle) {
        if (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Italic) styles["font-style"] = "italic";
        if (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Bold) styles["font-weight"] = "bold";
        const decorations = [];
        if (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Underline) decorations.push("underline");
        if (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Strikethrough) decorations.push("line-through");
        if (decorations.length) styles["text-decoration"] = decorations.join(" ");
    }
    return styles;
}
function stringifyTokenStyle(token) {
    if (typeof token === "string") return token;
    return Object.entries(token).map((param)=>{
        let [key, value] = param;
        return "".concat(key, ":").concat(value);
    }).join(";");
}
const _grammarStateMap = /* @__PURE__ */ new WeakMap();
function setLastGrammarStateToMap(keys, state) {
    _grammarStateMap.set(keys, state);
}
function getLastGrammarStateFromMap(keys) {
    return _grammarStateMap.get(keys);
}
class GrammarState {
    get themes() {
        return Object.keys(this._stacks);
    }
    get theme() {
        return this.themes[0];
    }
    get _stack() {
        return this._stacks[this.theme];
    }
    /**
   * Static method to create a initial grammar state.
   */ static initial(lang, themes) {
        return new GrammarState(Object.fromEntries(toArray(themes).map((theme)=>[
                theme,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INITIAL"]
            ])), lang);
    }
    /**
   * Get the internal stack object.
   * @internal
   */ getInternalStack() {
        let theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.theme;
        return this._stacks[theme];
    }
    getScopes() {
        let theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.theme;
        return getScopes(this._stacks[theme]);
    }
    toJSON() {
        return {
            lang: this.lang,
            theme: this.theme,
            themes: this.themes,
            scopes: this.getScopes()
        };
    }
    constructor(...args){
        /**
   * Theme to Stack mapping
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_stacks", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "lang", void 0);
        if (args.length === 2) {
            const [stacksMap, lang] = args;
            this.lang = lang;
            this._stacks = stacksMap;
        } else {
            const [stack, lang, theme] = args;
            this.lang = lang;
            this._stacks = {
                [theme]: stack
            };
        }
    }
}
function getScopes(stack) {
    const scopes = [];
    const visited = /* @__PURE__ */ new Set();
    function pushScope(stack2) {
        var _stack2_nameScopesList;
        if (visited.has(stack2)) return;
        visited.add(stack2);
        const name = stack2 === null || stack2 === void 0 ? void 0 : (_stack2_nameScopesList = stack2.nameScopesList) === null || _stack2_nameScopesList === void 0 ? void 0 : _stack2_nameScopesList.scopeName;
        if (name) scopes.push(name);
        if (stack2.parent) pushScope(stack2.parent);
    }
    pushScope(stack);
    return scopes;
}
function getGrammarStack(state, theme) {
    if (!(state instanceof GrammarState)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid grammar state");
    return state.getInternalStack(theme);
}
function transformerDecorations() {
    const map = /* @__PURE__ */ new WeakMap();
    function getContext(shiki) {
        if (!map.has(shiki.meta)) {
            let normalizePosition = function(p) {
                if (typeof p === "number") {
                    if (p < 0 || p > shiki.source.length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid decoration offset: ".concat(p, ". Code length: ").concat(shiki.source.length));
                    return {
                        ...converter.indexToPos(p),
                        offset: p
                    };
                } else {
                    const line = converter.lines[p.line];
                    if (line === void 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid decoration position ".concat(JSON.stringify(p), ". Lines length: ").concat(converter.lines.length));
                    let character = p.character;
                    if (character < 0) character = line.length + character;
                    if (character < 0 || character > line.length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid decoration position ".concat(JSON.stringify(p), ". Line ").concat(p.line, " length: ").concat(line.length));
                    return {
                        ...p,
                        character,
                        offset: converter.posToIndex(p.line, character)
                    };
                }
            };
            const converter = createPositionConverter(shiki.source);
            const decorations = (shiki.options.decorations || []).map((d)=>({
                    ...d,
                    start: normalizePosition(d.start),
                    end: normalizePosition(d.end)
                }));
            verifyIntersections(decorations);
            map.set(shiki.meta, {
                decorations,
                converter,
                source: shiki.source
            });
        }
        return map.get(shiki.meta);
    }
    return {
        name: "shiki:decorations",
        tokens (tokens) {
            var _this_options_decorations;
            if (!((_this_options_decorations = this.options.decorations) === null || _this_options_decorations === void 0 ? void 0 : _this_options_decorations.length)) return;
            const ctx = getContext(this);
            const breakpoints = ctx.decorations.flatMap((d)=>[
                    d.start.offset,
                    d.end.offset
                ]);
            const splitted = splitTokens(tokens, breakpoints);
            return splitted;
        },
        code (codeEl) {
            var _this_options_decorations;
            if (!((_this_options_decorations = this.options.decorations) === null || _this_options_decorations === void 0 ? void 0 : _this_options_decorations.length)) return;
            const ctx = getContext(this);
            const lines = Array.from(codeEl.children).filter((i)=>i.type === "element" && i.tagName === "span");
            if (lines.length !== ctx.converter.lines.length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Number of lines in code element (".concat(lines.length, ") does not match the number of lines in the source (").concat(ctx.converter.lines.length, "). Failed to apply decorations."));
            function applyLineSection(line, start, end, decoration) {
                const lineEl = lines[line];
                let text = "";
                let startIndex = -1;
                let endIndex = -1;
                if (start === 0) startIndex = 0;
                if (end === 0) endIndex = 0;
                if (end === Number.POSITIVE_INFINITY) endIndex = lineEl.children.length;
                if (startIndex === -1 || endIndex === -1) {
                    for(let i = 0; i < lineEl.children.length; i++){
                        text += stringify(lineEl.children[i]);
                        if (startIndex === -1 && text.length === start) startIndex = i + 1;
                        if (endIndex === -1 && text.length === end) endIndex = i + 1;
                    }
                }
                if (startIndex === -1) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Failed to find start index for decoration ".concat(JSON.stringify(decoration.start)));
                if (endIndex === -1) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Failed to find end index for decoration ".concat(JSON.stringify(decoration.end)));
                const children = lineEl.children.slice(startIndex, endIndex);
                if (!decoration.alwaysWrap && children.length === lineEl.children.length) {
                    applyDecoration(lineEl, decoration, "line");
                } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") {
                    applyDecoration(children[0], decoration, "token");
                } else {
                    const wrapper = {
                        type: "element",
                        tagName: "span",
                        properties: {},
                        children
                    };
                    applyDecoration(wrapper, decoration, "wrapper");
                    lineEl.children.splice(startIndex, children.length, wrapper);
                }
            }
            function applyLine(line, decoration) {
                lines[line] = applyDecoration(lines[line], decoration, "line");
            }
            function applyDecoration(el, decoration, type) {
                var _decoration_properties;
                const properties = decoration.properties || {};
                const transform = decoration.transform || ((i)=>i);
                el.tagName = decoration.tagName || "span";
                el.properties = {
                    ...el.properties,
                    ...properties,
                    class: el.properties.class
                };
                if ((_decoration_properties = decoration.properties) === null || _decoration_properties === void 0 ? void 0 : _decoration_properties.class) addClassToHast(el, decoration.properties.class);
                el = transform(el, type) || el;
                return el;
            }
            const lineApplies = [];
            const sorted = ctx.decorations.sort((a, b)=>b.start.offset - a.start.offset || a.end.offset - b.end.offset);
            for (const decoration of sorted){
                const { start, end } = decoration;
                if (start.line === end.line) {
                    applyLineSection(start.line, start.character, end.character, decoration);
                } else if (start.line < end.line) {
                    applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
                    for(let i = start.line + 1; i < end.line; i++)lineApplies.unshift(()=>applyLine(i, decoration));
                    applyLineSection(end.line, 0, end.character, decoration);
                }
            }
            lineApplies.forEach((i)=>i());
        }
    };
}
function verifyIntersections(items) {
    for(let i = 0; i < items.length; i++){
        const foo = items[i];
        if (foo.start.offset > foo.end.offset) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid decoration range: ".concat(JSON.stringify(foo.start), " - ").concat(JSON.stringify(foo.end)));
        for(let j = i + 1; j < items.length; j++){
            const bar = items[j];
            const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;
            const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;
            const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;
            const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;
            if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
                if (isFooHasBarStart && isFooHasBarEnd) continue;
                if (isBarHasFooStart && isBarHasFooEnd) continue;
                if (isBarHasFooStart && foo.start.offset === foo.end.offset) continue;
                if (isFooHasBarEnd && bar.start.offset === bar.end.offset) continue;
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Decorations ".concat(JSON.stringify(foo.start), " and ").concat(JSON.stringify(bar.start), " intersect."));
            }
        }
    }
}
function stringify(el) {
    if (el.type === "text") return el.value;
    if (el.type === "element") return el.children.map(stringify).join("");
    return "";
}
const builtInTransformers = [
    /* @__PURE__ */ transformerDecorations()
];
function getTransformers(options) {
    const transformers = sortTransformersByEnforcement(options.transformers || []);
    return [
        ...transformers.pre,
        ...transformers.normal,
        ...transformers.post,
        ...builtInTransformers
    ];
}
function sortTransformersByEnforcement(transformers) {
    const pre = [];
    const post = [];
    const normal = [];
    for (const transformer of transformers){
        switch(transformer.enforce){
            case "pre":
                pre.push(transformer);
                break;
            case "post":
                post.push(transformer);
                break;
            default:
                normal.push(transformer);
        }
    }
    return {
        pre,
        post,
        normal
    };
}
// src/colors.ts
var namedColors = [
    "black",
    "red",
    "green",
    "yellow",
    "blue",
    "magenta",
    "cyan",
    "white",
    "brightBlack",
    "brightRed",
    "brightGreen",
    "brightYellow",
    "brightBlue",
    "brightMagenta",
    "brightCyan",
    "brightWhite"
];
// src/decorations.ts
var decorations = {
    1: "bold",
    2: "dim",
    3: "italic",
    4: "underline",
    7: "reverse",
    8: "hidden",
    9: "strikethrough"
};
// src/parser.ts
function findSequence(value, position) {
    const nextEscape = value.indexOf("\x1B", position);
    if (nextEscape !== -1) {
        if (value[nextEscape + 1] === "[") {
            const nextClose = value.indexOf("m", nextEscape);
            if (nextClose !== -1) {
                return {
                    sequence: value.substring(nextEscape + 2, nextClose).split(";"),
                    startPosition: nextEscape,
                    position: nextClose + 1
                };
            }
        }
    }
    return {
        position: value.length
    };
}
function parseColor(sequence) {
    const colorMode = sequence.shift();
    if (colorMode === "2") {
        const rgb = sequence.splice(0, 3).map((x)=>Number.parseInt(x));
        if (rgb.length !== 3 || rgb.some((x)=>Number.isNaN(x))) return;
        return {
            type: "rgb",
            rgb
        };
    } else if (colorMode === "5") {
        const index = sequence.shift();
        if (index) {
            return {
                type: "table",
                index: Number(index)
            };
        }
    }
}
function parseSequence(sequence) {
    const commands = [];
    while(sequence.length > 0){
        const code = sequence.shift();
        if (!code) continue;
        const codeInt = Number.parseInt(code);
        if (Number.isNaN(codeInt)) continue;
        if (codeInt === 0) {
            commands.push({
                type: "resetAll"
            });
        } else if (codeInt <= 9) {
            const decoration = decorations[codeInt];
            if (decoration) {
                commands.push({
                    type: "setDecoration",
                    value: decorations[codeInt]
                });
            }
        } else if (codeInt <= 29) {
            const decoration = decorations[codeInt - 20];
            if (decoration) {
                commands.push({
                    type: "resetDecoration",
                    value: decoration
                });
                if (decoration === "dim") {
                    commands.push({
                        type: "resetDecoration",
                        value: "bold"
                    });
                }
            }
        } else if (codeInt <= 37) {
            commands.push({
                type: "setForegroundColor",
                value: {
                    type: "named",
                    name: namedColors[codeInt - 30]
                }
            });
        } else if (codeInt === 38) {
            const color = parseColor(sequence);
            if (color) {
                commands.push({
                    type: "setForegroundColor",
                    value: color
                });
            }
        } else if (codeInt === 39) {
            commands.push({
                type: "resetForegroundColor"
            });
        } else if (codeInt <= 47) {
            commands.push({
                type: "setBackgroundColor",
                value: {
                    type: "named",
                    name: namedColors[codeInt - 40]
                }
            });
        } else if (codeInt === 48) {
            const color = parseColor(sequence);
            if (color) {
                commands.push({
                    type: "setBackgroundColor",
                    value: color
                });
            }
        } else if (codeInt === 49) {
            commands.push({
                type: "resetBackgroundColor"
            });
        } else if (codeInt === 53) {
            commands.push({
                type: "setDecoration",
                value: "overline"
            });
        } else if (codeInt === 55) {
            commands.push({
                type: "resetDecoration",
                value: "overline"
            });
        } else if (codeInt >= 90 && codeInt <= 97) {
            commands.push({
                type: "setForegroundColor",
                value: {
                    type: "named",
                    name: namedColors[codeInt - 90 + 8]
                }
            });
        } else if (codeInt >= 100 && codeInt <= 107) {
            commands.push({
                type: "setBackgroundColor",
                value: {
                    type: "named",
                    name: namedColors[codeInt - 100 + 8]
                }
            });
        }
    }
    return commands;
}
function createAnsiSequenceParser() {
    let foreground = null;
    let background = null;
    let decorations2 = /* @__PURE__ */ new Set();
    return {
        parse (value) {
            const tokens = [];
            let position = 0;
            do {
                const findResult = findSequence(value, position);
                const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
                if (text.length > 0) {
                    tokens.push({
                        value: text,
                        foreground,
                        background,
                        decorations: new Set(decorations2)
                    });
                }
                if (findResult.sequence) {
                    const commands = parseSequence(findResult.sequence);
                    for (const styleToken of commands){
                        if (styleToken.type === "resetAll") {
                            foreground = null;
                            background = null;
                            decorations2.clear();
                        } else if (styleToken.type === "resetForegroundColor") {
                            foreground = null;
                        } else if (styleToken.type === "resetBackgroundColor") {
                            background = null;
                        } else if (styleToken.type === "resetDecoration") {
                            decorations2.delete(styleToken.value);
                        }
                    }
                    for (const styleToken of commands){
                        if (styleToken.type === "setForegroundColor") {
                            foreground = styleToken.value;
                        } else if (styleToken.type === "setBackgroundColor") {
                            background = styleToken.value;
                        } else if (styleToken.type === "setDecoration") {
                            decorations2.add(styleToken.value);
                        }
                    }
                }
                position = findResult.position;
            }while (position < value.length)
            return tokens;
        }
    };
}
// src/palette.ts
var defaultNamedColorsMap = {
    black: "#000000",
    red: "#bb0000",
    green: "#00bb00",
    yellow: "#bbbb00",
    blue: "#0000bb",
    magenta: "#ff00ff",
    cyan: "#00bbbb",
    white: "#eeeeee",
    brightBlack: "#555555",
    brightRed: "#ff5555",
    brightGreen: "#00ff00",
    brightYellow: "#ffff55",
    brightBlue: "#5555ff",
    brightMagenta: "#ff55ff",
    brightCyan: "#55ffff",
    brightWhite: "#ffffff"
};
function createColorPalette() {
    let namedColorsMap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultNamedColorsMap;
    function namedColor(name) {
        return namedColorsMap[name];
    }
    function rgbColor(rgb) {
        return "#".concat(rgb.map((x)=>Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join(""));
    }
    let colorTable;
    function getColorTable() {
        if (colorTable) {
            return colorTable;
        }
        colorTable = [];
        for(let i = 0; i < namedColors.length; i++){
            colorTable.push(namedColor(namedColors[i]));
        }
        let levels = [
            0,
            95,
            135,
            175,
            215,
            255
        ];
        for(let r = 0; r < 6; r++){
            for(let g = 0; g < 6; g++){
                for(let b = 0; b < 6; b++){
                    colorTable.push(rgbColor([
                        levels[r],
                        levels[g],
                        levels[b]
                    ]));
                }
            }
        }
        let level = 8;
        for(let i = 0; i < 24; i++, level += 10){
            colorTable.push(rgbColor([
                level,
                level,
                level
            ]));
        }
        return colorTable;
    }
    function tableColor(index) {
        return getColorTable()[index];
    }
    function value(color) {
        switch(color.type){
            case "named":
                return namedColor(color.name);
            case "rgb":
                return rgbColor(color.rgb);
            case "table":
                return tableColor(color.index);
        }
    }
    return {
        value
    };
}
function tokenizeAnsiWithTheme(theme, fileContents, options) {
    const colorReplacements = resolveColorReplacements(theme, options);
    const lines = splitLines(fileContents);
    const colorPalette = createColorPalette(Object.fromEntries(namedColors.map((name)=>{
        var _theme_colors;
        return [
            name,
            (_theme_colors = theme.colors) === null || _theme_colors === void 0 ? void 0 : _theme_colors["terminal.ansi".concat(name[0].toUpperCase()).concat(name.substring(1))]
        ];
    })));
    const parser = createAnsiSequenceParser();
    return lines.map((line)=>parser.parse(line[0]).map((token)=>{
            let color;
            let bgColor;
            if (token.decorations.has("reverse")) {
                color = token.background ? colorPalette.value(token.background) : theme.bg;
                bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
            } else {
                color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
                bgColor = token.background ? colorPalette.value(token.background) : void 0;
            }
            color = applyColorReplacements(color, colorReplacements);
            bgColor = applyColorReplacements(bgColor, colorReplacements);
            if (token.decorations.has("dim")) color = dimColor(color);
            let fontStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].None;
            if (token.decorations.has("bold")) fontStyle |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Bold;
            if (token.decorations.has("italic")) fontStyle |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Italic;
            if (token.decorations.has("underline")) fontStyle |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Underline;
            if (token.decorations.has("strikethrough")) fontStyle |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Strikethrough;
            return {
                content: token.value,
                offset: line[1],
                // TODO: more accurate offset? might need to fork ansi-sequence-parser
                color,
                bgColor,
                fontStyle
            };
        }));
}
function dimColor(color) {
    const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
    if (hexMatch) {
        if (hexMatch[3]) {
            const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
            return "#".concat(hexMatch[1]).concat(hexMatch[2]).concat(alpha);
        } else if (hexMatch[2]) {
            return "#".concat(hexMatch[1]).concat(hexMatch[2], "80");
        } else {
            return "#".concat(Array.from(hexMatch[1]).map((x)=>"".concat(x).concat(x)).join(""), "80");
        }
    }
    const cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
    if (cssVarMatch) return "var(".concat(cssVarMatch[1], "-dim)");
    return color;
}
function codeToTokensBase(internal, code) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { lang = "text", theme: themeName = internal.getLoadedThemes()[0] } = options;
    if (isPlainLang(lang) || isNoneTheme(themeName)) return splitLines(code).map((line)=>[
            {
                content: line[0],
                offset: line[1]
            }
        ]);
    const { theme, colorMap } = internal.setTheme(themeName);
    if (lang === "ansi") return tokenizeAnsiWithTheme(theme, code, options);
    const _grammar = internal.getLanguage(lang);
    if (options.grammarState) {
        if (options.grammarState.lang !== _grammar.name) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]('Grammar state language "'.concat(options.grammarState.lang, '" does not match highlight language "').concat(_grammar.name, '"'));
        }
        if (!options.grammarState.themes.includes(theme.name)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]('Grammar state themes "'.concat(options.grammarState.themes, '" do not contain highlight theme "').concat(theme.name, '"'));
        }
    }
    return tokenizeWithTheme(code, _grammar, theme, colorMap, options);
}
function getLastGrammarState() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    if (args.length === 2) {
        return getLastGrammarStateFromMap(args[1]);
    }
    const [internal, code, options = {}] = args;
    const { lang = "text", theme: themeName = internal.getLoadedThemes()[0] } = options;
    if (isPlainLang(lang) || isNoneTheme(themeName)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Plain language does not have grammar state");
    if (lang === "ansi") throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("ANSI language does not have grammar state");
    const { theme, colorMap } = internal.setTheme(themeName);
    const _grammar = internal.getLanguage(lang);
    return new GrammarState(_tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack, _grammar.name, theme.name);
}
function tokenizeWithTheme(code, grammar, theme, colorMap, options) {
    const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);
    const grammarState = new GrammarState(_tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack, grammar.name, theme.name);
    setLastGrammarStateToMap(result.tokens, grammarState);
    return result.tokens;
}
function _tokenizeWithTheme(code, grammar, theme, colorMap, options) {
    const colorReplacements = resolveColorReplacements(theme, options);
    const { tokenizeMaxLineLength = 0, tokenizeTimeLimit = 500 } = options;
    const lines = splitLines(code);
    var _getGrammarStack;
    let stateStack = options.grammarState ? (_getGrammarStack = getGrammarStack(options.grammarState, theme.name)) !== null && _getGrammarStack !== void 0 ? _getGrammarStack : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INITIAL"] : options.grammarContextCode != null ? _tokenizeWithTheme(options.grammarContextCode, grammar, theme, colorMap, {
        ...options,
        grammarState: void 0,
        grammarContextCode: void 0
    }).stateStack : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INITIAL"];
    let actual = [];
    const final = [];
    for(let i = 0, len = lines.length; i < len; i++){
        const [line, lineOffset] = lines[i];
        if (line === "") {
            actual = [];
            final.push([]);
            continue;
        }
        if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
            actual = [];
            final.push([
                {
                    content: line,
                    offset: lineOffset,
                    color: "",
                    fontStyle: 0
                }
            ]);
            continue;
        }
        let resultWithScopes;
        let tokensWithScopes;
        let tokensWithScopesIndex;
        if (options.includeExplanation) {
            resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);
            tokensWithScopes = resultWithScopes.tokens;
            tokensWithScopesIndex = 0;
        }
        const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);
        const tokensLength = result.tokens.length / 2;
        for(let j = 0; j < tokensLength; j++){
            const startIndex = result.tokens[2 * j];
            const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
            if (startIndex === nextStartIndex) continue;
            const metadata = result.tokens[2 * j + 1];
            const color = applyColorReplacements(colorMap[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EncodedTokenMetadata"].getForeground(metadata)], colorReplacements);
            const fontStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EncodedTokenMetadata"].getFontStyle(metadata);
            const token = {
                content: line.substring(startIndex, nextStartIndex),
                offset: lineOffset + startIndex,
                color,
                fontStyle
            };
            if (options.includeExplanation) {
                const themeSettingsSelectors = [];
                if (options.includeExplanation !== "scopeName") {
                    for (const setting of theme.settings){
                        let selectors;
                        switch(typeof setting.scope){
                            case "string":
                                selectors = setting.scope.split(/,/).map((scope)=>scope.trim());
                                break;
                            case "object":
                                selectors = setting.scope;
                                break;
                            default:
                                continue;
                        }
                        themeSettingsSelectors.push({
                            settings: setting,
                            selectors: selectors.map((selector)=>selector.split(/ /))
                        });
                    }
                }
                token.explanation = [];
                let offset = 0;
                while(startIndex + offset < nextStartIndex){
                    const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
                    const tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
                    offset += tokenWithScopesText.length;
                    token.explanation.push({
                        content: tokenWithScopesText,
                        scopes: options.includeExplanation === "scopeName" ? explainThemeScopesNameOnly(tokenWithScopes.scopes) : explainThemeScopesFull(themeSettingsSelectors, tokenWithScopes.scopes)
                    });
                    tokensWithScopesIndex += 1;
                }
            }
            actual.push(token);
        }
        final.push(actual);
        actual = [];
        stateStack = result.ruleStack;
    }
    return {
        tokens: final,
        stateStack
    };
}
function explainThemeScopesNameOnly(scopes) {
    return scopes.map((scope)=>({
            scopeName: scope
        }));
}
function explainThemeScopesFull(themeSelectors, scopes) {
    const result = [];
    for(let i = 0, len = scopes.length; i < len; i++){
        const scope = scopes[i];
        result[i] = {
            scopeName: scope,
            themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))
        };
    }
    return result;
}
function matchesOne(selector, scope) {
    return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
}
function matches(selectors, scope, parentScopes) {
    if (!matchesOne(selectors[selectors.length - 1], scope)) return false;
    let selectorParentIndex = selectors.length - 2;
    let parentIndex = parentScopes.length - 1;
    while(selectorParentIndex >= 0 && parentIndex >= 0){
        if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex])) selectorParentIndex -= 1;
        parentIndex -= 1;
    }
    if (selectorParentIndex === -1) return true;
    return false;
}
function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
    const result = [];
    for (const { selectors, settings } of themeSettingsSelectors){
        for (const selectorPieces of selectors){
            if (matches(selectorPieces, scope, parentScopes)) {
                result.push(settings);
                break;
            }
        }
    }
    return result;
}
function codeToTokensWithThemes(internal, code, options) {
    const themes = Object.entries(options.themes).filter((i)=>i[1]).map((i)=>({
            color: i[0],
            theme: i[1]
        }));
    const themedTokens = themes.map((t)=>{
        const tokens2 = codeToTokensBase(internal, code, {
            ...options,
            theme: t.theme
        });
        const state = getLastGrammarStateFromMap(tokens2);
        const theme = typeof t.theme === "string" ? t.theme : t.theme.name;
        return {
            tokens: tokens2,
            state,
            theme
        };
    });
    const tokens = syncThemesTokenization(...themedTokens.map((i)=>i.tokens));
    const mergedTokens = tokens[0].map((line, lineIdx)=>line.map((_token, tokenIdx)=>{
            const mergedToken = {
                content: _token.content,
                variants: {},
                offset: _token.offset
            };
            if ("includeExplanation" in options && options.includeExplanation) {
                mergedToken.explanation = _token.explanation;
            }
            tokens.forEach((t, themeIdx)=>{
                const { content: _, explanation: __, offset: ___, ...styles } = t[lineIdx][tokenIdx];
                mergedToken.variants[themes[themeIdx].color] = styles;
            });
            return mergedToken;
        }));
    const mergedGrammarState = themedTokens[0].state ? new GrammarState(Object.fromEntries(themedTokens.map((s)=>{
        var _s_state;
        return [
            s.theme,
            (_s_state = s.state) === null || _s_state === void 0 ? void 0 : _s_state.getInternalStack(s.theme)
        ];
    })), themedTokens[0].state.lang) : void 0;
    if (mergedGrammarState) setLastGrammarStateToMap(mergedTokens, mergedGrammarState);
    return mergedTokens;
}
function syncThemesTokenization() {
    for(var _len = arguments.length, themes = new Array(_len), _key = 0; _key < _len; _key++){
        themes[_key] = arguments[_key];
    }
    const outThemes = themes.map(()=>[]);
    const count = themes.length;
    for(let i = 0; i < themes[0].length; i++){
        const lines = themes.map((t)=>t[i]);
        const outLines = outThemes.map(()=>[]);
        outThemes.forEach((t, i2)=>t.push(outLines[i2]));
        const indexes = lines.map(()=>0);
        const current = lines.map((l)=>l[0]);
        while(current.every((t)=>t)){
            const minLength = Math.min(...current.map((t)=>t.content.length));
            for(let n = 0; n < count; n++){
                const token = current[n];
                if (token.content.length === minLength) {
                    outLines[n].push(token);
                    indexes[n] += 1;
                    current[n] = lines[n][indexes[n]];
                } else {
                    outLines[n].push({
                        ...token,
                        content: token.content.slice(0, minLength)
                    });
                    current[n] = {
                        ...token,
                        content: token.content.slice(minLength),
                        offset: token.offset + minLength
                    };
                }
            }
        }
    }
    return outThemes;
}
function codeToTokens(internal, code, options) {
    let bg;
    let fg;
    let tokens;
    let themeName;
    let rootStyle;
    let grammarState;
    if ("themes" in options) {
        const { defaultColor = "light", cssVariablePrefix = "--shiki-", colorsRendering = "css-vars" } = options;
        const themes = Object.entries(options.themes).filter((i)=>i[1]).map((i)=>({
                color: i[0],
                theme: i[1]
            })).sort((a, b)=>a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
        if (themes.length === 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("`themes` option must not be empty");
        const themeTokens = codeToTokensWithThemes(internal, code, options);
        grammarState = getLastGrammarStateFromMap(themeTokens);
        if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t)=>t.color === defaultColor)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("`themes` option must contain the defaultColor key `".concat(defaultColor, "`"));
        const themeRegs = themes.map((t)=>internal.getTheme(t.theme));
        const themesOrder = themes.map((t)=>t.color);
        tokens = themeTokens.map((line)=>line.map((token)=>flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));
        if (grammarState) setLastGrammarStateToMap(tokens, grammarState);
        const themeColorReplacements = themes.map((t)=>resolveColorReplacements(t.theme, options));
        fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "fg", colorsRendering);
        bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "bg", colorsRendering);
        themeName = "shiki-themes ".concat(themeRegs.map((t)=>t.name).join(" "));
        rootStyle = defaultColor ? void 0 : [
            fg,
            bg
        ].join(";");
    } else if ("theme" in options) {
        const colorReplacements = resolveColorReplacements(options.theme, options);
        tokens = codeToTokensBase(internal, code, options);
        const _theme = internal.getTheme(options.theme);
        bg = applyColorReplacements(_theme.bg, colorReplacements);
        fg = applyColorReplacements(_theme.fg, colorReplacements);
        themeName = _theme.name;
        grammarState = getLastGrammarStateFromMap(tokens);
    } else {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Invalid options, either `theme` or `themes` must be provided");
    }
    return {
        tokens,
        fg,
        bg,
        themeName,
        rootStyle,
        grammarState
    };
}
function mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {
    return themes.map((t, idx)=>{
        const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || "inherit";
        const cssVar = "".concat(cssVariablePrefix + t.color).concat(property === "bg" ? "-bg" : "", ":").concat(value);
        if (idx === 0 && defaultColor) {
            if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {
                const lightIndex = themes.findIndex((t2)=>t2.color === "light");
                const darkIndex = themes.findIndex((t2)=>t2.color === "dark");
                if (lightIndex === -1 || darkIndex === -1) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
                const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || "inherit";
                const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || "inherit";
                return "light-dark(".concat(lightValue, ", ").concat(darkValue, ");").concat(cssVar);
            }
            return value;
        }
        if (colorsRendering === "css-vars") {
            return cssVar;
        }
        return null;
    }).filter((i)=>!!i).join(";");
}
function codeToHast(internal, code, options) {
    let transformerContext = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        meta: {},
        options,
        codeToHast: (_code, _options)=>codeToHast(internal, _code, _options),
        codeToTokens: (_code, _options)=>codeToTokens(internal, _code, _options)
    };
    var _transformer_preprocess, _transformer_tokens;
    let input = code;
    for (const transformer of getTransformers(options))input = ((_transformer_preprocess = transformer.preprocess) === null || _transformer_preprocess === void 0 ? void 0 : _transformer_preprocess.call(transformerContext, input, options)) || input;
    let { tokens, fg, bg, themeName, rootStyle, grammarState } = codeToTokens(internal, input, options);
    const { mergeWhitespaces = true, mergeSameStyleTokens = false } = options;
    if (mergeWhitespaces === true) tokens = mergeWhitespaceTokens(tokens);
    else if (mergeWhitespaces === "never") tokens = splitWhitespaceTokens(tokens);
    if (mergeSameStyleTokens) {
        tokens = mergeAdjacentStyledTokens(tokens);
    }
    const contextSource = {
        ...transformerContext,
        get source () {
            return input;
        }
    };
    for (const transformer of getTransformers(options))tokens = ((_transformer_tokens = transformer.tokens) === null || _transformer_tokens === void 0 ? void 0 : _transformer_tokens.call(contextSource, tokens)) || tokens;
    return tokensToHast(tokens, {
        ...options,
        fg,
        bg,
        themeName,
        rootStyle
    }, contextSource, grammarState);
}
function tokensToHast(tokens, options, transformerContext) {
    let grammarState = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : getLastGrammarStateFromMap(tokens);
    var _transformer_root;
    const transformers = getTransformers(options);
    const lines = [];
    const root = {
        type: "root",
        children: []
    };
    const { structure = "classic", tabindex = "0" } = options;
    let preNode = {
        type: "element",
        tagName: "pre",
        properties: {
            class: "shiki ".concat(options.themeName || ""),
            style: options.rootStyle || "background-color:".concat(options.bg, ";color:").concat(options.fg),
            ...tabindex !== false && tabindex != null ? {
                tabindex: tabindex.toString()
            } : {},
            ...Object.fromEntries(Array.from(Object.entries(options.meta || {})).filter((param)=>{
                let [key] = param;
                return !key.startsWith("_");
            }))
        },
        children: []
    };
    let codeNode = {
        type: "element",
        tagName: "code",
        properties: {},
        children: lines
    };
    const lineNodes = [];
    const context = {
        ...transformerContext,
        structure,
        addClassToHast,
        get source () {
            return transformerContext.source;
        },
        get tokens () {
            return tokens;
        },
        get options () {
            return options;
        },
        get root () {
            return root;
        },
        get pre () {
            return preNode;
        },
        get code () {
            return codeNode;
        },
        get lines () {
            return lineNodes;
        }
    };
    tokens.forEach((line, idx)=>{
        if (idx) {
            if (structure === "inline") root.children.push({
                type: "element",
                tagName: "br",
                properties: {},
                children: []
            });
            else if (structure === "classic") lines.push({
                type: "text",
                value: "\n"
            });
        }
        let lineNode = {
            type: "element",
            tagName: "span",
            properties: {
                class: "line"
            },
            children: []
        };
        let col = 0;
        for (const token of line){
            var _transformer_span;
            let tokenNode = {
                type: "element",
                tagName: "span",
                properties: {
                    ...token.htmlAttrs
                },
                children: [
                    {
                        type: "text",
                        value: token.content
                    }
                ]
            };
            const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
            if (style) tokenNode.properties.style = style;
            for (const transformer of transformers)tokenNode = (transformer === null || transformer === void 0 ? void 0 : (_transformer_span = transformer.span) === null || _transformer_span === void 0 ? void 0 : _transformer_span.call(context, tokenNode, idx + 1, col, lineNode, token)) || tokenNode;
            if (structure === "inline") root.children.push(tokenNode);
            else if (structure === "classic") lineNode.children.push(tokenNode);
            col += token.content.length;
        }
        if (structure === "classic") {
            var _transformer_line;
            for (const transformer of transformers)lineNode = (transformer === null || transformer === void 0 ? void 0 : (_transformer_line = transformer.line) === null || _transformer_line === void 0 ? void 0 : _transformer_line.call(context, lineNode, idx + 1)) || lineNode;
            lineNodes.push(lineNode);
            lines.push(lineNode);
        }
    });
    if (structure === "classic") {
        var _transformer_code, _transformer_pre;
        for (const transformer of transformers)codeNode = (transformer === null || transformer === void 0 ? void 0 : (_transformer_code = transformer.code) === null || _transformer_code === void 0 ? void 0 : _transformer_code.call(context, codeNode)) || codeNode;
        preNode.children.push(codeNode);
        for (const transformer of transformers)preNode = (transformer === null || transformer === void 0 ? void 0 : (_transformer_pre = transformer.pre) === null || _transformer_pre === void 0 ? void 0 : _transformer_pre.call(context, preNode)) || preNode;
        root.children.push(preNode);
    }
    let result = root;
    for (const transformer of transformers)result = (transformer === null || transformer === void 0 ? void 0 : (_transformer_root = transformer.root) === null || _transformer_root === void 0 ? void 0 : _transformer_root.call(context, result)) || result;
    if (grammarState) setLastGrammarStateToMap(result, grammarState);
    return result;
}
function mergeWhitespaceTokens(tokens) {
    return tokens.map((line)=>{
        const newLine = [];
        let carryOnContent = "";
        let firstOffset = 0;
        line.forEach((token, idx)=>{
            const isDecorated = token.fontStyle && (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Underline || token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Strikethrough);
            const couldMerge = !isDecorated;
            if (couldMerge && token.content.match(/^\s+$/) && line[idx + 1]) {
                if (!firstOffset) firstOffset = token.offset;
                carryOnContent += token.content;
            } else {
                if (carryOnContent) {
                    if (couldMerge) {
                        newLine.push({
                            ...token,
                            offset: firstOffset,
                            content: carryOnContent + token.content
                        });
                    } else {
                        newLine.push({
                            content: carryOnContent,
                            offset: firstOffset
                        }, token);
                    }
                    firstOffset = 0;
                    carryOnContent = "";
                } else {
                    newLine.push(token);
                }
            }
        });
        return newLine;
    });
}
function splitWhitespaceTokens(tokens) {
    return tokens.map((line)=>{
        return line.flatMap((token)=>{
            if (token.content.match(/^\s+$/)) return token;
            const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
            if (!match) return token;
            const [, leading, content, trailing] = match;
            if (!leading && !trailing) return token;
            const expanded = [
                {
                    ...token,
                    offset: token.offset + leading.length,
                    content
                }
            ];
            if (leading) {
                expanded.unshift({
                    content: leading,
                    offset: token.offset
                });
            }
            if (trailing) {
                expanded.push({
                    content: trailing,
                    offset: token.offset + leading.length + content.length
                });
            }
            return expanded;
        });
    });
}
function mergeAdjacentStyledTokens(tokens) {
    return tokens.map((line)=>{
        const newLine = [];
        for (const token of line){
            if (newLine.length === 0) {
                newLine.push({
                    ...token
                });
                continue;
            }
            const prevToken = newLine[newLine.length - 1];
            const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));
            const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
            const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Underline || prevToken.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Strikethrough);
            const isDecorated = token.fontStyle && (token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Underline || token.fontStyle & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FontStyle"].Strikethrough);
            if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {
                prevToken.content += token.content;
            } else {
                newLine.push({
                    ...token
                });
            }
        }
        return newLine;
    });
}
const hastToHtml = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hast$2d$util$2d$to$2d$html$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHtml"];
function codeToHtml(internal, code, options) {
    var _transformer_postprocess;
    const context = {
        meta: {},
        options,
        codeToHast: (_code, _options)=>codeToHast(internal, _code, _options),
        codeToTokens: (_code, _options)=>codeToTokens(internal, _code, _options)
    };
    let result = hastToHtml(codeToHast(internal, code, options, context));
    for (const transformer of getTransformers(options))result = ((_transformer_postprocess = transformer.postprocess) === null || _transformer_postprocess === void 0 ? void 0 : _transformer_postprocess.call(context, result, options)) || result;
    return result;
}
const VSCODE_FALLBACK_EDITOR_FG = {
    light: "#333333",
    dark: "#bbbbbb"
};
const VSCODE_FALLBACK_EDITOR_BG = {
    light: "#fffffe",
    dark: "#1e1e1e"
};
const RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
    var _theme, _theme1;
    if (rawTheme === null || rawTheme === void 0 ? void 0 : rawTheme[RESOLVED_KEY]) return rawTheme;
    const theme = {
        ...rawTheme
    };
    if (theme.tokenColors && !theme.settings) {
        theme.settings = theme.tokenColors;
        delete theme.tokenColors;
    }
    (_theme = theme).type || (_theme.type = "dark");
    theme.colorReplacements = {
        ...theme.colorReplacements
    };
    (_theme1 = theme).settings || (_theme1.settings = []);
    let { bg, fg } = theme;
    if (!bg || !fg) {
        var _globalSetting_settings, _globalSetting_settings1, _theme_colors, _theme_colors1;
        const globalSetting = theme.settings ? theme.settings.find((s)=>!s.name && !s.scope) : void 0;
        if (globalSetting === null || globalSetting === void 0 ? void 0 : (_globalSetting_settings = globalSetting.settings) === null || _globalSetting_settings === void 0 ? void 0 : _globalSetting_settings.foreground) fg = globalSetting.settings.foreground;
        if (globalSetting === null || globalSetting === void 0 ? void 0 : (_globalSetting_settings1 = globalSetting.settings) === null || _globalSetting_settings1 === void 0 ? void 0 : _globalSetting_settings1.background) bg = globalSetting.settings.background;
        if (!fg && (theme === null || theme === void 0 ? void 0 : (_theme_colors = theme.colors) === null || _theme_colors === void 0 ? void 0 : _theme_colors["editor.foreground"])) fg = theme.colors["editor.foreground"];
        if (!bg && (theme === null || theme === void 0 ? void 0 : (_theme_colors1 = theme.colors) === null || _theme_colors1 === void 0 ? void 0 : _theme_colors1["editor.background"])) bg = theme.colors["editor.background"];
        if (!fg) fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
        if (!bg) bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
        theme.fg = fg;
        theme.bg = bg;
    }
    if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
        theme.settings.unshift({
            settings: {
                foreground: theme.fg,
                background: theme.bg
            }
        });
    }
    let replacementCount = 0;
    const replacementMap = /* @__PURE__ */ new Map();
    function getReplacementColor(value) {
        var _theme_colorReplacements;
        if (replacementMap.has(value)) return replacementMap.get(value);
        replacementCount += 1;
        const hex = "#".concat(replacementCount.toString(16).padStart(8, "0").toLowerCase());
        if ((_theme_colorReplacements = theme.colorReplacements) === null || _theme_colorReplacements === void 0 ? void 0 : _theme_colorReplacements["#".concat(hex)]) return getReplacementColor(value);
        replacementMap.set(value, hex);
        return hex;
    }
    theme.settings = theme.settings.map((setting)=>{
        var _setting_settings, _setting_settings1;
        const replaceFg = ((_setting_settings = setting.settings) === null || _setting_settings === void 0 ? void 0 : _setting_settings.foreground) && !setting.settings.foreground.startsWith("#");
        const replaceBg = ((_setting_settings1 = setting.settings) === null || _setting_settings1 === void 0 ? void 0 : _setting_settings1.background) && !setting.settings.background.startsWith("#");
        if (!replaceFg && !replaceBg) return setting;
        const clone = {
            ...setting,
            settings: {
                ...setting.settings
            }
        };
        if (replaceFg) {
            const replacement = getReplacementColor(setting.settings.foreground);
            theme.colorReplacements[replacement] = setting.settings.foreground;
            clone.settings.foreground = replacement;
        }
        if (replaceBg) {
            const replacement = getReplacementColor(setting.settings.background);
            theme.colorReplacements[replacement] = setting.settings.background;
            clone.settings.background = replacement;
        }
        return clone;
    });
    for (const key of Object.keys(theme.colors || {})){
        if (key === "editor.foreground" || key === "editor.background" || key.startsWith("terminal.ansi")) {
            var _theme_colors_key;
            if (!((_theme_colors_key = theme.colors[key]) === null || _theme_colors_key === void 0 ? void 0 : _theme_colors_key.startsWith("#"))) {
                const replacement = getReplacementColor(theme.colors[key]);
                theme.colorReplacements[replacement] = theme.colors[key];
                theme.colors[key] = replacement;
            }
        }
    }
    Object.defineProperty(theme, RESOLVED_KEY, {
        enumerable: false,
        writable: false,
        value: true
    });
    return theme;
}
async function resolveLangs(langs) {
    return Array.from(new Set((await Promise.all(langs.filter((l)=>!isSpecialLang(l)).map(async (lang)=>await normalizeGetter(lang).then((r)=>Array.isArray(r) ? r : [
                r
            ])))).flat()));
}
async function resolveThemes(themes) {
    const resolved = await Promise.all(themes.map(async (theme)=>isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))));
    return resolved.filter((i)=>!!i);
}
let _emitDeprecation = 3;
let _emitError = false;
function enableDeprecationWarnings() {
    let emitDeprecation = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, emitError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    _emitDeprecation = emitDeprecation;
    _emitError = emitError;
}
function warnDeprecated(message) {
    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (!_emitDeprecation) return;
    if (typeof _emitDeprecation === "number" && version > _emitDeprecation) return;
    if (_emitError) {
        throw new Error("[SHIKI DEPRECATE]: ".concat(message));
    } else {
        console.trace("[SHIKI DEPRECATE]: ".concat(message));
    }
}
class ShikiError extends Error {
    constructor(message){
        super(message);
        this.name = "ShikiError";
    }
}
class Registry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Registry"] {
    getTheme(theme) {
        if (typeof theme === "string") return this._resolvedThemes.get(theme);
        else return this.loadTheme(theme);
    }
    loadTheme(theme) {
        const _theme = normalizeTheme(theme);
        if (_theme.name) {
            this._resolvedThemes.set(_theme.name, _theme);
            this._loadedThemesCache = null;
        }
        return _theme;
    }
    getLoadedThemes() {
        if (!this._loadedThemesCache) this._loadedThemesCache = [
            ...this._resolvedThemes.keys()
        ];
        return this._loadedThemesCache;
    }
    // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
    // is expensive. Themes can switch often especially for dual-theme support.
    //
    // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
    // we omit here so it's easier to cache the themes.
    setTheme(theme) {
        let textmateTheme = this._textmateThemeCache.get(theme);
        if (!textmateTheme) {
            textmateTheme = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$vscode$2d$textmate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Theme"].createFromRawTheme(theme);
            this._textmateThemeCache.set(theme, textmateTheme);
        }
        this._syncRegistry.setTheme(textmateTheme);
    }
    getGrammar(name) {
        if (this._alias[name]) {
            const resolved = /* @__PURE__ */ new Set([
                name
            ]);
            while(this._alias[name]){
                name = this._alias[name];
                if (resolved.has(name)) throw new ShikiError("Circular alias `".concat(Array.from(resolved).join(" -> "), " -> ").concat(name, "`"));
                resolved.add(name);
            }
        }
        return this._resolvedGrammars.get(name);
    }
    loadLanguage(lang) {
        if (this.getGrammar(lang.name)) return;
        const embeddedLazilyBy = new Set([
            ...this._langMap.values()
        ].filter((i)=>{
            var _i_embeddedLangsLazy;
            return (_i_embeddedLangsLazy = i.embeddedLangsLazy) === null || _i_embeddedLangsLazy === void 0 ? void 0 : _i_embeddedLangsLazy.includes(lang.name);
        }));
        this._resolver.addLanguage(lang);
        const grammarConfig = {
            balancedBracketSelectors: lang.balancedBracketSelectors || [
                "*"
            ],
            unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
        };
        this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
        const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
        g.name = lang.name;
        this._resolvedGrammars.set(lang.name, g);
        if (lang.aliases) {
            lang.aliases.forEach((alias)=>{
                this._alias[alias] = lang.name;
            });
        }
        this._loadedLanguagesCache = null;
        if (embeddedLazilyBy.size) {
            for (const e of embeddedLazilyBy){
                var _this__syncRegistry__injectionGrammars, _this__syncRegistry, _this__syncRegistry__grammars, _this__syncRegistry1;
                this._resolvedGrammars.delete(e.name);
                this._loadedLanguagesCache = null;
                (_this__syncRegistry = this._syncRegistry) === null || _this__syncRegistry === void 0 ? void 0 : (_this__syncRegistry__injectionGrammars = _this__syncRegistry._injectionGrammars) === null || _this__syncRegistry__injectionGrammars === void 0 ? void 0 : _this__syncRegistry__injectionGrammars.delete(e.scopeName);
                (_this__syncRegistry1 = this._syncRegistry) === null || _this__syncRegistry1 === void 0 ? void 0 : (_this__syncRegistry__grammars = _this__syncRegistry1._grammars) === null || _this__syncRegistry__grammars === void 0 ? void 0 : _this__syncRegistry__grammars.delete(e.scopeName);
                this.loadLanguage(this._langMap.get(e.name));
            }
        }
    }
    dispose() {
        super.dispose();
        this._resolvedThemes.clear();
        this._resolvedGrammars.clear();
        this._langMap.clear();
        this._langGraph.clear();
        this._loadedThemesCache = null;
    }
    loadLanguages(langs) {
        for (const lang of langs)this.resolveEmbeddedLanguages(lang);
        const langsGraphArray = Array.from(this._langGraph.entries());
        const missingLangs = langsGraphArray.filter((param)=>{
            let [_, lang] = param;
            return !lang;
        });
        if (missingLangs.length) {
            const dependents = langsGraphArray.filter((param)=>{
                let [_, lang] = param;
                var _lang_embeddedLangs;
                return lang && ((_lang_embeddedLangs = lang.embeddedLangs) === null || _lang_embeddedLangs === void 0 ? void 0 : _lang_embeddedLangs.some((l)=>missingLangs.map((param)=>{
                        let [name] = param;
                        return name;
                    }).includes(l)));
            }).filter((lang)=>!missingLangs.includes(lang));
            throw new ShikiError("Missing languages ".concat(missingLangs.map((param)=>{
                let [name] = param;
                return "`".concat(name, "`");
            }).join(", "), ", required by ").concat(dependents.map((param)=>{
                let [name] = param;
                return "`".concat(name, "`");
            }).join(", ")));
        }
        for (const [_, lang] of langsGraphArray)this._resolver.addLanguage(lang);
        for (const [_, lang] of langsGraphArray)this.loadLanguage(lang);
    }
    getLoadedLanguages() {
        if (!this._loadedLanguagesCache) {
            this._loadedLanguagesCache = [
                .../* @__PURE__ */ new Set([
                    ...this._resolvedGrammars.keys(),
                    ...Object.keys(this._alias)
                ])
            ];
        }
        return this._loadedLanguagesCache;
    }
    resolveEmbeddedLanguages(lang) {
        this._langMap.set(lang.name, lang);
        this._langGraph.set(lang.name, lang);
        if (lang.embeddedLangs) {
            for (const embeddedLang of lang.embeddedLangs)this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
        }
    }
    constructor(_resolver, _themes, _langs, _alias = {}){
        super(_resolver), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_resolvedThemes", /* @__PURE__ */ new Map()), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_resolvedGrammars", /* @__PURE__ */ new Map()), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_langMap", /* @__PURE__ */ new Map()), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_langGraph", /* @__PURE__ */ new Map()), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_textmateThemeCache", /* @__PURE__ */ new WeakMap()), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_loadedThemesCache", null), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_loadedLanguagesCache", null);
        this._resolver = _resolver;
        this._themes = _themes;
        this._langs = _langs;
        this._alias = _alias;
        this._themes.map((t)=>this.loadTheme(t));
        this.loadLanguages(this._langs);
    }
}
class Resolver {
    get onigLib() {
        return this._onigLib;
    }
    getLangRegistration(langIdOrAlias) {
        return this._langs.get(langIdOrAlias);
    }
    loadGrammar(scopeName) {
        return this._scopeToLang.get(scopeName);
    }
    addLanguage(l) {
        this._langs.set(l.name, l);
        if (l.aliases) {
            l.aliases.forEach((a)=>{
                this._langs.set(a, l);
            });
        }
        this._scopeToLang.set(l.scopeName, l);
        if (l.injectTo) {
            l.injectTo.forEach((i)=>{
                if (!this._injections.get(i)) this._injections.set(i, []);
                this._injections.get(i).push(l.scopeName);
            });
        }
    }
    getInjections(scopeName) {
        const scopeParts = scopeName.split(".");
        let injections = [];
        for(let i = 1; i <= scopeParts.length; i++){
            const subScopeName = scopeParts.slice(0, i).join(".");
            injections = [
                ...injections,
                ...this._injections.get(subScopeName) || []
            ];
        }
        return injections;
    }
    constructor(engine, langs){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_langs", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_scopeToLang", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_injections", /* @__PURE__ */ new Map());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_onigLib", void 0);
        this._onigLib = {
            createOnigScanner: (patterns)=>engine.createScanner(patterns),
            createOnigString: (s)=>engine.createString(s)
        };
        langs.forEach((i)=>this.addLanguage(i));
    }
}
let instancesCount = 0;
function createShikiInternalSync(options) {
    instancesCount += 1;
    if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0) console.warn("[Shiki] ".concat(instancesCount, " instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call `highlighter.dispose()` to release unused instances."));
    let isDisposed = false;
    if (!options.engine) throw new ShikiError("`engine` option is required for synchronous mode");
    const langs = (options.langs || []).flat(1);
    const themes = (options.themes || []).flat(1).map(normalizeTheme);
    const resolver = new Resolver(options.engine, langs);
    const _registry = new Registry(resolver, themes, langs, options.langAlias);
    let _lastTheme;
    function getLanguage(name) {
        ensureNotDisposed();
        const _lang = _registry.getGrammar(typeof name === "string" ? name : name.name);
        if (!_lang) throw new ShikiError("Language `".concat(name, "` not found, you may need to load it first"));
        return _lang;
    }
    function getTheme(name) {
        if (name === "none") return {
            bg: "",
            fg: "",
            name: "none",
            settings: [],
            type: "dark"
        };
        ensureNotDisposed();
        const _theme = _registry.getTheme(name);
        if (!_theme) throw new ShikiError("Theme `".concat(name, "` not found, you may need to load it first"));
        return _theme;
    }
    function setTheme(name) {
        ensureNotDisposed();
        const theme = getTheme(name);
        if (_lastTheme !== name) {
            _registry.setTheme(theme);
            _lastTheme = name;
        }
        const colorMap = _registry.getColorMap();
        return {
            theme,
            colorMap
        };
    }
    function getLoadedThemes() {
        ensureNotDisposed();
        return _registry.getLoadedThemes();
    }
    function getLoadedLanguages() {
        ensureNotDisposed();
        return _registry.getLoadedLanguages();
    }
    function loadLanguageSync() {
        for(var _len = arguments.length, langs2 = new Array(_len), _key = 0; _key < _len; _key++){
            langs2[_key] = arguments[_key];
        }
        ensureNotDisposed();
        _registry.loadLanguages(langs2.flat(1));
    }
    async function loadLanguage() {
        for(var _len = arguments.length, langs2 = new Array(_len), _key = 0; _key < _len; _key++){
            langs2[_key] = arguments[_key];
        }
        return loadLanguageSync(await resolveLangs(langs2));
    }
    function loadThemeSync() {
        for(var _len = arguments.length, themes2 = new Array(_len), _key = 0; _key < _len; _key++){
            themes2[_key] = arguments[_key];
        }
        ensureNotDisposed();
        for (const theme of themes2.flat(1)){
            _registry.loadTheme(theme);
        }
    }
    async function loadTheme() {
        for(var _len = arguments.length, themes2 = new Array(_len), _key = 0; _key < _len; _key++){
            themes2[_key] = arguments[_key];
        }
        ensureNotDisposed();
        return loadThemeSync(await resolveThemes(themes2));
    }
    function ensureNotDisposed() {
        if (isDisposed) throw new ShikiError("Shiki instance has been disposed");
    }
    function dispose() {
        if (isDisposed) return;
        isDisposed = true;
        _registry.dispose();
        instancesCount -= 1;
    }
    return {
        setTheme,
        getTheme,
        getLanguage,
        getLoadedThemes,
        getLoadedLanguages,
        loadLanguage,
        loadLanguageSync,
        loadTheme,
        loadThemeSync,
        dispose,
        [Symbol.dispose]: dispose
    };
}
async function createShikiInternal(options) {
    if (!options.engine) {
        warnDeprecated("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
    }
    const [themes, langs, engine] = await Promise.all([
        resolveThemes(options.themes || []),
        resolveLangs(options.langs || []),
        options.engine
    ]);
    return createShikiInternalSync({
        ...options,
        themes,
        langs,
        engine
    });
}
async function createHighlighterCore(options) {
    const internal = await createShikiInternal(options);
    return {
        getLastGrammarState: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return getLastGrammarState(internal, ...args);
        },
        codeToTokensBase: (code, options2)=>codeToTokensBase(internal, code, options2),
        codeToTokensWithThemes: (code, options2)=>codeToTokensWithThemes(internal, code, options2),
        codeToTokens: (code, options2)=>codeToTokens(internal, code, options2),
        codeToHast: (code, options2)=>codeToHast(internal, code, options2),
        codeToHtml: (code, options2)=>codeToHtml(internal, code, options2),
        getBundledLanguages: ()=>({}),
        getBundledThemes: ()=>({}),
        ...internal,
        getInternalContext: ()=>internal
    };
}
function createHighlighterCoreSync(options) {
    const internal = createShikiInternalSync(options);
    return {
        getLastGrammarState: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return getLastGrammarState(internal, ...args);
        },
        codeToTokensBase: (code, options2)=>codeToTokensBase(internal, code, options2),
        codeToTokensWithThemes: (code, options2)=>codeToTokensWithThemes(internal, code, options2),
        codeToTokens: (code, options2)=>codeToTokens(internal, code, options2),
        codeToHast: (code, options2)=>codeToHast(internal, code, options2),
        codeToHtml: (code, options2)=>codeToHtml(internal, code, options2),
        getBundledLanguages: ()=>({}),
        getBundledThemes: ()=>({}),
        ...internal,
        getInternalContext: ()=>internal
    };
}
function makeSingletonHighlighterCore(createHighlighter) {
    let _shiki;
    async function getSingletonHighlighterCore2(options) {
        if (!_shiki) {
            _shiki = createHighlighter({
                ...options,
                themes: options.themes || [],
                langs: options.langs || []
            });
            return _shiki;
        } else {
            const s = await _shiki;
            await Promise.all([
                s.loadTheme(...options.themes || []),
                s.loadLanguage(...options.langs || [])
            ]);
            return s;
        }
    }
    return getSingletonHighlighterCore2;
}
const getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);
function createdBundledHighlighter(options) {
    const bundledLanguages = options.langs;
    const bundledThemes = options.themes;
    const engine = options.engine;
    async function createHighlighter(options2) {
        function resolveLang(lang) {
            if (typeof lang === "string") {
                var _options2_langAlias;
                if (isSpecialLang(lang)) return [];
                lang = ((_options2_langAlias = options2.langAlias) === null || _options2_langAlias === void 0 ? void 0 : _options2_langAlias[lang]) || lang;
                const bundle = bundledLanguages[lang];
                if (!bundle) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Language `".concat(lang, "` is not included in this bundle. You may want to load it from external source."));
                return bundle;
            }
            return lang;
        }
        function resolveTheme(theme) {
            if (isSpecialTheme(theme)) return "none";
            if (typeof theme === "string") {
                const bundle = bundledThemes[theme];
                if (!bundle) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"]("Theme `".concat(theme, "` is not included in this bundle. You may want to load it from external source."));
                return bundle;
            }
            return theme;
        }
        var _options2_themes;
        const _themes = ((_options2_themes = options2.themes) !== null && _options2_themes !== void 0 ? _options2_themes : []).map((i)=>resolveTheme(i));
        var _options2_langs;
        const langs = ((_options2_langs = options2.langs) !== null && _options2_langs !== void 0 ? _options2_langs : []).map((i)=>resolveLang(i));
        var _options2_engine;
        const core = await createHighlighterCore({
            engine: (_options2_engine = options2.engine) !== null && _options2_engine !== void 0 ? _options2_engine : engine(),
            ...options2,
            themes: _themes,
            langs
        });
        return {
            ...core,
            loadLanguage () {
                for(var _len = arguments.length, langs2 = new Array(_len), _key = 0; _key < _len; _key++){
                    langs2[_key] = arguments[_key];
                }
                return core.loadLanguage(...langs2.map(resolveLang));
            },
            loadTheme () {
                for(var _len = arguments.length, themes = new Array(_len), _key = 0; _key < _len; _key++){
                    themes[_key] = arguments[_key];
                }
                return core.loadTheme(...themes.map(resolveTheme));
            },
            getBundledLanguages () {
                return bundledLanguages;
            },
            getBundledThemes () {
                return bundledThemes;
            }
        };
    }
    return createHighlighter;
}
function makeSingletonHighlighter(createHighlighter) {
    let _shiki;
    async function getSingletonHighlighter() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!_shiki) {
            _shiki = createHighlighter({
                ...options,
                themes: options.themes || [],
                langs: options.langs || []
            });
            return _shiki;
        } else {
            const s = await _shiki;
            await Promise.all([
                s.loadTheme(...options.themes || []),
                s.loadLanguage(...options.langs || [])
            ]);
            return s;
        }
    }
    return getSingletonHighlighter;
}
function createSingletonShorthands(createHighlighter, config) {
    const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);
    async function get(code, options) {
        var _config_guessEmbeddedLanguages;
        const shiki = await getSingletonHighlighter({
            langs: [
                options.lang
            ],
            themes: "theme" in options ? [
                options.theme
            ] : Object.values(options.themes)
        });
        const langs = await (config === null || config === void 0 ? void 0 : (_config_guessEmbeddedLanguages = config.guessEmbeddedLanguages) === null || _config_guessEmbeddedLanguages === void 0 ? void 0 : _config_guessEmbeddedLanguages.call(config, code, options.lang, shiki));
        if (langs) {
            await shiki.loadLanguage(...langs);
        }
        return shiki;
    }
    return {
        getSingletonHighlighter (options) {
            return getSingletonHighlighter(options);
        },
        async codeToHtml (code, options) {
            const shiki = await get(code, options);
            return shiki.codeToHtml(code, options);
        },
        async codeToHast (code, options) {
            const shiki = await get(code, options);
            return shiki.codeToHast(code, options);
        },
        async codeToTokens (code, options) {
            const shiki = await get(code, options);
            return shiki.codeToTokens(code, options);
        },
        async codeToTokensBase (code, options) {
            const shiki = await get(code, options);
            return shiki.codeToTokensBase(code, options);
        },
        async codeToTokensWithThemes (code, options) {
            const shiki = await get(code, options);
            return shiki.codeToTokensWithThemes(code, options);
        },
        async getLastGrammarState (code, options) {
            const shiki = await getSingletonHighlighter({
                langs: [
                    options.lang
                ],
                themes: [
                    options.theme
                ]
            });
            return shiki.getLastGrammarState(code, options);
        }
    };
}
function createCssVariablesTheme() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { name = "css-variables", variablePrefix = "--shiki-", fontStyle = true } = options;
    const variable = (name2)=>{
        var _options_variableDefaults;
        if ((_options_variableDefaults = options.variableDefaults) === null || _options_variableDefaults === void 0 ? void 0 : _options_variableDefaults[name2]) return "var(".concat(variablePrefix).concat(name2, ", ").concat(options.variableDefaults[name2], ")");
        return "var(".concat(variablePrefix).concat(name2, ")");
    };
    const theme = {
        name,
        type: "dark",
        colors: {
            "editor.foreground": variable("foreground"),
            "editor.background": variable("background"),
            "terminal.ansiBlack": variable("ansi-black"),
            "terminal.ansiRed": variable("ansi-red"),
            "terminal.ansiGreen": variable("ansi-green"),
            "terminal.ansiYellow": variable("ansi-yellow"),
            "terminal.ansiBlue": variable("ansi-blue"),
            "terminal.ansiMagenta": variable("ansi-magenta"),
            "terminal.ansiCyan": variable("ansi-cyan"),
            "terminal.ansiWhite": variable("ansi-white"),
            "terminal.ansiBrightBlack": variable("ansi-bright-black"),
            "terminal.ansiBrightRed": variable("ansi-bright-red"),
            "terminal.ansiBrightGreen": variable("ansi-bright-green"),
            "terminal.ansiBrightYellow": variable("ansi-bright-yellow"),
            "terminal.ansiBrightBlue": variable("ansi-bright-blue"),
            "terminal.ansiBrightMagenta": variable("ansi-bright-magenta"),
            "terminal.ansiBrightCyan": variable("ansi-bright-cyan"),
            "terminal.ansiBrightWhite": variable("ansi-bright-white")
        },
        tokenColors: [
            {
                scope: [
                    "keyword.operator.accessor",
                    "meta.group.braces.round.function.arguments",
                    "meta.template.expression",
                    "markup.fenced_code meta.embedded.block"
                ],
                settings: {
                    foreground: variable("foreground")
                }
            },
            {
                scope: "emphasis",
                settings: {
                    fontStyle: "italic"
                }
            },
            {
                scope: [
                    "strong",
                    "markup.heading.markdown",
                    "markup.bold.markdown"
                ],
                settings: {
                    fontStyle: "bold"
                }
            },
            {
                scope: [
                    "markup.italic.markdown"
                ],
                settings: {
                    fontStyle: "italic"
                }
            },
            {
                scope: "meta.link.inline.markdown",
                settings: {
                    fontStyle: "underline",
                    foreground: variable("token-link")
                }
            },
            {
                scope: [
                    "string",
                    "markup.fenced_code",
                    "markup.inline"
                ],
                settings: {
                    foreground: variable("token-string")
                }
            },
            {
                scope: [
                    "comment",
                    "string.quoted.docstring.multi"
                ],
                settings: {
                    foreground: variable("token-comment")
                }
            },
            {
                scope: [
                    "constant.numeric",
                    "constant.language",
                    "constant.other.placeholder",
                    "constant.character.format.placeholder",
                    "variable.language.this",
                    "variable.other.object",
                    "variable.other.class",
                    "variable.other.constant",
                    "meta.property-name",
                    "meta.property-value",
                    "support"
                ],
                settings: {
                    foreground: variable("token-constant")
                }
            },
            {
                scope: [
                    "keyword",
                    "storage.modifier",
                    "storage.type",
                    "storage.control.clojure",
                    "entity.name.function.clojure",
                    "entity.name.tag.yaml",
                    "support.function.node",
                    "support.type.property-name.json",
                    "punctuation.separator.key-value",
                    "punctuation.definition.template-expression"
                ],
                settings: {
                    foreground: variable("token-keyword")
                }
            },
            {
                scope: "variable.parameter.function",
                settings: {
                    foreground: variable("token-parameter")
                }
            },
            {
                scope: [
                    "support.function",
                    "entity.name.type",
                    "entity.other.inherited-class",
                    "meta.function-call",
                    "meta.instance.constructor",
                    "entity.other.attribute-name",
                    "entity.name.function",
                    "constant.keyword.clojure"
                ],
                settings: {
                    foreground: variable("token-function")
                }
            },
            {
                scope: [
                    "entity.name.tag",
                    "string.quoted",
                    "string.regexp",
                    "string.interpolated",
                    "string.template",
                    "string.unquoted.plain.out.yaml",
                    "keyword.other.template"
                ],
                settings: {
                    foreground: variable("token-string-expression")
                }
            },
            {
                scope: [
                    "punctuation.definition.arguments",
                    "punctuation.definition.dict",
                    "punctuation.separator",
                    "meta.function-call.arguments"
                ],
                settings: {
                    foreground: variable("token-punctuation")
                }
            },
            {
                // [Custom] Markdown links
                scope: [
                    "markup.underline.link",
                    "punctuation.definition.metadata.markdown"
                ],
                settings: {
                    foreground: variable("token-link")
                }
            },
            {
                // [Custom] Markdown list
                scope: [
                    "beginning.punctuation.definition.list.markdown"
                ],
                settings: {
                    foreground: variable("token-string")
                }
            },
            {
                // [Custom] Markdown punctuation definition brackets
                scope: [
                    "punctuation.definition.string.begin.markdown",
                    "punctuation.definition.string.end.markdown",
                    "string.other.link.title.markdown",
                    "string.other.link.description.markdown"
                ],
                settings: {
                    foreground: variable("token-keyword")
                }
            },
            {
                // [Custom] Diff
                scope: [
                    "markup.inserted",
                    "meta.diff.header.to-file",
                    "punctuation.definition.inserted"
                ],
                settings: {
                    foreground: variable("token-inserted")
                }
            },
            {
                scope: [
                    "markup.deleted",
                    "meta.diff.header.from-file",
                    "punctuation.definition.deleted"
                ],
                settings: {
                    foreground: variable("token-deleted")
                }
            },
            {
                scope: [
                    "markup.changed",
                    "punctuation.definition.changed"
                ],
                settings: {
                    foreground: variable("token-changed")
                }
            }
        ]
    };
    if (!fontStyle) {
        var _theme_tokenColors;
        theme.tokenColors = (_theme_tokenColors = theme.tokenColors) === null || _theme_tokenColors === void 0 ? void 0 : _theme_tokenColors.map((tokenColor)=>{
            var _tokenColor_settings;
            if ((_tokenColor_settings = tokenColor.settings) === null || _tokenColor_settings === void 0 ? void 0 : _tokenColor_settings.fontStyle) delete tokenColor.settings.fontStyle;
            return tokenColor;
        });
    }
    return theme;
}
;
}),
"[project]/node_modules/shiki/dist/langs.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bundledLanguages",
    ()=>bundledLanguages,
    "bundledLanguagesAlias",
    ()=>bundledLanguagesAlias,
    "bundledLanguagesBase",
    ()=>bundledLanguagesBase,
    "bundledLanguagesInfo",
    ()=>bundledLanguagesInfo
]);
const bundledLanguagesInfo = [
    {
        "id": "abap",
        "name": "ABAP",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/abap.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "actionscript-3",
        "name": "ActionScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/actionscript-3.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ada",
        "name": "Ada",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ada.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "angular-html",
        "name": "Angular HTML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/angular-html.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "angular-ts",
        "name": "Angular TypeScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/angular-ts.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "apache",
        "name": "Apache Conf",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/apache.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "apex",
        "name": "Apex",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/apex.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "apl",
        "name": "APL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/apl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "applescript",
        "name": "AppleScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/applescript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ara",
        "name": "Ara",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ara.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "asciidoc",
        "name": "AsciiDoc",
        "aliases": [
            "adoc"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/asciidoc.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "asm",
        "name": "Assembly",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/asm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "astro",
        "name": "Astro",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/astro.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "awk",
        "name": "AWK",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/awk.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ballerina",
        "name": "Ballerina",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ballerina.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "bat",
        "name": "Batch File",
        "aliases": [
            "batch"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/bat.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "beancount",
        "name": "Beancount",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/beancount.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "berry",
        "name": "Berry",
        "aliases": [
            "be"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/berry.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "bibtex",
        "name": "BibTeX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/bibtex.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "bicep",
        "name": "Bicep",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/bicep.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "blade",
        "name": "Blade",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/blade.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "bsl",
        "name": "1C (Enterprise)",
        "aliases": [
            "1c"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/bsl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "c",
        "name": "C",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/c.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cadence",
        "name": "Cadence",
        "aliases": [
            "cdc"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cadence.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cairo",
        "name": "Cairo",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cairo.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "clarity",
        "name": "Clarity",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/clarity.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "clojure",
        "name": "Clojure",
        "aliases": [
            "clj"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/clojure.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cmake",
        "name": "CMake",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cmake.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cobol",
        "name": "COBOL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cobol.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "codeowners",
        "name": "CODEOWNERS",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/codeowners.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "codeql",
        "name": "CodeQL",
        "aliases": [
            "ql"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/codeql.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "coffee",
        "name": "CoffeeScript",
        "aliases": [
            "coffeescript"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/coffee.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "common-lisp",
        "name": "Common Lisp",
        "aliases": [
            "lisp"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/common-lisp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "coq",
        "name": "Coq",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/coq.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cpp",
        "name": "C++",
        "aliases": [
            "c++"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cpp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "crystal",
        "name": "Crystal",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/crystal.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "csharp",
        "name": "C#",
        "aliases": [
            "c#",
            "cs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/csharp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "css",
        "name": "CSS",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/css.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "csv",
        "name": "CSV",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/csv.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cue",
        "name": "CUE",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cue.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "cypher",
        "name": "Cypher",
        "aliases": [
            "cql"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/cypher.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "d",
        "name": "D",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/d.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dart",
        "name": "Dart",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/dart.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dax",
        "name": "DAX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/dax.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "desktop",
        "name": "Desktop",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/desktop.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "diff",
        "name": "Diff",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/diff.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "docker",
        "name": "Dockerfile",
        "aliases": [
            "dockerfile"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/docker.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dotenv",
        "name": "dotEnv",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/dotenv.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dream-maker",
        "name": "Dream Maker",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/dream-maker.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "edge",
        "name": "Edge",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/edge.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "elixir",
        "name": "Elixir",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/elixir.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "elm",
        "name": "Elm",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/elm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "emacs-lisp",
        "name": "Emacs Lisp",
        "aliases": [
            "elisp"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/emacs-lisp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "erb",
        "name": "ERB",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/erb.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "erlang",
        "name": "Erlang",
        "aliases": [
            "erl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/erlang.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fennel",
        "name": "Fennel",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fennel.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fish",
        "name": "Fish",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fish.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fluent",
        "name": "Fluent",
        "aliases": [
            "ftl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fluent.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fortran-fixed-form",
        "name": "Fortran (Fixed Form)",
        "aliases": [
            "f",
            "for",
            "f77"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fortran-fixed-form.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fortran-free-form",
        "name": "Fortran (Free Form)",
        "aliases": [
            "f90",
            "f95",
            "f03",
            "f08",
            "f18"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fortran-free-form.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "fsharp",
        "name": "F#",
        "aliases": [
            "f#",
            "fs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/fsharp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gdresource",
        "name": "GDResource",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gdresource.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gdscript",
        "name": "GDScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gdscript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gdshader",
        "name": "GDShader",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gdshader.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "genie",
        "name": "Genie",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/genie.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gherkin",
        "name": "Gherkin",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gherkin.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "git-commit",
        "name": "Git Commit Message",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/git-commit.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "git-rebase",
        "name": "Git Rebase Message",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/git-rebase.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gleam",
        "name": "Gleam",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gleam.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "glimmer-js",
        "name": "Glimmer JS",
        "aliases": [
            "gjs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/glimmer-js.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "glimmer-ts",
        "name": "Glimmer TS",
        "aliases": [
            "gts"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/glimmer-ts.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "glsl",
        "name": "GLSL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/glsl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gnuplot",
        "name": "Gnuplot",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/gnuplot.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "go",
        "name": "Go",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/go.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "graphql",
        "name": "GraphQL",
        "aliases": [
            "gql"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/graphql.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "groovy",
        "name": "Groovy",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/groovy.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hack",
        "name": "Hack",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hack.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "haml",
        "name": "Ruby Haml",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/haml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "handlebars",
        "name": "Handlebars",
        "aliases": [
            "hbs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/handlebars.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "haskell",
        "name": "Haskell",
        "aliases": [
            "hs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/haskell.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "haxe",
        "name": "Haxe",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/haxe.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hcl",
        "name": "HashiCorp HCL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hcl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hjson",
        "name": "Hjson",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hjson.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hlsl",
        "name": "HLSL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hlsl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "html",
        "name": "HTML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/html.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "html-derivative",
        "name": "HTML (Derivative)",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/html-derivative.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "http",
        "name": "HTTP",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/http.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hxml",
        "name": "HXML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hxml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "hy",
        "name": "Hy",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/hy.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "imba",
        "name": "Imba",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/imba.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ini",
        "name": "INI",
        "aliases": [
            "properties"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ini.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "java",
        "name": "Java",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/java.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "javascript",
        "name": "JavaScript",
        "aliases": [
            "js"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/javascript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jinja",
        "name": "Jinja",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jinja.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jison",
        "name": "Jison",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jison.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "json",
        "name": "JSON",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/json.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "json5",
        "name": "JSON5",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/json5.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jsonc",
        "name": "JSON with Comments",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jsonc.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jsonl",
        "name": "JSON Lines",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jsonl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jsonnet",
        "name": "Jsonnet",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jsonnet.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jssm",
        "name": "JSSM",
        "aliases": [
            "fsl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jssm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "jsx",
        "name": "JSX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/jsx.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "julia",
        "name": "Julia",
        "aliases": [
            "jl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/julia.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "kotlin",
        "name": "Kotlin",
        "aliases": [
            "kt",
            "kts"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/kotlin.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "kusto",
        "name": "Kusto",
        "aliases": [
            "kql"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/kusto.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "latex",
        "name": "LaTeX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/latex.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "lean",
        "name": "Lean 4",
        "aliases": [
            "lean4"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/lean.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "less",
        "name": "Less",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/less.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "liquid",
        "name": "Liquid",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/liquid.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "llvm",
        "name": "LLVM IR",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/llvm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "log",
        "name": "Log file",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/log.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "logo",
        "name": "Logo",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/logo.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "lua",
        "name": "Lua",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/lua.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "luau",
        "name": "Luau",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/luau.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "make",
        "name": "Makefile",
        "aliases": [
            "makefile"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/make.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "markdown",
        "name": "Markdown",
        "aliases": [
            "md"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/markdown.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "marko",
        "name": "Marko",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/marko.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "matlab",
        "name": "MATLAB",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/matlab.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "mdc",
        "name": "MDC",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/mdc.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "mdx",
        "name": "MDX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/mdx.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "mermaid",
        "name": "Mermaid",
        "aliases": [
            "mmd"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/mermaid.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "mipsasm",
        "name": "MIPS Assembly",
        "aliases": [
            "mips"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/mipsasm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "mojo",
        "name": "Mojo",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/mojo.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "move",
        "name": "Move",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/move.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "narrat",
        "name": "Narrat Language",
        "aliases": [
            "nar"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/narrat.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nextflow",
        "name": "Nextflow",
        "aliases": [
            "nf"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/nextflow.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nginx",
        "name": "Nginx",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/nginx.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nim",
        "name": "Nim",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/nim.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nix",
        "name": "Nix",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/nix.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nushell",
        "name": "nushell",
        "aliases": [
            "nu"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/nushell.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "objective-c",
        "name": "Objective-C",
        "aliases": [
            "objc"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/objective-c.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "objective-cpp",
        "name": "Objective-C++",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/objective-cpp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ocaml",
        "name": "OCaml",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ocaml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "pascal",
        "name": "Pascal",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/pascal.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "perl",
        "name": "Perl",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/perl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "php",
        "name": "PHP",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/php.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "plsql",
        "name": "PL/SQL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/plsql.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "po",
        "name": "Gettext PO",
        "aliases": [
            "pot",
            "potx"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/po.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "polar",
        "name": "Polar",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/polar.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "postcss",
        "name": "PostCSS",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/postcss.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "powerquery",
        "name": "PowerQuery",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/powerquery.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "powershell",
        "name": "PowerShell",
        "aliases": [
            "ps",
            "ps1"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/powershell.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "prisma",
        "name": "Prisma",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/prisma.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "prolog",
        "name": "Prolog",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/prolog.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "proto",
        "name": "Protocol Buffer 3",
        "aliases": [
            "protobuf"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/proto.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "pug",
        "name": "Pug",
        "aliases": [
            "jade"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/pug.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "puppet",
        "name": "Puppet",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/puppet.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "purescript",
        "name": "PureScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/purescript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "python",
        "name": "Python",
        "aliases": [
            "py"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/python.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "qml",
        "name": "QML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/qml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "qmldir",
        "name": "QML Directory",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/qmldir.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "qss",
        "name": "Qt Style Sheets",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/qss.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "r",
        "name": "R",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/r.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "racket",
        "name": "Racket",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/racket.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "raku",
        "name": "Raku",
        "aliases": [
            "perl6"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/raku.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "razor",
        "name": "ASP.NET Razor",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/razor.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "reg",
        "name": "Windows Registry Script",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/reg.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "regexp",
        "name": "RegExp",
        "aliases": [
            "regex"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/regexp.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rel",
        "name": "Rel",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/rel.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "riscv",
        "name": "RISC-V",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/riscv.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rst",
        "name": "reStructuredText",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/rst.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ruby",
        "name": "Ruby",
        "aliases": [
            "rb"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ruby.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rust",
        "name": "Rust",
        "aliases": [
            "rs"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/rust.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "sas",
        "name": "SAS",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/sas.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "sass",
        "name": "Sass",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/sass.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "scala",
        "name": "Scala",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/scala.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "scheme",
        "name": "Scheme",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/scheme.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "scss",
        "name": "SCSS",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/scss.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "sdbl",
        "name": "1C (Query)",
        "aliases": [
            "1c-query"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/sdbl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "shaderlab",
        "name": "ShaderLab",
        "aliases": [
            "shader"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/shaderlab.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "shellscript",
        "name": "Shell",
        "aliases": [
            "bash",
            "sh",
            "shell",
            "zsh"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/shellscript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "shellsession",
        "name": "Shell Session",
        "aliases": [
            "console"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/shellsession.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "smalltalk",
        "name": "Smalltalk",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/smalltalk.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "solidity",
        "name": "Solidity",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/solidity.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "soy",
        "name": "Closure Templates",
        "aliases": [
            "closure-templates"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/soy.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "sparql",
        "name": "SPARQL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/sparql.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "splunk",
        "name": "Splunk Query Language",
        "aliases": [
            "spl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/splunk.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "sql",
        "name": "SQL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/sql.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ssh-config",
        "name": "SSH Config",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ssh-config.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "stata",
        "name": "Stata",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/stata.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "stylus",
        "name": "Stylus",
        "aliases": [
            "styl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/stylus.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "svelte",
        "name": "Svelte",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/svelte.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "swift",
        "name": "Swift",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/swift.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "system-verilog",
        "name": "SystemVerilog",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/system-verilog.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "systemd",
        "name": "Systemd Units",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/systemd.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "talonscript",
        "name": "TalonScript",
        "aliases": [
            "talon"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/talonscript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tasl",
        "name": "Tasl",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/tasl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tcl",
        "name": "Tcl",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/tcl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "templ",
        "name": "Templ",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/templ.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "terraform",
        "name": "Terraform",
        "aliases": [
            "tf",
            "tfvars"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/terraform.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tex",
        "name": "TeX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/tex.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "toml",
        "name": "TOML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/toml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ts-tags",
        "name": "TypeScript with Tags",
        "aliases": [
            "lit"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/ts-tags.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tsv",
        "name": "TSV",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/tsv.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tsx",
        "name": "TSX",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/tsx.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "turtle",
        "name": "Turtle",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/turtle.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "twig",
        "name": "Twig",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/twig.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "typescript",
        "name": "TypeScript",
        "aliases": [
            "ts"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/typescript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "typespec",
        "name": "TypeSpec",
        "aliases": [
            "tsp"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/typespec.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "typst",
        "name": "Typst",
        "aliases": [
            "typ"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/typst.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "v",
        "name": "V",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/v.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vala",
        "name": "Vala",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vala.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vb",
        "name": "Visual Basic",
        "aliases": [
            "cmd"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vb.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "verilog",
        "name": "Verilog",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/verilog.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vhdl",
        "name": "VHDL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vhdl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "viml",
        "name": "Vim Script",
        "aliases": [
            "vim",
            "vimscript"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/viml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vue",
        "name": "Vue",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vue.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vue-html",
        "name": "Vue HTML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vue-html.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vue-vine",
        "name": "Vue Vine",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vue-vine.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vyper",
        "name": "Vyper",
        "aliases": [
            "vy"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/vyper.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wasm",
        "name": "WebAssembly",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wasm.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wenyan",
        "name": "Wenyan",
        "aliases": [
            "\u6587\u8A00"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wenyan.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wgsl",
        "name": "WGSL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wgsl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wikitext",
        "name": "Wikitext",
        "aliases": [
            "mediawiki",
            "wiki"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wikitext.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wit",
        "name": "WebAssembly Interface Types",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wit.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "wolfram",
        "name": "Wolfram",
        "aliases": [
            "wl"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/wolfram.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "xml",
        "name": "XML",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/xml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "xsl",
        "name": "XSL",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/xsl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "yaml",
        "name": "YAML",
        "aliases": [
            "yml"
        ],
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/yaml.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "zenscript",
        "name": "ZenScript",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/zenscript.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "zig",
        "name": "Zig",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/langs/dist/zig.mjs [app-client] (ecmascript, async loader)")
    }
];
const bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i)=>[
        i.id,
        i.import
    ]));
const bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i)=>{
    var _i_aliases;
    return ((_i_aliases = i.aliases) === null || _i_aliases === void 0 ? void 0 : _i_aliases.map((a)=>[
            a,
            i.import
        ])) || [];
}));
const bundledLanguages = {
    ...bundledLanguagesBase,
    ...bundledLanguagesAlias
};
;
}),
"[project]/node_modules/shiki/dist/themes.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bundledThemes",
    ()=>bundledThemes,
    "bundledThemesInfo",
    ()=>bundledThemesInfo
]);
const bundledThemesInfo = [
    {
        "id": "andromeeda",
        "displayName": "Andromeeda",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/andromeeda.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "aurora-x",
        "displayName": "Aurora X",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/aurora-x.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "ayu-dark",
        "displayName": "Ayu Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/ayu-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "catppuccin-frappe",
        "displayName": "Catppuccin Frapp\xE9",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/catppuccin-frappe.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "catppuccin-latte",
        "displayName": "Catppuccin Latte",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/catppuccin-latte.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "catppuccin-macchiato",
        "displayName": "Catppuccin Macchiato",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/catppuccin-macchiato.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "catppuccin-mocha",
        "displayName": "Catppuccin Mocha",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/catppuccin-mocha.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dark-plus",
        "displayName": "Dark Plus",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/dark-plus.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dracula",
        "displayName": "Dracula Theme",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/dracula.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "dracula-soft",
        "displayName": "Dracula Theme Soft",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/dracula-soft.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "everforest-dark",
        "displayName": "Everforest Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/everforest-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "everforest-light",
        "displayName": "Everforest Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/everforest-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-dark",
        "displayName": "GitHub Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-dark-default",
        "displayName": "GitHub Dark Default",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-dark-default.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-dark-dimmed",
        "displayName": "GitHub Dark Dimmed",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-dark-dimmed.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-dark-high-contrast",
        "displayName": "GitHub Dark High Contrast",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-dark-high-contrast.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-light",
        "displayName": "GitHub Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-light-default",
        "displayName": "GitHub Light Default",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-light-default.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "github-light-high-contrast",
        "displayName": "GitHub Light High Contrast",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/github-light-high-contrast.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-dark-hard",
        "displayName": "Gruvbox Dark Hard",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-dark-hard.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-dark-medium",
        "displayName": "Gruvbox Dark Medium",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-dark-medium.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-dark-soft",
        "displayName": "Gruvbox Dark Soft",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-dark-soft.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-light-hard",
        "displayName": "Gruvbox Light Hard",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-light-hard.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-light-medium",
        "displayName": "Gruvbox Light Medium",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-light-medium.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "gruvbox-light-soft",
        "displayName": "Gruvbox Light Soft",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/gruvbox-light-soft.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "houston",
        "displayName": "Houston",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/houston.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "kanagawa-dragon",
        "displayName": "Kanagawa Dragon",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/kanagawa-dragon.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "kanagawa-lotus",
        "displayName": "Kanagawa Lotus",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/kanagawa-lotus.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "kanagawa-wave",
        "displayName": "Kanagawa Wave",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/kanagawa-wave.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "laserwave",
        "displayName": "LaserWave",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/laserwave.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "light-plus",
        "displayName": "Light Plus",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/light-plus.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "material-theme",
        "displayName": "Material Theme",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/material-theme.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "material-theme-darker",
        "displayName": "Material Theme Darker",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/material-theme-darker.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "material-theme-lighter",
        "displayName": "Material Theme Lighter",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/material-theme-lighter.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "material-theme-ocean",
        "displayName": "Material Theme Ocean",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/material-theme-ocean.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "material-theme-palenight",
        "displayName": "Material Theme Palenight",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/material-theme-palenight.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "min-dark",
        "displayName": "Min Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/min-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "min-light",
        "displayName": "Min Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/min-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "monokai",
        "displayName": "Monokai",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/monokai.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "night-owl",
        "displayName": "Night Owl",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/night-owl.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "nord",
        "displayName": "Nord",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/nord.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "one-dark-pro",
        "displayName": "One Dark Pro",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/one-dark-pro.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "one-light",
        "displayName": "One Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/one-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "plastic",
        "displayName": "Plastic",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/plastic.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "poimandres",
        "displayName": "Poimandres",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/poimandres.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "red",
        "displayName": "Red",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/red.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rose-pine",
        "displayName": "Ros\xE9 Pine",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/rose-pine.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rose-pine-dawn",
        "displayName": "Ros\xE9 Pine Dawn",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/rose-pine-dawn.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "rose-pine-moon",
        "displayName": "Ros\xE9 Pine Moon",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/rose-pine-moon.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "slack-dark",
        "displayName": "Slack Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/slack-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "slack-ochin",
        "displayName": "Slack Ochin",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/slack-ochin.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "snazzy-light",
        "displayName": "Snazzy Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/snazzy-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "solarized-dark",
        "displayName": "Solarized Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/solarized-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "solarized-light",
        "displayName": "Solarized Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/solarized-light.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "synthwave-84",
        "displayName": "Synthwave '84",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/synthwave-84.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "tokyo-night",
        "displayName": "Tokyo Night",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/tokyo-night.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vesper",
        "displayName": "Vesper",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/vesper.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vitesse-black",
        "displayName": "Vitesse Black",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/vitesse-black.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vitesse-dark",
        "displayName": "Vitesse Dark",
        "type": "dark",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/vitesse-dark.mjs [app-client] (ecmascript, async loader)")
    },
    {
        "id": "vitesse-light",
        "displayName": "Vitesse Light",
        "type": "light",
        "import": ()=>__turbopack_context__.A("[project]/node_modules/@shikijs/themes/dist/vitesse-light.mjs [app-client] (ecmascript, async loader)")
    }
];
const bundledThemes = Object.fromEntries(bundledThemesInfo.map((i)=>[
        i.id,
        i.import
    ]));
;
}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/buffer") + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}),
"[project]/node_modules/@shikijs/engine-oniguruma/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createOnigurumaEngine",
    ()=>createOnigurumaEngine,
    "getDefaultWasmLoader",
    ()=>getDefaultWasmLoader,
    "loadWasm",
    ()=>loadWasm,
    "setDefaultWasmLoader",
    ()=>setDefaultWasmLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
class ShikiError extends Error {
    constructor(message){
        super(message);
        this.name = "ShikiError";
    }
}
function getHeapMax() {
    return 2147483648;
}
function _emscripten_get_now() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
}
const alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;
async function main(init) {
    let wasmMemory;
    let buffer;
    const binding = {};
    function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        binding.HEAPU8 = new Uint8Array(buf);
        binding.HEAPU32 = new Uint32Array(buf);
    }
    function _emscripten_memcpy_big(dest, src, num) {
        binding.HEAPU8.copyWithin(dest, src, src + num);
    }
    function emscripten_realloc_buffer(size) {
        try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
        } catch (e) {}
    }
    function _emscripten_resize_heap(requestedSize) {
        const oldSize = binding.HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        const maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) return false;
        for(let cutDown = 1; cutDown <= 4; cutDown *= 2){
            let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            const replacement = emscripten_realloc_buffer(newSize);
            if (replacement) return true;
        }
        return false;
    }
    const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx) {
        let maxBytesToRead = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1024;
        const endIdx = idx + maxBytesToRead;
        let endPtr = idx;
        while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        let str = "";
        while(idx < endPtr){
            let u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
            }
            const u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) === 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
            }
            const u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) === 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
                str += String.fromCharCode(u0);
            } else {
                const ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
        }
        return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
    }
    const asmLibraryArg = {
        emscripten_get_now: _emscripten_get_now,
        emscripten_memcpy_big: _emscripten_memcpy_big,
        emscripten_resize_heap: _emscripten_resize_heap,
        fd_write: ()=>0
    };
    async function createWasm() {
        const info = {
            env: asmLibraryArg,
            wasi_snapshot_preview1: asmLibraryArg
        };
        const exports = await init(info);
        wasmMemory = exports.memory;
        updateGlobalBufferAndViews(wasmMemory.buffer);
        Object.assign(binding, exports);
        binding.UTF8ToString = UTF8ToString;
    }
    await createWasm();
    return binding;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let onigBinding = null;
function throwLastOnigError(onigBinding2) {
    throw new ShikiError(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
class UtfString {
    static _utf8ByteLength(str) {
        let result = 0;
        for(let i = 0, len = str.length; i < len; i++){
            const charCode = str.charCodeAt(i);
            let codepoint = charCode;
            let wasSurrogatePair = false;
            if (charCode >= 55296 && charCode <= 56319) {
                if (i + 1 < len) {
                    const nextCharCode = str.charCodeAt(i + 1);
                    if (nextCharCode >= 56320 && nextCharCode <= 57343) {
                        codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
                        wasSurrogatePair = true;
                    }
                }
            }
            if (codepoint <= 127) result += 1;
            else if (codepoint <= 2047) result += 2;
            else if (codepoint <= 65535) result += 3;
            else result += 4;
            if (wasSurrogatePair) i++;
        }
        return result;
    }
    createString(onigBinding2) {
        const result = onigBinding2.omalloc(this.utf8Length);
        onigBinding2.HEAPU8.set(this.utf8Value, result);
        return result;
    }
    constructor(str){
        __publicField(this, "utf16Length");
        __publicField(this, "utf8Length");
        __publicField(this, "utf16Value");
        __publicField(this, "utf8Value");
        __publicField(this, "utf16OffsetToUtf8");
        __publicField(this, "utf8OffsetToUtf16");
        const utf16Length = str.length;
        const utf8Length = UtfString._utf8ByteLength(str);
        const computeIndicesMapping = utf8Length !== utf16Length;
        const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
        if (computeIndicesMapping) utf16OffsetToUtf8[utf16Length] = utf8Length;
        const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
        if (computeIndicesMapping) utf8OffsetToUtf16[utf8Length] = utf16Length;
        const utf8Value = new Uint8Array(utf8Length);
        let i8 = 0;
        for(let i16 = 0; i16 < utf16Length; i16++){
            const charCode = str.charCodeAt(i16);
            let codePoint = charCode;
            let wasSurrogatePair = false;
            if (charCode >= 55296 && charCode <= 56319) {
                if (i16 + 1 < utf16Length) {
                    const nextCharCode = str.charCodeAt(i16 + 1);
                    if (nextCharCode >= 56320 && nextCharCode <= 57343) {
                        codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
                        wasSurrogatePair = true;
                    }
                }
            }
            if (computeIndicesMapping) {
                utf16OffsetToUtf8[i16] = i8;
                if (wasSurrogatePair) utf16OffsetToUtf8[i16 + 1] = i8;
                if (codePoint <= 127) {
                    utf8OffsetToUtf16[i8 + 0] = i16;
                } else if (codePoint <= 2047) {
                    utf8OffsetToUtf16[i8 + 0] = i16;
                    utf8OffsetToUtf16[i8 + 1] = i16;
                } else if (codePoint <= 65535) {
                    utf8OffsetToUtf16[i8 + 0] = i16;
                    utf8OffsetToUtf16[i8 + 1] = i16;
                    utf8OffsetToUtf16[i8 + 2] = i16;
                } else {
                    utf8OffsetToUtf16[i8 + 0] = i16;
                    utf8OffsetToUtf16[i8 + 1] = i16;
                    utf8OffsetToUtf16[i8 + 2] = i16;
                    utf8OffsetToUtf16[i8 + 3] = i16;
                }
            }
            if (codePoint <= 127) {
                utf8Value[i8++] = codePoint;
            } else if (codePoint <= 2047) {
                utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
                utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
            } else if (codePoint <= 65535) {
                utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
                utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
                utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
            } else {
                utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
                utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
                utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
                utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
            }
            if (wasSurrogatePair) i16++;
        }
        this.utf16Length = utf16Length;
        this.utf8Length = utf8Length;
        this.utf16Value = str;
        this.utf8Value = utf8Value;
        this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
        this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
    }
}
const _OnigString = class _OnigString {
    convertUtf8OffsetToUtf16(utf8Offset) {
        if (this.utf8OffsetToUtf16) {
            if (utf8Offset < 0) return 0;
            if (utf8Offset > this.utf8Length) return this.utf16Length;
            return this.utf8OffsetToUtf16[utf8Offset];
        }
        return utf8Offset;
    }
    convertUtf16OffsetToUtf8(utf16Offset) {
        if (this.utf16OffsetToUtf8) {
            if (utf16Offset < 0) return 0;
            if (utf16Offset > this.utf16Length) return this.utf8Length;
            return this.utf16OffsetToUtf8[utf16Offset];
        }
        return utf16Offset;
    }
    dispose() {
        if (this.ptr === _OnigString._sharedPtr) _OnigString._sharedPtrInUse = false;
        else this._onigBinding.ofree(this.ptr);
    }
    constructor(str){
        __publicField(this, "id", ++_OnigString.LAST_ID);
        __publicField(this, "_onigBinding");
        __publicField(this, "content");
        __publicField(this, "utf16Length");
        __publicField(this, "utf8Length");
        __publicField(this, "utf16OffsetToUtf8");
        __publicField(this, "utf8OffsetToUtf16");
        __publicField(this, "ptr");
        if (!onigBinding) throw new ShikiError("Must invoke loadWasm first.");
        this._onigBinding = onigBinding;
        this.content = str;
        const utfString = new UtfString(str);
        this.utf16Length = utfString.utf16Length;
        this.utf8Length = utfString.utf8Length;
        this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
        this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
        if (this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse) {
            if (!_OnigString._sharedPtr) _OnigString._sharedPtr = onigBinding.omalloc(1e4);
            _OnigString._sharedPtrInUse = true;
            onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr);
            this.ptr = _OnigString._sharedPtr;
        } else {
            this.ptr = utfString.createString(onigBinding);
        }
    }
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
// a pointer to a string of 10000 bytes
__publicField(_OnigString, "_sharedPtrInUse", false);
let OnigString = _OnigString;
class OnigScanner {
    dispose() {
        this._onigBinding.freeOnigScanner(this._ptr);
    }
    findNextMatchSync(string, startPosition, arg) {
        let options = 0 /* None */ ;
        if (typeof arg === "number") {
            options = arg;
        }
        if (typeof string === "string") {
            string = new OnigString(string);
            const result = this._findNextMatchSync(string, startPosition, false, options);
            string.dispose();
            return result;
        }
        return this._findNextMatchSync(string, startPosition, false, options);
    }
    _findNextMatchSync(string, startPosition, debugCall, options) {
        const onigBinding2 = this._onigBinding;
        const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
        if (resultPtr === 0) {
            return null;
        }
        const HEAPU32 = onigBinding2.HEAPU32;
        let offset = resultPtr / 4;
        const index = HEAPU32[offset++];
        const count = HEAPU32[offset++];
        const captureIndices = [];
        for(let i = 0; i < count; i++){
            const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
            const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
            captureIndices[i] = {
                start: beg,
                end,
                length: end - beg
            };
        }
        return {
            index,
            captureIndices
        };
    }
    constructor(patterns){
        __publicField(this, "_onigBinding");
        __publicField(this, "_ptr");
        if (!onigBinding) throw new ShikiError("Must invoke loadWasm first.");
        const strPtrsArr = [];
        const strLenArr = [];
        for(let i = 0, len = patterns.length; i < len; i++){
            const utfString = new UtfString(patterns[i]);
            strPtrsArr[i] = utfString.createString(onigBinding);
            strLenArr[i] = utfString.utf8Length;
        }
        const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
        onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
        const strLenPtr = onigBinding.omalloc(4 * patterns.length);
        onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
        const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
        for(let i = 0, len = patterns.length; i < len; i++)onigBinding.ofree(strPtrsArr[i]);
        onigBinding.ofree(strLenPtr);
        onigBinding.ofree(strPtrsPtr);
        if (scannerPtr === 0) throwLastOnigError(onigBinding);
        this._onigBinding = onigBinding;
        this._ptr = scannerPtr;
    }
}
function isInstantiatorOptionsObject(dataOrOptions) {
    return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
    return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
    return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
    return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
    var _Buffer_isBuffer, _Buffer;
    return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined" && ((_Buffer_isBuffer = (_Buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]).isBuffer) === null || _Buffer_isBuffer === void 0 ? void 0 : _Buffer_isBuffer.call(_Buffer, data)) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
let initPromise;
function loadWasm(options) {
    if (initPromise) return initPromise;
    async function _load() {
        onigBinding = await main(async (info)=>{
            let instance = options;
            instance = await instance;
            if (typeof instance === "function") instance = await instance(info);
            if (typeof instance === "function") instance = await instance(info);
            if (isInstantiatorOptionsObject(instance)) {
                instance = await instance.instantiator(info);
            } else if (isInstantiatorModule(instance)) {
                instance = await instance.default(info);
            } else {
                if (isDataOptionsObject(instance)) instance = instance.data;
                if (isResponse(instance)) {
                    if (typeof WebAssembly.instantiateStreaming === "function") instance = await _makeResponseStreamingLoader(instance)(info);
                    else instance = await _makeResponseNonStreamingLoader(instance)(info);
                } else if (isArrayBuffer(instance)) {
                    instance = await _makeArrayBufferLoader(instance)(info);
                } else if (instance instanceof WebAssembly.Module) {
                    instance = await _makeArrayBufferLoader(instance)(info);
                } else if ("default" in instance && instance.default instanceof WebAssembly.Module) {
                    instance = await _makeArrayBufferLoader(instance.default)(info);
                }
            }
            if ("instance" in instance) instance = instance.instance;
            if ("exports" in instance) instance = instance.exports;
            return instance;
        });
    }
    initPromise = _load();
    return initPromise;
}
function _makeArrayBufferLoader(data) {
    return (importObject)=>WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
    return (importObject)=>WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
    return async (importObject)=>{
        const arrayBuffer = await data.arrayBuffer();
        return WebAssembly.instantiate(arrayBuffer, importObject);
    };
}
let _defaultWasmLoader;
function setDefaultWasmLoader(_loader) {
    _defaultWasmLoader = _loader;
}
function getDefaultWasmLoader() {
    return _defaultWasmLoader;
}
async function createOnigurumaEngine(options) {
    if (options) await loadWasm(options);
    return {
        createScanner (patterns) {
            return new OnigScanner(patterns.map((p)=>typeof p === "string" ? p : p.source));
        },
        createString (s) {
            return new OnigString(s);
        }
    };
}
;
}),
"[project]/node_modules/shiki/dist/bundle-full.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "codeToHast",
    ()=>codeToHast,
    "codeToHtml",
    ()=>codeToHtml,
    "codeToTokens",
    ()=>codeToTokens,
    "codeToTokensBase",
    ()=>codeToTokensBase,
    "codeToTokensWithThemes",
    ()=>codeToTokensWithThemes,
    "createHighlighter",
    ()=>createHighlighter,
    "getLastGrammarState",
    ()=>getLastGrammarState,
    "getSingletonHighlighter",
    ()=>getSingletonHighlighter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/core/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/langs.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$themes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/themes.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$oniguruma$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/engine-oniguruma/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
const createHighlighter = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createdBundledHighlighter"])({
    langs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledLanguages"],
    themes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$themes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledThemes"],
    engine: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$oniguruma$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOnigurumaEngine"])(__turbopack_context__.A("[project]/node_modules/shiki/dist/wasm.mjs [app-client] (ecmascript, async loader)"))
});
const { codeToHtml, codeToHast, codeToTokens, codeToTokensBase, codeToTokensWithThemes, getSingletonHighlighter, getLastGrammarState } = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSingletonShorthands"])(createHighlighter, {
    guessEmbeddedLanguages: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guessEmbeddedLanguages"]
});
;
}),
"[project]/node_modules/@swc/helpers/esm/_class_private_method_get.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_method_get
]);
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
    return fn;
}
;
}),
"[project]/node_modules/@swc/helpers/esm/_class_private_method_init.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_method_init
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_check_private_redeclaration.js [app-client] (ecmascript)");
;
function _class_private_method_init(obj, privateSet) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(obj, privateSet);
    privateSet.add(obj);
}
;
}),
"[project]/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_get_prototype_of
]);
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
;
}),
"[project]/node_modules/@swc/helpers/esm/_super_prop_base.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_super_prop_base
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
;
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(object);
        if (object === null) break;
    }
    return object;
}
;
}),
"[project]/node_modules/@swc/helpers/esm/_get.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_get
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_super_prop_base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_super_prop_base.js [app-client] (ecmascript)");
;
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) _get = Reflect.get;
    else {
        _get = function get(target, property, receiver) {
            var base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_super_prop_base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) return desc.get.call(receiver || target);
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
;
}),
"[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_tagged_template_literal
]);
function _tagged_template_literal(strings, raw) {
    if (!raw) raw = strings.slice(0);
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
;
}),
"[project]/node_modules/oniguruma-parser/dist/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PosixClassNames",
    ()=>i,
    "cpOf",
    ()=>r,
    "getOrInsert",
    ()=>l,
    "r",
    ()=>o,
    "throwIfNullish",
    ()=>u
]);
"use strict";
function r(e) {
    if ([
        ...e
    ].length !== 1) throw new Error('Expected "'.concat(e, '" to be a single code point'));
    return e.codePointAt(0);
}
function l(e, t, n) {
    return e.has(t) || e.set(t, n), e.get(t);
}
const i = new Set([
    "alnum",
    "alpha",
    "ascii",
    "blank",
    "cntrl",
    "digit",
    "graph",
    "lower",
    "print",
    "punct",
    "space",
    "upper",
    "word",
    "xdigit"
]), o = String.raw;
function u(e, t) {
    if (e == null) throw new Error(t !== null && t !== void 0 ? t : "Value expected");
    return e;
}
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/oniguruma-parser/dist/tokenizer/tokenize.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "tokenize",
    ()=>M
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/utils.js [app-client] (ecmascript)");
"use strict";
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[^?"
    ], [
        "\\[\\^?"
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[pP]{(?:^?[- _]*[A-Za-z][- w]*})?"
    ], [
        "[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?"
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "x[89A-Fa-f]p{AHex}(?:\\x[89A-Fa-f]p{AHex})*"
    ], [
        "x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*"
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "u(?:p{AHex}{4})? | x{[^}]*}? | xp{AHex}{0,2}"
    ], [
        "u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}"
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
function _templateObject4() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "o{[^}]*}?"
    ], [
        "o\\{[^\\}]*\\}?"
    ]);
    _templateObject4 = function() {
        return data;
    };
    return data;
}
function _templateObject5() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "d{1,3}"
    ], [
        "\\d{1,3}"
    ]);
    _templateObject5 = function() {
        return data;
    };
    return data;
}
function _templateObject6() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\n  \\ (?:\n    ",
        "\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | ( (?:\n    ? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~|?\n      | #(?:[^)\\]|\\.?)*\n      | [^:)]*[:)]\n    )?\n    | *[^)]*)?\n  )?\n  | (?:",
        ")+\n  | ",
        "\n  | .\n"
    ], [
        "\n  \\\\ (?:\n    ",
        "\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*[^\\)]*\\)?\n  )?\n  | (?:",
        ")+\n  | ",
        "\n  | .\n"
    ]);
    _templateObject6 = function() {
        return data;
    };
    return data;
}
function _templateObject7() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\n  \\ (?:\n    ",
        "\n    | .\n  )\n  | [:(?:^?p{Alpha}+|^):]\n  | ",
        "\n  | &&\n  | .\n"
    ], [
        "\n  \\\\ (?:\n    ",
        "\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ",
        "\n  | &&\n  | .\n"
    ]);
    _templateObject7 = function() {
        return data;
    };
    return data;
}
function _templateObject8() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "A"
    ], [
        "\\A"
    ]);
    _templateObject8 = function() {
        return data;
    };
    return data;
}
function _templateObject9() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "Z"
    ], [
        "\\Z"
    ]);
    _templateObject9 = function() {
        return data;
    };
    return data;
}
function _templateObject10() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "o{"
    ], [
        "\\o{"
    ]);
    _templateObject10 = function() {
        return data;
    };
    return data;
}
function _templateObject11() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Incomplete escape ""'
    ], [
        'Incomplete escape "\\"'
    ]);
    _templateObject11 = function() {
        return data;
    };
    return data;
}
function _templateObject12() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Octal encoded byte above 177 unsupported "',
        '"'
    ]);
    _templateObject12 = function() {
        return data;
    };
    return data;
}
;
const m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject()), b = "c.? | C(?:-.?)?|".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject1()), "|").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject2()), "|").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject3()), "|").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject4()), "|").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject5())), y = /[?*+][?+]?|\{(?:\d+(?:,\d*)?|,\d+)\}\??/, C = new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject6(), b, y.source, m).replace(/\s+/g, ""), "gsu"), T = new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject7(), b, m).replace(/\s+/g, ""), "gsu");
function M(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const t = {
        flags: "",
        ...n,
        rules: {
            captureGroup: !1,
            singleline: !1,
            ...n.rules
        }
    };
    if (typeof e != "string") throw new Error("String expected as pattern");
    const o = Y(t.flags), s = [
        o.extended
    ], a = {
        captureGroup: t.rules.captureGroup,
        getCurrentModX () {
            return s.at(-1);
        },
        numOpenGroups: 0,
        popModX () {
            s.pop();
        },
        pushModX (u) {
            s.push(u);
        },
        replaceCurrentModX (u) {
            s[s.length - 1] = u;
        },
        singleline: t.rules.singleline
    };
    let r = [], i;
    for(C.lastIndex = 0; i = C.exec(e);){
        const u = F(a, e, i[0], C.lastIndex);
        u.tokens ? r.push(...u.tokens) : u.token && r.push(u.token), u.lastIndex !== void 0 && (C.lastIndex = u.lastIndex);
    }
    const l = [];
    let c = 0;
    r.filter((u)=>u.type === "GroupOpen").forEach((u)=>{
        u.kind === "capturing" ? u.number = ++c : u.raw === "(" && l.push(u);
    }), c || l.forEach((u, S)=>{
        u.kind = "capturing", u.number = S + 1;
    });
    const g = c || l.length;
    return {
        tokens: r.map((u)=>u.type === "EscapedNumber" ? ee(u, g) : u).flat(),
        flags: o
    };
}
function F(e, n, t, o) {
    const [s, a] = t;
    if (t === "[" || t === "[^") {
        const r = K(n, t, o);
        return {
            tokens: r.tokens,
            lastIndex: r.lastIndex
        };
    }
    if (s === "\\") {
        if ("AbBGyYzZ".includes(a)) return {
            token: w(t, t)
        };
        if (/^\\g[<']/.test(t)) {
            if (!/^\\g(?:<[^>]+>|'[^']+')$/.test(t)) throw new Error('Invalid group name "'.concat(t, '"'));
            return {
                token: R(t)
            };
        }
        if (/^\\k[<']/.test(t)) {
            if (!/^\\k(?:<[^>]+>|'[^']+')$/.test(t)) throw new Error('Invalid group name "'.concat(t, '"'));
            return {
                token: A(t)
            };
        }
        if (a === "K") return {
            token: I("keep", t)
        };
        if (a === "N" || a === "R") return {
            token: k("newline", t, {
                negate: a === "N"
            })
        };
        if (a === "O") return {
            token: k("any", t)
        };
        if (a === "X") return {
            token: k("text_segment", t)
        };
        const r = x(t, {
            inCharClass: !1
        });
        return Array.isArray(r) ? {
            tokens: r
        } : {
            token: r
        };
    }
    if (s === "(") {
        if (a === "*") return {
            token: j(t)
        };
        if (t === "(?{") throw new Error('Unsupported callout "'.concat(t, '"'));
        if (t.startsWith("(?#")) {
            if (n[o] !== ")") throw new Error('Unclosed comment group "(?#"');
            return {
                lastIndex: o + 1
            };
        }
        if (/^\(\?[-imx]+[:)]$/.test(t)) return {
            token: L(t, e)
        };
        if (e.pushModX(e.getCurrentModX()), e.numOpenGroups++, t === "(" && !e.captureGroup || t === "(?:") return {
            token: f("group", t)
        };
        if (t === "(?>") return {
            token: f("atomic", t)
        };
        if (t === "(?=" || t === "(?!" || t === "(?<=" || t === "(?<!") return {
            token: f(t[2] === "<" ? "lookbehind" : "lookahead", t, {
                negate: t.endsWith("!")
            })
        };
        if (t === "(" && e.captureGroup || t.startsWith("(?<") && t.endsWith(">") || t.startsWith("(?'") && t.endsWith("'")) return {
            token: f("capturing", t, {
                ...t !== "(" && {
                    name: t.slice(3, -1)
                }
            })
        };
        if (t.startsWith("(?~")) {
            if (t === "(?~|") throw new Error('Unsupported absence function kind "'.concat(t, '"'));
            return {
                token: f("absence_repeater", t)
            };
        }
        throw t === "(?(" ? new Error('Unsupported conditional "'.concat(t, '"')) : new Error('Invalid or unsupported group option "'.concat(t, '"'));
    }
    if (t === ")") {
        if (e.popModX(), e.numOpenGroups--, e.numOpenGroups < 0) throw new Error('Unmatched ")"');
        return {
            token: Q(t)
        };
    }
    if (e.getCurrentModX()) {
        if (t === "#") {
            const r = n.indexOf("\n", o);
            return {
                lastIndex: r === -1 ? n.length : r
            };
        }
        if (/^\s$/.test(t)) {
            const r = /\s+/y;
            return r.lastIndex = o, {
                lastIndex: r.exec(n) ? r.lastIndex : o
            };
        }
    }
    if (t === ".") return {
        token: k("dot", t)
    };
    if (t === "^" || t === "$") {
        const r = e.singleline ? ({
            "^": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject8()),
            $: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject9())
        })[t] : t;
        return {
            token: w(r, t)
        };
    }
    return t === "|" ? {
        token: P(t)
    } : y.test(t) ? {
        tokens: te(t)
    } : {
        token: d((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])(t), t)
    };
}
function K(e, n, t) {
    const o = [
        E(n[1] === "^", n)
    ];
    let s = 1, a;
    for(T.lastIndex = t; a = T.exec(e);){
        const r = a[0];
        if (r[0] === "[" && r[1] !== ":") s++, o.push(E(r[1] === "^", r));
        else if (r === "]") {
            if (o.at(-1).type === "CharacterClassOpen") o.push(d(93, r));
            else if (s--, o.push(z(r)), !s) break;
        } else {
            const i = X(r);
            Array.isArray(i) ? o.push(...i) : o.push(i);
        }
    }
    return {
        tokens: o,
        lastIndex: T.lastIndex || e.length
    };
}
function X(e) {
    if (e[0] === "\\") return x(e, {
        inCharClass: !0
    });
    if (e[0] === "[") {
        const n = RegExp("\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]").exec(e);
        if (!n || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PosixClassNames"].has(n.groups.name)) throw new Error('Invalid POSIX class "'.concat(e, '"'));
        return k("posix", e, {
            value: n.groups.name,
            negate: !!n.groups.negate
        });
    }
    return e === "-" ? U(e) : e === "&&" ? H(e) : d((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])(e), e);
}
function x(e, param) {
    let { inCharClass: n } = param;
    const t = e[1];
    if (t === "c" || t === "C") return Z(e);
    if ("dDhHsSwW".includes(t)) return q(e);
    if (e.startsWith((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject10()))) throw new Error('Incomplete, invalid, or unsupported octal code point "'.concat(e, '"'));
    if (/^\\[pP]\{/.test(e)) {
        if (e.length === 3) throw new Error('Incomplete or invalid Unicode property "'.concat(e, '"'));
        return V(e);
    }
    if (RegExp("^\\\\x[89A-Fa-f]\\p{AHex}", "u").test(e)) try {
        const o = e.split(/\\x/).slice(1).map((i)=>parseInt(i, 16)), s = new TextDecoder("utf-8", {
            ignoreBOM: !0,
            fatal: !0
        }).decode(new Uint8Array(o)), a = new TextEncoder;
        return [
            ...s
        ].map((i)=>{
            const l = [
                ...a.encode(i)
            ].map((c)=>"\\x".concat(c.toString(16))).join("");
            return d((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])(i), l);
        });
    } catch (e1) {
        throw new Error('Multibyte code "'.concat(e, '" incomplete or invalid in Oniguruma'));
    }
    if (t === "u" || t === "x") return d(J(e), e);
    if ($.has(t)) return d($.get(t), e);
    if (/\d/.test(t)) return W(n, e);
    if (e === "\\") throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject11()));
    if (t === "M") throw new Error('Unsupported meta "'.concat(e, '"'));
    if ([
        ...e
    ].length === 2) return d(e.codePointAt(1), e);
    throw new Error('Unexpected escape "'.concat(e, '"'));
}
function P(e) {
    return {
        type: "Alternator",
        raw: e
    };
}
function w(e, n) {
    return {
        type: "Assertion",
        kind: e,
        raw: n
    };
}
function A(e) {
    return {
        type: "Backreference",
        raw: e
    };
}
function d(e, n) {
    return {
        type: "Character",
        value: e,
        raw: n
    };
}
function z(e) {
    return {
        type: "CharacterClassClose",
        raw: e
    };
}
function U(e) {
    return {
        type: "CharacterClassHyphen",
        raw: e
    };
}
function H(e) {
    return {
        type: "CharacterClassIntersector",
        raw: e
    };
}
function E(e, n) {
    return {
        type: "CharacterClassOpen",
        negate: e,
        raw: n
    };
}
function k(e, n) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return {
        type: "CharacterSet",
        kind: e,
        ...t,
        raw: n
    };
}
function I(e, n) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return e === "keep" ? {
        type: "Directive",
        kind: e,
        raw: n
    } : {
        type: "Directive",
        kind: e,
        flags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])(t.flags),
        raw: n
    };
}
function W(e, n) {
    return {
        type: "EscapedNumber",
        inCharClass: e,
        raw: n
    };
}
function Q(e) {
    return {
        type: "GroupClose",
        raw: e
    };
}
function f(e, n) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return {
        type: "GroupOpen",
        kind: e,
        ...t,
        raw: n
    };
}
function D(e, n, t, o) {
    return {
        type: "NamedCallout",
        kind: e,
        tag: n,
        arguments: t,
        raw: o
    };
}
function _(e, n, t, o) {
    return {
        type: "Quantifier",
        kind: e,
        min: n,
        max: t,
        raw: o
    };
}
function R(e) {
    return {
        type: "Subroutine",
        raw: e
    };
}
const B = new Set([
    "COUNT",
    "CMP",
    "ERROR",
    "FAIL",
    "MAX",
    "MISMATCH",
    "SKIP",
    "TOTAL_COUNT"
]), $ = new Map([
    [
        "a",
        7
    ],
    [
        "b",
        8
    ],
    [
        "e",
        27
    ],
    [
        "f",
        12
    ],
    [
        "n",
        10
    ],
    [
        "r",
        13
    ],
    [
        "t",
        9
    ],
    [
        "v",
        11
    ]
]);
function Z(e) {
    const n = e[1] === "c" ? e[2] : e[3];
    if (!n || !/[A-Za-z]/.test(n)) throw new Error('Unsupported control character "'.concat(e, '"'));
    return d((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])(n.toUpperCase()) - 64, e);
}
function L(e, n) {
    let { on: t, off: o } = RegExp("^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?").exec(e).groups;
    o !== null && o !== void 0 ? o : o = "";
    const s = (n.getCurrentModX() || t.includes("x")) && !o.includes("x"), a = v(t), r = v(o), i = {};
    if (a && (i.enable = a), r && (i.disable = r), e.endsWith(")")) return n.replaceCurrentModX(s), I("flags", e, {
        flags: i
    });
    if (e.endsWith(":")) return n.pushModX(s), n.numOpenGroups++, f("group", e, {
        ...(a || r) && {
            flags: i
        }
    });
    throw new Error('Unexpected flag modifier "'.concat(e, '"'));
}
function j(e) {
    const n = RegExp("\\(\\*(?<name>[A-Za-z_]\\w*)?(?:\\[(?<tag>(?:[A-Za-z_]\\w*)?)\\])?(?:\\{(?<args>[^}]*)\\})?\\)").exec(e);
    if (!n) throw new Error('Incomplete or invalid named callout "'.concat(e, '"'));
    const { name: t, tag: o, args: s } = n.groups;
    if (!t) throw new Error('Invalid named callout "'.concat(e, '"'));
    if (o === "") throw new Error('Named callout tag with empty value not allowed "'.concat(e, '"'));
    const a = s ? s.split(",").filter((g)=>g !== "").map((g)=>/^[+-]?\d+$/.test(g) ? +g : g) : [], [r, i, l] = a, c = B.has(t) ? t.toLowerCase() : "custom";
    switch(c){
        case "fail":
        case "mismatch":
        case "skip":
            if (a.length > 0) throw new Error('Named callout arguments not allowed "'.concat(a, '"'));
            break;
        case "error":
            if (a.length > 1) throw new Error('Named callout allows only one argument "'.concat(a, '"'));
            if (typeof r == "string") throw new Error('Named callout argument must be a number "'.concat(r, '"'));
            break;
        case "max":
            if (!a.length || a.length > 2) throw new Error('Named callout must have one or two arguments "'.concat(a, '"'));
            if (typeof r == "string" && !/^[A-Za-z_]\w*$/.test(r)) throw new Error('Named callout argument one must be a tag or number "'.concat(r, '"'));
            if (a.length === 2 && (typeof i == "number" || !/^[<>X]$/.test(i))) throw new Error("Named callout optional argument two must be '<', '>', or 'X' \"".concat(i, '"'));
            break;
        case "count":
        case "total_count":
            if (a.length > 1) throw new Error('Named callout allows only one argument "'.concat(a, '"'));
            if (a.length === 1 && (typeof r == "number" || !/^[<>X]$/.test(r))) throw new Error("Named callout optional argument must be '<', '>', or 'X' \"".concat(r, '"'));
            break;
        case "cmp":
            if (a.length !== 3) throw new Error('Named callout must have three arguments "'.concat(a, '"'));
            if (typeof r == "string" && !/^[A-Za-z_]\w*$/.test(r)) throw new Error('Named callout argument one must be a tag or number "'.concat(r, '"'));
            if (typeof i == "number" || !/^(?:[<>!=]=|[<>])$/.test(i)) throw new Error("Named callout argument two must be '==', '!=', '>', '<', '>=', or '<=' \"".concat(i, '"'));
            if (typeof l == "string" && !/^[A-Za-z_]\w*$/.test(l)) throw new Error('Named callout argument three must be a tag or number "'.concat(l, '"'));
            break;
        case "custom":
            throw new Error('Undefined callout name "'.concat(t, '"'));
        default:
            throw new Error('Unexpected named callout kind "'.concat(c, '"'));
    }
    var _s_split;
    return D(c, o !== null && o !== void 0 ? o : null, (_s_split = s === null || s === void 0 ? void 0 : s.split(",")) !== null && _s_split !== void 0 ? _s_split : null, e);
}
function O(e) {
    let n = null, t, o;
    if (e[0] === "{") {
        const { minStr: s, maxStr: a } = RegExp("^\\{(?<minStr>\\d*)(?:,(?<maxStr>\\d*))?").exec(e).groups, r = 1e5;
        if (+s > r || a && +a > r) throw new Error("Quantifier value unsupported in Oniguruma");
        if (t = +s, o = a === void 0 ? +s : a === "" ? 1 / 0 : +a, t > o && (n = "possessive", [t, o] = [
            o,
            t
        ]), e.endsWith("?")) {
            if (n === "possessive") throw new Error('Unsupported possessive interval quantifier chain with "?"');
            n = "lazy";
        } else n || (n = "greedy");
    } else t = e[0] === "+" ? 1 : 0, o = e[0] === "?" ? 1 : 1 / 0, n = e[1] === "+" ? "possessive" : e[1] === "?" ? "lazy" : "greedy";
    return _(n, t, o, e);
}
function q(e) {
    const n = e[1].toLowerCase();
    return k({
        d: "digit",
        h: "hex",
        s: "space",
        w: "word"
    }[n], e, {
        negate: e[1] !== n
    });
}
function V(e) {
    const { p: n, neg: t, value: o } = RegExp("^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)").exec(e).groups;
    return k("property", e, {
        value: o,
        negate: n === "P" && !t || n === "p" && !!t
    });
}
function v(e) {
    const n = {};
    return e.includes("i") && (n.ignoreCase = !0), e.includes("m") && (n.dotAll = !0), e.includes("x") && (n.extended = !0), Object.keys(n).length ? n : null;
}
function Y(e) {
    const n = {
        ignoreCase: !1,
        dotAll: !1,
        extended: !1,
        digitIsAscii: !1,
        posixIsAscii: !1,
        spaceIsAscii: !1,
        wordIsAscii: !1,
        textSegmentMode: null
    };
    for(let t = 0; t < e.length; t++){
        const o = e[t];
        if (!"imxDPSWy".includes(o)) throw new Error('Invalid flag "'.concat(o, '"'));
        if (o === "y") {
            if (!/^y{[gw]}/.test(e.slice(t))) throw new Error('Invalid or unspecified flag "y" mode');
            n.textSegmentMode = e[t + 2] === "g" ? "grapheme" : "word", t += 3;
            continue;
        }
        n[({
            i: "ignoreCase",
            m: "dotAll",
            x: "extended",
            D: "digitIsAscii",
            P: "posixIsAscii",
            S: "spaceIsAscii",
            W: "wordIsAscii"
        })[o]] = !0;
    }
    return n;
}
function J(e) {
    if (RegExp("^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))", "u").test(e)) throw new Error('Incomplete or invalid escape "'.concat(e, '"'));
    const n = e[2] === "{" ? RegExp("^\\\\x\\{\\s*(?<hex>\\p{AHex}+)", "u").exec(e).groups.hex : e.slice(2);
    return parseInt(n, 16);
}
function ee(e, n) {
    const { raw: t, inCharClass: o } = e, s = t.slice(1);
    if (!o && (s !== "0" && s.length === 1 || s[0] !== "0" && +s <= n)) return [
        A(t)
    ];
    const a = [], r = s.match(/^[0-7]+|\d/g);
    for(let i = 0; i < r.length; i++){
        const l = r[i];
        let c;
        if (i === 0 && l !== "8" && l !== "9") {
            if (c = parseInt(l, 8), c > 127) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject12(), t));
        } else c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])(l);
        a.push(d(c, (i === 0 ? "\\" : "") + l));
    }
    return a;
}
function te(e) {
    const n = [], t = new RegExp(y, "gy");
    let o;
    for(; o = t.exec(e);){
        const s = o[0];
        if (s[0] === "{") {
            const a = RegExp("^\\{(?<min>\\d+),(?<max>\\d+)\\}\\??$").exec(s);
            if (a) {
                const { min: r, max: i } = a.groups;
                if (+r > +i && s.endsWith("?")) {
                    t.lastIndex--, n.push(O(s.slice(0, -1)));
                    continue;
                }
            }
        }
        n.push(O(s));
    }
    return n;
}
;
 //# sourceMappingURL=tokenize.js.map
}),
"[project]/node_modules/oniguruma-parser/dist/parser/node-utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasOnlyChild",
    ()=>o,
    "isAlternativeContainer",
    ()=>a,
    "isQuantifiable",
    ()=>s
]);
"use strict";
function o(e, t) {
    if (!Array.isArray(e.body)) throw new Error("Expected node with body array");
    if (e.body.length !== 1) return !1;
    const r = e.body[0];
    return !t || Object.keys(t).every((n)=>t[n] === r[n]);
}
function a(e) {
    return !(!i.has(e.type) || e.type === "AbsenceFunction" && e.kind !== "repeater");
}
const i = new Set([
    "AbsenceFunction",
    "CapturingGroup",
    "Group",
    "LookaroundAssertion",
    "Regex"
]);
function s(e) {
    return y.has(e.type);
}
const y = new Set([
    "AbsenceFunction",
    "Backreference",
    "CapturingGroup",
    "Character",
    "CharacterClass",
    "CharacterSet",
    "Group",
    "Quantifier",
    "Subroutine"
]);
;
 //# sourceMappingURL=node-utils.js.map
}),
"[project]/node_modules/oniguruma-parser/dist/parser/parse.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createAbsenceFunction",
    ()=>G,
    "createAlternative",
    ()=>b,
    "createAssertion",
    ()=>F,
    "createBackreference",
    ()=>k,
    "createCapturingGroup",
    ()=>P,
    "createCharacter",
    ()=>m,
    "createCharacterClass",
    ()=>C,
    "createCharacterClassRange",
    ()=>L,
    "createCharacterSet",
    ()=>E,
    "createDirective",
    ()=>I,
    "createFlags",
    ()=>T,
    "createGroup",
    ()=>A,
    "createLookaroundAssertion",
    ()=>K,
    "createNamedCallout",
    ()=>U,
    "createPosixClass",
    ()=>R,
    "createQuantifier",
    ()=>_,
    "createRegex",
    ()=>B,
    "createSubroutine",
    ()=>O,
    "createUnicodeProperty",
    ()=>Q,
    "parse",
    ()=>J,
    "slug",
    ()=>w
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$tokenizer$2f$tokenize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/tokenizer/tokenize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$node$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/parser/node-utils.js [app-client] (ecmascript)");
"use strict";
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Subroutine uses a duplicate group name "g<',
        '>"'
    ], [
        'Subroutine uses a duplicate group name "\\g<',
        '>"'
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "Subroutine uses a group name that's not defined \"g<",
        '>"'
    ], [
        "Subroutine uses a group name that's not defined \"\\g<",
        '>"'
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "B"
    ], [
        "\\B"
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "Y"
    ], [
        "\\Y"
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
function _templateObject4() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Invalid Unicode property "p{',
        '}"'
    ], [
        'Invalid Unicode property "\\p{',
        '}"'
    ]);
    _templateObject4 = function() {
        return data;
    };
    return data;
}
;
;
;
function J(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = {
        flags: "",
        normalizeUnknownPropertyNames: !1,
        skipBackrefValidation: !1,
        skipLookbehindValidation: !1,
        skipPropertyNameValidation: !1,
        unicodePropertyMap: null,
        ...r,
        rules: {
            captureGroup: !1,
            singleline: !1,
            ...r.rules
        }
    }, t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$tokenizer$2f$tokenize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokenize"])(e, {
        flags: n.flags,
        rules: {
            captureGroup: n.rules.captureGroup,
            singleline: n.rules.singleline
        }
    }), s = (p, N)=>{
        const u = t.tokens[o.nextIndex];
        switch(o.parent = p, o.nextIndex++, u.type){
            case "Alternator":
                return b();
            case "Assertion":
                return W(u);
            case "Backreference":
                return X(u, o);
            case "Character":
                return m(u.value, {
                    useLastValid: !!N.isCheckingRangeEnd
                });
            case "CharacterClassHyphen":
                return ee(u, o, N);
            case "CharacterClassOpen":
                return re(u, o, N);
            case "CharacterSet":
                return ne(u, o);
            case "Directive":
                return I(u.kind, {
                    flags: u.flags
                });
            case "GroupOpen":
                return te(u, o, N);
            case "NamedCallout":
                return U(u.kind, u.tag, u.arguments);
            case "Quantifier":
                return oe(u, o);
            case "Subroutine":
                return ae(u, o);
            default:
                throw new Error('Unexpected token type "'.concat(u.type, '"'));
        }
    }, o = {
        capturingGroups: [],
        hasNumberedRef: !1,
        namedGroupsByName: new Map,
        nextIndex: 0,
        normalizeUnknownPropertyNames: n.normalizeUnknownPropertyNames,
        parent: null,
        skipBackrefValidation: n.skipBackrefValidation,
        skipLookbehindValidation: n.skipLookbehindValidation,
        skipPropertyNameValidation: n.skipPropertyNameValidation,
        subroutines: [],
        tokens: t.tokens,
        unicodePropertyMap: n.unicodePropertyMap,
        walk: s
    }, i = B(T(t.flags));
    let d = i.body[0];
    for(; o.nextIndex < t.tokens.length;){
        const p = s(d, {});
        p.type === "Alternative" ? (i.body.push(p), d = p) : d.body.push(p);
    }
    const { capturingGroups: a, hasNumberedRef: l, namedGroupsByName: c, subroutines: f } = o;
    if (l && c.size && !n.rules.captureGroup) throw new Error("Numbered backref/subroutine not allowed when using named capture");
    for (const { ref: p } of f)if (typeof p == "number") {
        if (p > a.length) throw new Error("Subroutine uses a group number that's not defined");
        p && (a[p - 1].isSubroutined = !0);
    } else if (c.has(p)) {
        if (c.get(p).length > 1) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject(), p));
        c.get(p)[0].isSubroutined = !0;
    } else throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject1(), p));
    return i;
}
function W(param) {
    let { kind: e } = param;
    return F((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])({
        "^": "line_start",
        $: "line_end",
        "\\A": "string_start",
        "\\b": "word_boundary",
        "\\B": "word_boundary",
        "\\G": "search_start",
        "\\y": "text_segment_boundary",
        "\\Y": "text_segment_boundary",
        "\\z": "string_end",
        "\\Z": "string_end_newline"
    }[e], 'Unexpected assertion kind "'.concat(e, '"')), {
        negate: e === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject2()) || e === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject3())
    });
}
function X(param, r) {
    let { raw: e } = param;
    const n = /^\\k[<']/.test(e), t = n ? e.slice(3, -1) : e.slice(1), s = function(o) {
        let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        const d = r.capturingGroups.length;
        let a = !1;
        if (o > d) if (r.skipBackrefValidation) a = !0;
        else throw new Error('Not enough capturing groups defined to the left "'.concat(e, '"'));
        return r.hasNumberedRef = !0, k(i ? d + 1 - o : o, {
            orphan: a
        });
    };
    if (n) {
        const o = RegExp("^(?<sign>-?)0*(?<num>[1-9]\\d*)$").exec(t);
        if (o) return s(+o.groups.num, !!o.groups.sign);
        if (/[-+]/.test(t)) throw new Error('Invalid backref name "'.concat(e, '"'));
        if (!r.namedGroupsByName.has(t)) throw new Error('Group name not defined to the left "'.concat(e, '"'));
        return k(t);
    }
    return s(+t);
}
function ee(e, r, n) {
    const { tokens: t, walk: s } = r, o = r.parent, i = o.body.at(-1), d = t[r.nextIndex];
    if (!n.isCheckingRangeEnd && i && i.type !== "CharacterClass" && i.type !== "CharacterClassRange" && d && d.type !== "CharacterClassOpen" && d.type !== "CharacterClassClose" && d.type !== "CharacterClassIntersector") {
        const a = s(o, {
            ...n,
            isCheckingRangeEnd: !0
        });
        if (i.type === "Character" && a.type === "Character") return o.body.pop(), L(i, a);
        throw new Error("Invalid character class range");
    }
    return m((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cpOf"])("-"));
}
function re(param, r, n) {
    let { negate: e } = param;
    const { tokens: t, walk: s } = r, o = t[r.nextIndex], i = [
        C()
    ];
    let d = z(o);
    for(; d.type !== "CharacterClassClose";){
        if (d.type === "CharacterClassIntersector") i.push(C()), r.nextIndex++;
        else {
            const l = i.at(-1);
            l.body.push(s(l, n));
        }
        d = z(t[r.nextIndex], o);
    }
    const a = C({
        negate: e
    });
    return i.length === 1 ? a.body = i[0].body : (a.kind = "intersection", a.body = i.map((l)=>l.body.length === 1 ? l.body[0] : l)), r.nextIndex++, a;
}
function ne(param, t) {
    let { kind: e, negate: r, value: n } = param;
    const { normalizeUnknownPropertyNames: s, skipPropertyNameValidation: o, unicodePropertyMap: i } = t;
    if (e === "property") {
        const d = w(n);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PosixClassNames"].has(d) && !(i === null || i === void 0 ? void 0 : i.has(d))) e = "posix", n = d;
        else return Q(n, {
            negate: r,
            normalizeUnknownPropertyNames: s,
            skipPropertyNameValidation: o,
            unicodePropertyMap: i
        });
    }
    return e === "posix" ? R(n, {
        negate: r
    }) : E(e, {
        negate: r
    });
}
function te(e, r, n) {
    const { tokens: t, capturingGroups: s, namedGroupsByName: o, skipLookbehindValidation: i, walk: d } = r, a = ie(e), l = a.type === "AbsenceFunction", c = $(a), f = c && a.negate;
    if (a.type === "CapturingGroup" && (s.push(a), a.name && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOrInsert"])(o, a.name, []).push(a)), l && n.isInAbsenceFunction) throw new Error("Nested absence function not supported by Oniguruma");
    let p = D(t[r.nextIndex]);
    for(; p.type !== "GroupClose";){
        if (p.type === "Alternator") a.body.push(b()), r.nextIndex++;
        else {
            const N = a.body.at(-1), u = d(N, {
                ...n,
                isInAbsenceFunction: n.isInAbsenceFunction || l,
                isInLookbehind: n.isInLookbehind || c,
                isInNegLookbehind: n.isInNegLookbehind || f
            });
            if (N.body.push(u), (c || n.isInLookbehind) && !i) {
                const v = "Lookbehind includes a pattern not allowed by Oniguruma";
                if (f || n.isInNegLookbehind) {
                    if (M(u) || u.type === "CapturingGroup") throw new Error(v);
                } else if (M(u) || $(u) && u.negate) throw new Error(v);
            }
        }
        p = D(t[r.nextIndex]);
    }
    return r.nextIndex++, a;
}
function oe(param, t) {
    let { kind: e, min: r, max: n } = param;
    const s = t.parent, o = s.body.at(-1);
    if (!o || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$node$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isQuantifiable"])(o)) throw new Error("Quantifier requires a repeatable token");
    const i = _(e, r, n, o);
    return s.body.pop(), i;
}
function ae(param, r) {
    let { raw: e } = param;
    const { capturingGroups: n, subroutines: t } = r;
    let s = e.slice(3, -1);
    const o = RegExp("^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$").exec(s);
    if (o) {
        const d = +o.groups.num, a = n.length;
        if (r.hasNumberedRef = !0, s = ({
            "": d,
            "+": a + d,
            "-": a + 1 - d
        })[o.groups.sign], s < 1) throw new Error("Invalid subroutine number");
    } else s === "0" && (s = 0);
    const i = O(s);
    return t.push(i), i;
}
function G(e, r) {
    if (e !== "repeater") throw new Error('Unexpected absence function kind "'.concat(e, '"'));
    return {
        type: "AbsenceFunction",
        kind: e,
        body: h(r === null || r === void 0 ? void 0 : r.body)
    };
}
function b(e) {
    return {
        type: "Alternative",
        body: V(e === null || e === void 0 ? void 0 : e.body)
    };
}
function F(e, r) {
    const n = {
        type: "Assertion",
        kind: e
    };
    return (e === "word_boundary" || e === "text_segment_boundary") && (n.negate = !!(r === null || r === void 0 ? void 0 : r.negate)), n;
}
function k(e, r) {
    const n = !!(r === null || r === void 0 ? void 0 : r.orphan);
    return {
        type: "Backreference",
        ref: e,
        ...n && {
            orphan: n
        }
    };
}
function P(e, r) {
    const n = {
        name: void 0,
        isSubroutined: !1,
        ...r
    };
    if (n.name !== void 0 && !se(n.name)) throw new Error('Group name "'.concat(n.name, '" invalid in Oniguruma'));
    return {
        type: "CapturingGroup",
        number: e,
        ...n.name && {
            name: n.name
        },
        ...n.isSubroutined && {
            isSubroutined: n.isSubroutined
        },
        body: h(r === null || r === void 0 ? void 0 : r.body)
    };
}
function m(e, r) {
    const n = {
        useLastValid: !1,
        ...r
    };
    if (e > 1114111) {
        const t = e.toString(16);
        if (n.useLastValid) e = 1114111;
        else throw e > 1310719 ? new Error('Invalid code point out of range "\\x{'.concat(t, '}"')) : new Error('Invalid code point out of range in JS "\\x{'.concat(t, '}"'));
    }
    return {
        type: "Character",
        value: e
    };
}
function C(e) {
    const r = {
        kind: "union",
        negate: !1,
        ...e
    };
    return {
        type: "CharacterClass",
        kind: r.kind,
        negate: r.negate,
        body: V(e === null || e === void 0 ? void 0 : e.body)
    };
}
function L(e, r) {
    if (r.value < e.value) throw new Error("Character class range out of order");
    return {
        type: "CharacterClassRange",
        min: e,
        max: r
    };
}
function E(e, r) {
    const n = !!(r === null || r === void 0 ? void 0 : r.negate), t = {
        type: "CharacterSet",
        kind: e
    };
    return (e === "digit" || e === "hex" || e === "newline" || e === "space" || e === "word") && (t.negate = n), (e === "text_segment" || e === "newline" && !n) && (t.variableLength = !0), t;
}
function I(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (e === "keep") return {
        type: "Directive",
        kind: e
    };
    if (e === "flags") return {
        type: "Directive",
        kind: e,
        flags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])(r.flags)
    };
    throw new Error('Unexpected directive kind "'.concat(e, '"'));
}
function T(e) {
    return {
        type: "Flags",
        ...e
    };
}
function A(e) {
    const r = e === null || e === void 0 ? void 0 : e.atomic, n = e === null || e === void 0 ? void 0 : e.flags;
    if (r && n) throw new Error("Atomic group cannot have flags");
    return {
        type: "Group",
        ...r && {
            atomic: r
        },
        ...n && {
            flags: n
        },
        body: h(e === null || e === void 0 ? void 0 : e.body)
    };
}
function K(e) {
    const r = {
        behind: !1,
        negate: !1,
        ...e
    };
    return {
        type: "LookaroundAssertion",
        kind: r.behind ? "lookbehind" : "lookahead",
        negate: r.negate,
        body: h(e === null || e === void 0 ? void 0 : e.body)
    };
}
function U(e, r, n) {
    return {
        type: "NamedCallout",
        kind: e,
        tag: r,
        arguments: n
    };
}
function R(e, r) {
    const n = !!(r === null || r === void 0 ? void 0 : r.negate);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PosixClassNames"].has(e)) throw new Error('Invalid POSIX class "'.concat(e, '"'));
    return {
        type: "CharacterSet",
        kind: "posix",
        value: e,
        negate: n
    };
}
function _(e, r, n, t) {
    if (r > n) throw new Error("Invalid reversed quantifier range");
    return {
        type: "Quantifier",
        kind: e,
        min: r,
        max: n,
        body: t
    };
}
function B(e, r) {
    return {
        type: "Regex",
        body: h(r === null || r === void 0 ? void 0 : r.body),
        flags: e
    };
}
function O(e) {
    return {
        type: "Subroutine",
        ref: e
    };
}
function Q(e, r) {
    var _n_unicodePropertyMap;
    const n = {
        negate: !1,
        normalizeUnknownPropertyNames: !1,
        skipPropertyNameValidation: !1,
        unicodePropertyMap: null,
        ...r
    };
    let t = (_n_unicodePropertyMap = n.unicodePropertyMap) === null || _n_unicodePropertyMap === void 0 ? void 0 : _n_unicodePropertyMap.get(w(e));
    if (!t) {
        if (n.normalizeUnknownPropertyNames) t = de(e);
        else if (n.unicodePropertyMap && !n.skipPropertyNameValidation) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(_templateObject4(), e));
    }
    return {
        type: "CharacterSet",
        kind: "property",
        value: t !== null && t !== void 0 ? t : e,
        negate: n.negate
    };
}
function ie(param) {
    let { flags: e, kind: r, name: n, negate: t, number: s } = param;
    switch(r){
        case "absence_repeater":
            return G("repeater");
        case "atomic":
            return A({
                atomic: !0
            });
        case "capturing":
            return P(s, {
                name: n
            });
        case "group":
            return A({
                flags: e
            });
        case "lookahead":
        case "lookbehind":
            return K({
                behind: r === "lookbehind",
                negate: t
            });
        default:
            throw new Error('Unexpected group kind "'.concat(r, '"'));
    }
}
function h(e) {
    if (e === void 0) e = [
        b()
    ];
    else if (!Array.isArray(e) || !e.length || !e.every((r)=>r.type === "Alternative")) throw new Error("Invalid body; expected array of one or more Alternative nodes");
    return e;
}
function V(e) {
    if (e === void 0) e = [];
    else if (!Array.isArray(e) || !e.every((r)=>!!r.type)) throw new Error("Invalid body; expected array of nodes");
    return e;
}
function M(e) {
    return e.type === "LookaroundAssertion" && e.kind === "lookahead";
}
function $(e) {
    return e.type === "LookaroundAssertion" && e.kind === "lookbehind";
}
function se(e) {
    return RegExp("^[\\p{Alpha}\\p{Pc}][^)]*$", "u").test(e);
}
function de(e) {
    return e.trim().replace(/[- _]+/g, "_").replace(/[A-Z][a-z]+(?=[A-Z])/g, "$&_").replace(/[A-Za-z]+/g, (r)=>r[0].toUpperCase() + r.slice(1).toLowerCase());
}
function w(e) {
    return e.replace(/[- _]+/g, "").toLowerCase();
}
function z(e, r) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])(e, "".concat((r === null || r === void 0 ? void 0 : r.type) === "Character" && r.value === 93 ? "Empty" : "Unclosed", " character class"));
}
function D(e) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])(e, "Unclosed group");
}
;
 //# sourceMappingURL=parse.js.map
}),
"[project]/node_modules/oniguruma-parser/dist/traverser/traverse.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "traverse",
    ()=>S
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/utils.js [app-client] (ecmascript)");
"use strict";
;
function S(a, v) {
    let N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    function u(e, s) {
        for(let t = 0; t < e.length; t++){
            const r = n(e[t], s, t, e);
            t = Math.max(-1, t + r);
        }
    }
    function n(e) {
        let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        var _p_exit, _h_exit;
        let i = 0, c = !1;
        const d = {
            node: e,
            parent: s,
            key: t,
            container: r,
            root: a,
            remove () {
                f(r).splice(Math.max(0, l(t) + i), 1), i--, c = !0;
            },
            removeAllNextSiblings () {
                return f(r).splice(l(t) + 1);
            },
            removeAllPrevSiblings () {
                const o = l(t) + i;
                return i -= o, f(r).splice(0, Math.max(0, o));
            },
            replaceWith (o) {
                let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const b = !!y.traverse;
                r ? r[Math.max(0, l(t) + i)] = o : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwIfNullish"])(s, "Can't replace root node")[t] = o, b && n(o, s, t, r), c = !0;
            },
            replaceWithMultiple (o) {
                let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const b = !!y.traverse;
                if (f(r).splice(Math.max(0, l(t) + i), 1, ...o), i += o.length - 1, b) {
                    let g = 0;
                    for(let x = 0; x < o.length; x++)g += n(o[x], s, l(t) + x + g, r);
                }
                c = !0;
            },
            skip () {
                c = !0;
            }
        }, { type: m } = e, h = v["*"], p = v[m], R = typeof h == "function" ? h : h === null || h === void 0 ? void 0 : h.enter, P = typeof p == "function" ? p : p === null || p === void 0 ? void 0 : p.enter;
        if (R === null || R === void 0 ? void 0 : R(d, N), P === null || P === void 0 ? void 0 : P(d, N), !c) switch(m){
            case "AbsenceFunction":
            case "CapturingGroup":
            case "Group":
                u(e.body, e);
                break;
            case "Alternative":
            case "CharacterClass":
                u(e.body, e);
                break;
            case "Assertion":
            case "Backreference":
            case "Character":
            case "CharacterSet":
            case "Directive":
            case "Flags":
            case "NamedCallout":
            case "Subroutine":
                break;
            case "CharacterClassRange":
                n(e.min, e, "min"), n(e.max, e, "max");
                break;
            case "LookaroundAssertion":
                u(e.body, e);
                break;
            case "Quantifier":
                n(e.body, e, "body");
                break;
            case "Regex":
                u(e.body, e), n(e.flags, e, "flags");
                break;
            default:
                throw new Error('Unexpected node type "'.concat(m, '"'));
        }
        return p === null || p === void 0 ? void 0 : (_p_exit = p.exit) === null || _p_exit === void 0 ? void 0 : _p_exit.call(p, d, N), h === null || h === void 0 ? void 0 : (_h_exit = h.exit) === null || _h_exit === void 0 ? void 0 : _h_exit.call(h, d, N), i;
    }
    return n(a), a;
}
function f(a) {
    if (!Array.isArray(a)) throw new Error("Container expected");
    return a;
}
function l(a) {
    if (typeof a != "number") throw new Error("Numeric key expected");
    return a;
}
;
 //# sourceMappingURL=traverse.js.map
}),
"[project]/node_modules/regex/src/utils-internals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Separating some utils for improved tree shaking of the `./internals` export
__turbopack_context__.s([
    "incrementIfAtLeast",
    ()=>incrementIfAtLeast,
    "noncapturingDelim",
    ()=>noncapturingDelim,
    "spliceStr",
    ()=>spliceStr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?(?:[:=!>A-Za-z-]|<[=!]|(DEFINE))"
    ], [
        "\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))"
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
const noncapturingDelim = String.raw(_templateObject());
/**
Updates the array in place by incrementing each value greater than or equal to the threshold.
@param {Array<number>} arr
@param {number} threshold
*/ function incrementIfAtLeast(arr, threshold) {
    for(let i = 0; i < arr.length; i++){
        if (arr[i] >= threshold) {
            arr[i]++;
        }
    }
}
/**
@param {string} str
@param {number} pos
@param {string} oldValue
@param {string} newValue
@returns {string}
*/ function spliceStr(str, pos, oldValue, newValue) {
    return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);
}
;
}),
"[project]/node_modules/regex-utilities/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Constant properties for tracking regex syntax context
__turbopack_context__.s([
    "Context",
    ()=>Context,
    "execUnescaped",
    ()=>execUnescaped,
    "forEachUnescaped",
    ()=>forEachUnescaped,
    "getGroupContents",
    ()=>getGroupContents,
    "hasUnescaped",
    ()=>hasUnescaped,
    "replaceUnescaped",
    ()=>replaceUnescaped
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "",
        "|(?<$skip>[^?|\\?.)"
    ], [
        "",
        "|(?<$skip>\\[\\^?|\\\\?.)"
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
const Context = Object.freeze({
    DEFAULT: 'DEFAULT',
    CHAR_CLASS: 'CHAR_CLASS'
});
function replaceUnescaped(expression, needle, replacement, context) {
    const re = new RegExp(String.raw(_templateObject(), needle), 'gsu');
    const negated = [
        false
    ];
    let numCharClassesOpen = 0;
    let result = '';
    for (const match of expression.matchAll(re)){
        const { 0: m, groups: { $skip } } = match;
        if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {
            if (replacement instanceof Function) {
                result += replacement(match, {
                    context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,
                    negated: negated[negated.length - 1]
                });
            } else {
                result += replacement;
            }
            continue;
        }
        if (m[0] === '[') {
            numCharClassesOpen++;
            negated.push(m[1] === '^');
        } else if (m === ']' && numCharClassesOpen) {
            numCharClassesOpen--;
            negated.pop();
        }
        result += m;
    }
    return result;
}
function forEachUnescaped(expression, needle, callback, context) {
    // Do this the easy way
    replaceUnescaped(expression, needle, callback, context);
}
function execUnescaped(expression, needle) {
    let pos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, context = arguments.length > 3 ? arguments[3] : void 0;
    // Quick partial test; avoid the loop if not needed
    if (!new RegExp(needle, 'su').test(expression)) {
        return null;
    }
    const re = new RegExp("".concat(needle, "|(?<$skip>\\\\?.)"), 'gsu');
    re.lastIndex = pos;
    let numCharClassesOpen = 0;
    let match;
    while(match = re.exec(expression)){
        const { 0: m, groups: { $skip } } = match;
        if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {
            return match;
        }
        if (m === '[') {
            numCharClassesOpen++;
        } else if (m === ']' && numCharClassesOpen) {
            numCharClassesOpen--;
        }
        // Avoid an infinite loop on zero-length matches
        if (re.lastIndex == match.index) {
            re.lastIndex++;
        }
    }
    return null;
}
function hasUnescaped(expression, needle, context) {
    // Do this the easy way
    return !!execUnescaped(expression, needle, 0, context);
}
function getGroupContents(expression, contentsStartPos) {
    const token = RegExp("\\\\?.", "gsu");
    token.lastIndex = contentsStartPos;
    let contentsEndPos = expression.length;
    let numCharClassesOpen = 0;
    // Starting search within an open group, after the group's opening
    let numGroupsOpen = 1;
    let match;
    while(match = token.exec(expression)){
        const [m] = match;
        if (m === '[') {
            numCharClassesOpen++;
        } else if (!numCharClassesOpen) {
            if (m === '(') {
                numGroupsOpen++;
            } else if (m === ')') {
                numGroupsOpen--;
                if (!numGroupsOpen) {
                    contentsEndPos = match.index;
                    break;
                }
            }
        } else if (m === ']') {
            numCharClassesOpen--;
        }
    }
    return expression.slice(contentsStartPos, contentsEndPos);
}
}),
"[project]/node_modules/regex/src/atomic.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "atomic",
    ()=>atomic,
    "possessive",
    ()=>possessive
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$utils$2d$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex/src/utils-internals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex-utilities/src/index.js [app-client] (ecmascript)");
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?<noncapturingStart>",
        ")|(?<capturingStart>((?:?<[^>]+>)?)|\\?."
    ], [
        "(?<noncapturingStart>",
        ")|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?."
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\\(?<backrefNum>[1-9]d*)|<$$(?<wrappedBackrefNum>d+)>"
    ], [
        "\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>"
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?:[?*+]|{d+(?:,d*)?})"
    ], [
        "(?:[?*+]|\\{\\d+(?:,\\d*)?\\})"
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\n\\(?: d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]{[^}]+}\n  | u[A-Fa-fd]{4}\n  | x[A-Fa-fd]{2}\n  )\n| ((?: ? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z-]+:\n  | (DEFINE)\n  ))?\n| (?<qBase>",
        ")(?<qMod>[?+]?)(?<invalidQ>[?*+{]?)\n| \\?.\n"
    ], [
        "\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>",
        ")(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n"
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
;
;
const atomicPluginToken = new RegExp(String.raw(_templateObject(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$utils$2d$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noncapturingDelim"]), 'gsu');
/**
Apply transformations for atomic groups: `(?>)`.
@param {string} expression
@param {import('./regex.js').PluginData} [data]
@returns {Required<import('./regex.js').PluginResult>}
*/ function atomic(expression, data) {
    var _data_hiddenCaptures;
    const hiddenCaptures = (_data_hiddenCaptures = data === null || data === void 0 ? void 0 : data.hiddenCaptures) !== null && _data_hiddenCaptures !== void 0 ? _data_hiddenCaptures : [];
    var _data_captureTransfers;
    // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>
    let captureTransfers = (_data_captureTransfers = data === null || data === void 0 ? void 0 : data.captureTransfers) !== null && _data_captureTransfers !== void 0 ? _data_captureTransfers : new Map();
    if (!/\(\?>/.test(expression)) {
        return {
            pattern: expression,
            captureTransfers,
            hiddenCaptures
        };
    }
    const aGDelim = '(?>';
    const emulatedAGDelim = '(?:(?=(';
    const captureNumMap = [
        0
    ];
    const addedHiddenCaptures = [];
    let numCapturesBeforeAG = 0;
    let numAGs = 0;
    let aGPos = NaN;
    let hasProcessedAG;
    do {
        hasProcessedAG = false;
        let numCharClassesOpen = 0;
        let numGroupsOpenInAG = 0;
        let inAG = false;
        let match;
        atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;
        while(match = atomicPluginToken.exec(expression)){
            const { 0: m, index, groups: { capturingStart, noncapturingStart } } = match;
            if (m === '[') {
                numCharClassesOpen++;
            } else if (!numCharClassesOpen) {
                if (m === aGDelim && !inAG) {
                    aGPos = index;
                    inAG = true;
                } else if (inAG && noncapturingStart) {
                    numGroupsOpenInAG++;
                } else if (capturingStart) {
                    if (inAG) {
                        numGroupsOpenInAG++;
                    } else {
                        numCapturesBeforeAG++;
                        captureNumMap.push(numCapturesBeforeAG + numAGs);
                    }
                } else if (m === ')' && inAG) {
                    if (!numGroupsOpenInAG) {
                        numAGs++;
                        const addedCaptureNum = numCapturesBeforeAG + numAGs;
                        // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it
                        // can avoid backref renumbering afterward. Wrap the whole substitution (including the
                        // lookahead and following backref) in a noncapturing group to handle following
                        // quantifiers and literal digits
                        expression = "".concat(expression.slice(0, aGPos)).concat(emulatedAGDelim).concat(expression.slice(aGPos + aGDelim.length, index), "))<$$").concat(addedCaptureNum, ">)").concat(expression.slice(index + 1));
                        hasProcessedAG = true;
                        addedHiddenCaptures.push(addedCaptureNum);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$utils$2d$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["incrementIfAtLeast"])(hiddenCaptures, addedCaptureNum);
                        if (captureTransfers.size) {
                            const newCaptureTransfers = new Map();
                            captureTransfers.forEach((from, to)=>{
                                newCaptureTransfers.set(to >= addedCaptureNum ? to + 1 : to, from.map((f)=>f >= addedCaptureNum ? f + 1 : f));
                            });
                            captureTransfers = newCaptureTransfers;
                        }
                        break;
                    }
                    numGroupsOpenInAG--;
                }
            } else if (m === ']') {
                numCharClassesOpen--;
            }
        }
    // Start over from the beginning of the atomic group's contents, in case the processed group
    // contains additional atomic groups
    }while (hasProcessedAG)
    hiddenCaptures.push(...addedHiddenCaptures);
    // Second pass to adjust numbered backrefs
    expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceUnescaped"])(expression, String.raw(_templateObject1()), (param)=>{
        let { 0: m, groups: { backrefNum, wrappedBackrefNum } } = param;
        if (backrefNum) {
            const bNum = +backrefNum;
            if (bNum > captureNumMap.length - 1) {
                throw new Error('Backref "'.concat(m, '" greater than number of captures'));
            }
            return "\\".concat(captureNumMap[bNum]);
        }
        return "\\".concat(wrappedBackrefNum);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT);
    return {
        pattern: expression,
        captureTransfers,
        hiddenCaptures
    };
}
const baseQuantifier = String.raw(_templateObject2());
// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax
const possessivePluginToken = new RegExp(String.raw(_templateObject3(), baseQuantifier).replace(/\s+/g, ''), 'gsu');
/**
Transform posessive quantifiers into atomic groups. The posessessive quantifiers are:
`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.
This follows Java, PCRE, Perl, and Python.
Possessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.
@param {string} expression
@returns {import('./regex.js').PluginResult}
*/ function possessive(expression) {
    if (!new RegExp("".concat(baseQuantifier, "\\+")).test(expression)) {
        return {
            pattern: expression
        };
    }
    const openGroupIndices = [];
    let lastGroupIndex = null;
    let lastCharClassIndex = null;
    let lastToken = '';
    let numCharClassesOpen = 0;
    let match;
    possessivePluginToken.lastIndex = 0;
    while(match = possessivePluginToken.exec(expression)){
        const { 0: m, index, groups: { qBase, qMod, invalidQ } } = match;
        if (m === '[') {
            if (!numCharClassesOpen) {
                lastCharClassIndex = index;
            }
            numCharClassesOpen++;
        } else if (m === ']') {
            if (numCharClassesOpen) {
                numCharClassesOpen--;
            // Unmatched `]`
            } else {
                lastCharClassIndex = null;
            }
        } else if (!numCharClassesOpen) {
            if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {
                // Invalid following quantifier would become valid via the wrapping group
                if (invalidQ) {
                    throw new Error('Invalid quantifier "'.concat(m, '"'));
                }
                let charsAdded = -1; // -1 for removed trailing `+`
                // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so
                // avoid doing so (convert them to greedy)
                if (/^\{\d+\}$/.test(qBase)) {
                    expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$utils$2d$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spliceStr"])(expression, index + qBase.length, qMod, '');
                } else {
                    if (lastToken === ')' || lastToken === ']') {
                        const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;
                        // Unmatched `)` would break out of the wrapping group and mess with handling.
                        // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support
                        // for unescaped `]++` since this won't work with flag u or v anyway
                        if (nodeIndex === null) {
                            throw new Error('Invalid unmatched "'.concat(lastToken, '"'));
                        }
                        expression = "".concat(expression.slice(0, nodeIndex), "(?>").concat(expression.slice(nodeIndex, index)).concat(qBase, ")").concat(expression.slice(index + m.length));
                    } else {
                        expression = "".concat(expression.slice(0, index - lastToken.length), "(?>").concat(lastToken).concat(qBase, ")").concat(expression.slice(index + m.length));
                    }
                    charsAdded += 4; // `(?>)`
                }
                possessivePluginToken.lastIndex += charsAdded;
            } else if (m[0] === '(') {
                openGroupIndices.push(index);
            } else if (m === ')') {
                lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;
            }
        }
        lastToken = m;
    }
    return {
        pattern: expression
    };
}
;
}),
"[project]/node_modules/regex/src/subclass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
Works the same as JavaScript's native `RegExp` constructor in all contexts, but automatically
adjusts subpattern matches and indices (with flag `d`) to account for captures added as part of
emulating extended syntax.
*/ __turbopack_context__.s([
    "RegExpSubclass",
    ()=>RegExpSubclass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
class RegExpSubclass extends RegExp {
    /**
  Called internally by all String/RegExp methods that use regexes.
  @override
  @param {string} str
  @returns {RegExpExecArray | null}
  */ exec(str) {
        const match = super.exec(str);
        if (!match || !this._captureMap.size) {
            return match;
        }
        const matchCopy = [
            ...match
        ];
        // Empty all but the first value of the array while preserving its other properties
        match.length = 1;
        let indicesCopy;
        if (this.hasIndices) {
            indicesCopy = [
                ...match.indices
            ];
            match.indices.length = 1;
        }
        for(let i = 1; i < matchCopy.length; i++){
            var _this__captureMap_get;
            if (!((_this__captureMap_get = this._captureMap.get(i)) === null || _this__captureMap_get === void 0 ? void 0 : _this__captureMap_get.hidden)) {
                match.push(matchCopy[i]);
                if (this.hasIndices) {
                    match.indices.push(indicesCopy[i]);
                }
            }
        }
        return match;
    }
    /**
  @overload
  @param {string} expression
  @param {string} [flags]
  @param {{
    hiddenCaptures?: Array<number>;
  }} [options]
  */ /**
  @overload
  @param {RegExpSubclass} expression
  @param {string} [flags]
  */ constructor(expression, flags, options){
        // Argument `options` isn't provided when regexes are copied via `new RegExpSubclass(regexp)`,
        // including as part of the internal handling of string methods `matchAll` and `split`
        if (expression instanceof RegExp) {
            if (options) {
                throw new Error('Cannot provide options when copying a regexp');
            }
            super(expression, flags), // Avoid `#private` to allow for subclassing
            /**
  @private
  @type {Map<number, {
    hidden: true;
  }>}
  */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_captureMap", void 0);
            if (expression instanceof RegExpSubclass) {
                this._captureMap = expression._captureMap;
            } else {
                this._captureMap = new Map();
            }
        } else {
            super(expression, flags), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_captureMap", void 0);
            var _options_hiddenCaptures;
            const hiddenCaptures = (_options_hiddenCaptures = options === null || options === void 0 ? void 0 : options.hiddenCaptures) !== null && _options_hiddenCaptures !== void 0 ? _options_hiddenCaptures : [];
            this._captureMap = createCaptureMap(hiddenCaptures);
        }
    }
}
/**
Build the capturing group map, with hidden captures marked to indicate their submatches shouldn't
appear in match results.
@param {Array<number>} hiddenCaptures
@returns {Map<number, {
  hidden: true;
}>}
*/ function createCaptureMap(hiddenCaptures) {
    const captureMap = new Map();
    for (const num of hiddenCaptures){
        captureMap.set(num, {
            hidden: true
        });
    }
    return captureMap;
}
;
}),
"[project]/node_modules/regex/src/internals.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$atomic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex/src/atomic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$subclass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex/src/subclass.js [app-client] (ecmascript)");
;
;
}),
"[project]/node_modules/regex-recursion/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "recursion",
    ()=>recursion
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex-utilities/src/index.js [app-client] (ecmascript)");
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>"
    ], [
        "\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>"
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?R=(?<rDepth>[^)]+))|",
        ""
    ], [
        "\\(\\?R=(?<rDepth>[^\\)]+)\\)|",
        ""
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?<(?![=!])(?<captureName>[^>]+)>"
    ], [
        "\\(\\?<(?![=!])(?<captureName>[^>]+)>"
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "",
        "|(?<unnamed>()(?!?)"
    ], [
        "",
        "|(?<unnamed>\\()(?!\\?)"
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
function _templateObject4() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "",
        "|",
        "|(?|\\?."
    ], [
        "",
        "|",
        "|\\(\\?|\\\\?."
    ]);
    _templateObject4 = function() {
        return data;
    };
    return data;
}
function _templateObject5() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?(DEFINE)"
    ], [
        "\\(\\?\\(DEFINE\\)"
    ]);
    _templateObject5 = function() {
        return data;
    };
    return data;
}
function _templateObject6() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\\[1-9]"
    ], [
        "\\\\[1-9]"
    ]);
    _templateObject6 = function() {
        return data;
    };
    return data;
}
function _templateObject7() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "g<",
        "&R=",
        ">"
    ], [
        "\\g<",
        "&R=",
        ">"
    ]);
    _templateObject7 = function() {
        return data;
    };
    return data;
}
function _templateObject8() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Recursive g cannot be used outside the referenced group "',
        '"'
    ], [
        'Recursive \\g cannot be used outside the referenced group "',
        '"'
    ]);
    _templateObject8 = function() {
        return data;
    };
    return data;
}
function _templateObject9() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "",
        "|((?!?)"
    ], [
        "",
        "|\\((?!\\?)"
    ]);
    _templateObject9 = function() {
        return data;
    };
    return data;
}
function _templateObject10() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "",
        "|\\k<(?<backref>[^>]+)>"
    ], [
        "",
        "|\\\\k<(?<backref>[^>]+)>"
    ]);
    _templateObject10 = function() {
        return data;
    };
    return data;
}
function _templateObject11() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "k<",
        "",
        ">"
    ], [
        "\\k<",
        "",
        ">"
    ]);
    _templateObject11 = function() {
        return data;
    };
    return data;
}
;
const r = String.raw;
const gRToken = r(_templateObject());
const recursiveToken = r(_templateObject1(), gRToken);
const namedCaptureDelim = r(_templateObject2());
const captureDelim = r(_templateObject3(), namedCaptureDelim);
const token = new RegExp(r(_templateObject4(), namedCaptureDelim, recursiveToken), 'gsu');
const overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';
/**
@param {string} pattern
@param {{
  flags?: string;
  captureTransfers?: Map<number, Array<number>>;
  hiddenCaptures?: Array<number>;
  mode?: 'plugin' | 'external';
}} [data]
@returns {{
  pattern: string;
  captureTransfers: Map<number, Array<number>>;
  hiddenCaptures: Array<number>;
}}
*/ function recursion(pattern, data) {
    const { hiddenCaptures, mode } = {
        hiddenCaptures: [],
        mode: 'plugin',
        ...data
    };
    var _data_captureTransfers;
    // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>
    let captureTransfers = (_data_captureTransfers = data === null || data === void 0 ? void 0 : data.captureTransfers) !== null && _data_captureTransfers !== void 0 ? _data_captureTransfers : new Map();
    // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing
    // without the accuracy improvement of using `hasUnescaped` with `Context.DEFAULT`
    if (!new RegExp(recursiveToken, 'su').test(pattern)) {
        return {
            pattern,
            captureTransfers,
            hiddenCaptures
        };
    }
    if (mode === 'plugin' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasUnescaped"])(pattern, r(_templateObject5()), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT)) {
        throw new Error('DEFINE groups cannot be used with recursion');
    }
    const addedHiddenCaptures = [];
    const hasNumberedBackref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasUnescaped"])(pattern, r(_templateObject6()), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT);
    const groupContentsStartPos = new Map();
    const openGroups = [];
    let hasRecursed = false;
    let numCharClassesOpen = 0;
    let numCapturesPassed = 0;
    let match;
    token.lastIndex = 0;
    while(match = token.exec(pattern)){
        const { 0: m, groups: { captureName, rDepth, gRNameOrNum, gRDepth } } = match;
        if (m === '[') {
            numCharClassesOpen++;
        } else if (!numCharClassesOpen) {
            // `(?R=N)`
            if (rDepth) {
                assertMaxInBounds(rDepth);
                if (hasRecursed) {
                    throw new Error(overlappingRecursionMsg);
                }
                if (hasNumberedBackref) {
                    // Could add support for numbered backrefs with extra effort, but it's probably not worth
                    // it. To trigger this error, the regex must include recursion and one of the following:
                    // - An interpolated regex that contains a numbered backref (since other numbered
                    //   backrefs are prevented by implicit flag n).
                    // - A numbered backref, when flag n is explicitly disabled.
                    // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also
                    // add numbered backrefs, but those work fine because external plugins like this one run
                    // *before* the transformation of built-in syntax extensions
                    throw new Error(// When used in `external` mode by transpilers other than Regex+, backrefs might have
                    // gone through conversion from named to numbered, so avoid a misleading error
                    "".concat(mode === 'external' ? 'Backrefs' : 'Numbered backrefs', " cannot be used with global recursion"));
                }
                const left = pattern.slice(0, match.index);
                const right = pattern.slice(token.lastIndex);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasUnescaped"])(right, recursiveToken, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT)) {
                    throw new Error(overlappingRecursionMsg);
                }
                const reps = +rDepth - 1;
                pattern = makeRecursive(left, right, reps, false, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);
                captureTransfers = mapCaptureTransfers(captureTransfers, left, reps, addedHiddenCaptures.length, 0, numCapturesPassed);
                break;
            // `\g<name&R=N>`, `\g<number&R=N>`
            } else if (gRNameOrNum) {
                assertMaxInBounds(gRDepth);
                let isWithinReffedGroup = false;
                for (const g of openGroups){
                    if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {
                        isWithinReffedGroup = true;
                        if (g.hasRecursedWithin) {
                            throw new Error(overlappingRecursionMsg);
                        }
                        break;
                    }
                }
                if (!isWithinReffedGroup) {
                    throw new Error(r(_templateObject8(), mode === 'external' ? gRNameOrNum : r(_templateObject7(), gRNameOrNum, gRDepth)));
                }
                const startPos = groupContentsStartPos.get(gRNameOrNum);
                const groupContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGroupContents"])(pattern, startPos);
                if (hasNumberedBackref && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasUnescaped"])(groupContents, r(_templateObject9(), namedCaptureDelim), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT)) {
                    throw new Error(// When used in `external` mode by transpilers other than Regex+, backrefs might have
                    // gone through conversion from named to numbered, so avoid a misleading error
                    "".concat(mode === 'external' ? 'Backrefs' : 'Numbered backrefs', " cannot be used with recursion of capturing groups"));
                }
                const groupContentsLeft = pattern.slice(startPos, match.index);
                const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);
                const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;
                const reps = +gRDepth - 1;
                const expansion = makeRecursive(groupContentsLeft, groupContentsRight, reps, true, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);
                captureTransfers = mapCaptureTransfers(captureTransfers, groupContentsLeft, reps, addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed);
                const pre = pattern.slice(0, startPos);
                const post = pattern.slice(startPos + groupContents.length);
                // Modify the string we're looping over
                pattern = "".concat(pre).concat(expansion).concat(post);
                // Step forward for the next loop iteration
                token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;
                openGroups.forEach((g)=>g.hasRecursedWithin = true);
                hasRecursed = true;
            } else if (captureName) {
                numCapturesPassed++;
                groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
                groupContentsStartPos.set(captureName, token.lastIndex);
                openGroups.push({
                    num: numCapturesPassed,
                    name: captureName
                });
            } else if (m[0] === '(') {
                const isUnnamedCapture = m === '(';
                if (isUnnamedCapture) {
                    numCapturesPassed++;
                    groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
                }
                openGroups.push(isUnnamedCapture ? {
                    num: numCapturesPassed
                } : {});
            } else if (m === ')') {
                openGroups.pop();
            }
        } else if (m === ']') {
            numCharClassesOpen--;
        }
    }
    hiddenCaptures.push(...addedHiddenCaptures);
    return {
        pattern,
        captureTransfers,
        hiddenCaptures
    };
}
/**
@param {string} max
*/ function assertMaxInBounds(max) {
    const errMsg = "Max depth must be integer between 2 and 100; used ".concat(max);
    if (!/^[1-9]\d*$/.test(max)) {
        throw new Error(errMsg);
    }
    max = +max;
    if (max < 2 || max > 100) {
        throw new Error(errMsg);
    }
}
/**
@param {string} left
@param {string} right
@param {number} reps
@param {boolean} isSubpattern
@param {Array<number>} hiddenCaptures
@param {Array<number>} addedHiddenCaptures
@param {number} numCapturesPassed
@returns {string}
*/ function makeRecursive(left, right, reps, isSubpattern, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
    const namesInRecursed = new Set();
    // Can skip this work if not needed
    if (isSubpattern) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEachUnescaped"])(left + right, namedCaptureDelim, (param)=>{
            let { groups: { captureName } } = param;
            namesInRecursed.add(captureName);
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT);
    }
    const rest = [
        reps,
        isSubpattern ? namesInRecursed : null,
        hiddenCaptures,
        addedHiddenCaptures,
        numCapturesPassed
    ];
    // Depth 2: 'left(?:left(?:)right)right'
    // Depth 3: 'left(?:left(?:left(?:)right)right)right'
    // Empty group in the middle separates tokens and absorbs a following quantifier if present
    return "".concat(left).concat(repeatWithDepth("(?:".concat(left), 'forward', ...rest), "(?:)").concat(repeatWithDepth("".concat(right, ")"), 'backward', ...rest)).concat(right);
}
/**
@param {string} pattern
@param {'forward' | 'backward'} direction
@param {number} reps
@param {Set<string> | null} namesInRecursed
@param {Array<number>} hiddenCaptures
@param {Array<number>} addedHiddenCaptures
@param {number} numCapturesPassed
@returns {string}
*/ function repeatWithDepth(pattern, direction, reps, namesInRecursed, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
    const startNum = 2;
    const getDepthNum = (i)=>direction === 'forward' ? i + startNum : reps - i + startNum - 1;
    let result = '';
    for(let i = 0; i < reps; i++){
        const depthNum = getDepthNum(i);
        result += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceUnescaped"])(pattern, r(_templateObject10(), captureDelim), (param)=>{
            let { 0: m, groups: { captureName, unnamed, backref } } = param;
            if (backref && namesInRecursed && !namesInRecursed.has(backref)) {
                // Don't alter backrefs to groups outside the recursed subpattern
                return m;
            }
            const suffix = "_$".concat(depthNum);
            if (unnamed || captureName) {
                const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;
                addedHiddenCaptures.push(addedCaptureNum);
                incrementIfAtLeast(hiddenCaptures, addedCaptureNum);
                return unnamed ? m : "(?<".concat(captureName).concat(suffix, ">");
            }
            return r(_templateObject11(), backref, suffix);
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT);
    }
    return result;
}
/**
Updates the array in place by incrementing each value greater than or equal to the threshold.
@param {Array<number>} arr
@param {number} threshold
*/ function incrementIfAtLeast(arr, threshold) {
    for(let i = 0; i < arr.length; i++){
        if (arr[i] >= threshold) {
            arr[i]++;
        }
    }
}
/**
@param {Map<number, Array<number>>} captureTransfers
@param {string} left
@param {number} reps
@param {number} numCapturesAddedInExpansion
@param {number} numAddedHiddenCapturesPreExpansion
@param {number} numCapturesPassed
@returns {Map<number, Array<number>>}
*/ function mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {
    if (captureTransfers.size && numCapturesAddedInExpansion) {
        let numCapturesInLeft = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEachUnescaped"])(left, captureDelim, ()=>numCapturesInLeft++, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$utilities$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"].DEFAULT);
        // Is 0 for global recursion
        const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;
        const newCaptureTransfers = new Map();
        captureTransfers.forEach((from, to)=>{
            const numCapturesInRight = (numCapturesAddedInExpansion - numCapturesInLeft * reps) / reps;
            const numCapturesAddedInLeft = numCapturesInLeft * reps;
            const newTo = to > recursionDelimCaptureNum + numCapturesInLeft ? to + numCapturesAddedInExpansion : to;
            const newFrom = [];
            for (const f of from){
                // Before the recursed subpattern
                if (f <= recursionDelimCaptureNum) {
                    newFrom.push(f);
                // After the recursed subpattern
                } else if (f > recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight) {
                    newFrom.push(f + numCapturesAddedInExpansion);
                // Within the recursed subpattern, on the left of the recursion token
                } else if (f <= recursionDelimCaptureNum + numCapturesInLeft) {
                    for(let i = 0; i <= reps; i++){
                        newFrom.push(f + numCapturesInLeft * i);
                    }
                // Within the recursed subpattern, on the right of the recursion token
                } else {
                    for(let i = 0; i <= reps; i++){
                        newFrom.push(f + numCapturesAddedInLeft + numCapturesInRight * i);
                    }
                }
            }
            newCaptureTransfers.set(newTo, newFrom);
        });
        return newCaptureTransfers;
    }
    return captureTransfers;
}
;
}),
"[project]/node_modules/oniguruma-to-es/dist/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils.js
__turbopack_context__.s([
    "EmulatedRegExp",
    ()=>EmulatedRegExp,
    "toRegExp",
    ()=>toRegExp,
    "toRegExpDetails",
    ()=>toRegExpDetails
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_private_field_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_private_field_init.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_private_field_set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_private_method_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_private_method_init.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_tagged_template_literal.js [app-client] (ecmascript)");
// src/unicode.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/parser/parse.js [app-client] (ecmascript) <locals>");
// src/transform.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$node$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/parser/node-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-parser/dist/traverser/traverse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/regex/src/internals.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$atomic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex/src/atomic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$recursion$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/regex-recursion/src/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
function _templateObject() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[d-a]"
    ], [
        "[\\d\\-a]"
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[p{L}p{M}p{N}p{Pc}]"
    ], [
        "[\\p{L}\\p{M}\\p{N}\\p{Pc}]"
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[p{Alpha}p{Nd}]"
    ], [
        "[\\p{Alpha}\\p{Nd}]"
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{Alpha}"
    ], [
        "\\p{Alpha}"
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
function _templateObject4() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{ASCII}"
    ], [
        "\\p{ASCII}"
    ]);
    _templateObject4 = function() {
        return data;
    };
    return data;
}
function _templateObject5() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[p{Zs}	]"
    ], [
        "[\\p{Zs}\\t]"
    ]);
    _templateObject5 = function() {
        return data;
    };
    return data;
}
function _templateObject6() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{Cc}"
    ], [
        "\\p{Cc}"
    ]);
    _templateObject6 = function() {
        return data;
    };
    return data;
}
function _templateObject7() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{Nd}"
    ], [
        "\\p{Nd}"
    ]);
    _templateObject7 = function() {
        return data;
    };
    return data;
}
function _templateObject8() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[P{space}&&P{Cc}&&P{Cn}&&P{Cs}]"
    ], [
        "[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]"
    ]);
    _templateObject8 = function() {
        return data;
    };
    return data;
}
function _templateObject9() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{Lower}"
    ], [
        "\\p{Lower}"
    ]);
    _templateObject9 = function() {
        return data;
    };
    return data;
}
function _templateObject10() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[[P{space}&&P{Cc}&&P{Cn}&&P{Cs}]p{Zs}]"
    ], [
        "[[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]"
    ]);
    _templateObject10 = function() {
        return data;
    };
    return data;
}
function _templateObject11() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[p{P}p{S}]"
    ], [
        "[\\p{P}\\p{S}]"
    ]);
    _templateObject11 = function() {
        return data;
    };
    return data;
}
function _templateObject12() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{space}"
    ], [
        "\\p{space}"
    ]);
    _templateObject12 = function() {
        return data;
    };
    return data;
}
function _templateObject13() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{Upper}"
    ], [
        "\\p{Upper}"
    ]);
    _templateObject13 = function() {
        return data;
    };
    return data;
}
function _templateObject14() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[p{Alpha}p{M}p{Nd}p{Pc}]"
    ], [
        "[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]"
    ]);
    _templateObject14 = function() {
        return data;
    };
    return data;
}
function _templateObject15() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{AHex}"
    ], [
        "\\p{AHex}"
    ]);
    _templateObject15 = function() {
        return data;
    };
    return data;
}
function _templateObject16() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?<=A|\n(?!z))"
    ], [
        "(?<=\\A|\\n(?!\\z))"
    ]);
    _templateObject16 = function() {
        return data;
    };
    return data;
}
function _templateObject17() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Uses "G" in a way that requires a subclass'
    ], [
        'Uses "\\G" in a way that requires a subclass'
    ]);
    _templateObject17 = function() {
        return data;
    };
    return data;
}
function _templateObject18() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?=\n?z)"
    ], [
        "(?=\\n?\\z)"
    ]);
    _templateObject18 = function() {
        return data;
    };
    return data;
}
function _templateObject19() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Use of "X" requires non-strict accuracy'
    ], [
        'Use of "\\X" requires non-strict accuracy'
    ]);
    _templateObject19 = function() {
        return data;
    };
    return data;
}
function _templateObject20() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{RI}{2}|",
        "(?:",
        ")*"
    ], [
        "\\p{RI}{2}|",
        "(?:\\u200D",
        ")*"
    ]);
    _templateObject20 = function() {
        return data;
    };
    return data;
}
function _templateObject21() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p{RGI_Emoji}"
    ], [
        "\\p{RGI_Emoji}"
    ]);
    _templateObject21 = function() {
        return data;
    };
    return data;
}
function _templateObject22() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "(?>\r\n|",
        "|P{M}p{M}*)"
    ], [
        "(?>\\r\\n|",
        "|\\P{M}\\p{M}*)"
    ]);
    _templateObject22 = function() {
        return data;
    };
    return data;
}
function _templateObject23() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Uses "K" in a way that\'s unsupported'
    ], [
        'Uses "\\K" in a way that\'s unsupported'
    ]);
    _templateObject23 = function() {
        return data;
    };
    return data;
}
function _templateObject24() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        'Uses "G" in a way that requires non-strict accuracy'
    ], [
        'Uses "\\G" in a way that requires non-strict accuracy'
    ]);
    _templateObject24 = function() {
        return data;
    };
    return data;
}
function _templateObject25() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "B"
    ], [
        "\\B"
    ]);
    _templateObject25 = function() {
        return data;
    };
    return data;
}
function _templateObject26() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\b"
    ], [
        "\\b"
    ]);
    _templateObject26 = function() {
        return data;
    };
    return data;
}
function _templateObject27() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "[^\n]"
    ], [
        "[^\\n]"
    ]);
    _templateObject27 = function() {
        return data;
    };
    return data;
}
function _templateObject28() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "D"
    ], [
        "\\D"
    ]);
    _templateObject28 = function() {
        return data;
    };
    return data;
}
function _templateObject29() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "d"
    ], [
        "\\d"
    ]);
    _templateObject29 = function() {
        return data;
    };
    return data;
}
function _templateObject30() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "P"
    ], [
        "\\P"
    ]);
    _templateObject30 = function() {
        return data;
    };
    return data;
}
function _templateObject31() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "p"
    ], [
        "\\p"
    ]);
    _templateObject31 = function() {
        return data;
    };
    return data;
}
function _templateObject32() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "W"
    ], [
        "\\W"
    ]);
    _templateObject32 = function() {
        return data;
    };
    return data;
}
function _templateObject33() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "w"
    ], [
        "\\w"
    ]);
    _templateObject33 = function() {
        return data;
    };
    return data;
}
function _templateObject34() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "g<",
        "&R=",
        ">"
    ], [
        "\\g<",
        "&R=",
        ">"
    ]);
    _templateObject34 = function() {
        return data;
    };
    return data;
}
function _templateObject35() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "	"
    ], [
        "\\t"
    ]);
    _templateObject35 = function() {
        return data;
    };
    return data;
}
function _templateObject36() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\n"
    ], [
        "\\n"
    ]);
    _templateObject36 = function() {
        return data;
    };
    return data;
}
function _templateObject37() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\v"
    ], [
        "\\v"
    ]);
    _templateObject37 = function() {
        return data;
    };
    return data;
}
function _templateObject38() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\f"
    ], [
        "\\f"
    ]);
    _templateObject38 = function() {
        return data;
    };
    return data;
}
function _templateObject39() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\r"
    ], [
        "\\r"
    ]);
    _templateObject39 = function() {
        return data;
    };
    return data;
}
function _templateObject40() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\u2028"
    ], [
        "\\u2028"
    ]);
    _templateObject40 = function() {
        return data;
    };
    return data;
}
function _templateObject41() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\u2029"
    ], [
        "\\u2029"
    ]);
    _templateObject41 = function() {
        return data;
    };
    return data;
}
function _templateObject42() {
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_tagged_template_literal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])([
        "\uFEFF"
    ], [
        "\\uFEFF"
    ]);
    _templateObject42 = function() {
        return data;
    };
    return data;
}
var /**
  @type {Map<number, {
    hidden?: true;
    transferTo?: number;
  }>}
  */ _captureMap, /**
  @type {RegExp | EmulatedRegExp | null}
  */ _compiled, /**
  @type {string}
  */ _pattern, /**
  @type {Map<number, string>?}
  */ _nameMap, /**
  @type {string?}
  */ _strategy, /**
  Adds support for hidden and transfer captures.
  @param {string} str
  @returns
  */ _execCore, __EmulatedRegExp;
var cp = String.fromCodePoint;
var r = String.raw;
var envFlags = {
    flagGroups: (()=>{
        try {
            new RegExp("(?i:)");
        } catch (e) {
            return false;
        }
        return true;
    })(),
    unicodeSets: (()=>{
        try {
            new RegExp("", "v");
        } catch (e) {
            return false;
        }
        return true;
    })()
};
envFlags.bugFlagVLiteralHyphenIsRange = envFlags.unicodeSets ? (()=>{
    try {
        new RegExp(r(_templateObject()), "v");
    } catch (e) {
        return true;
    }
    return false;
})() : false;
envFlags.bugNestedClassIgnoresNegation = envFlags.unicodeSets && new RegExp("[[^a]]", "v").test("a");
function getNewCurrentFlags(current, param) {
    let { enable, disable } = param;
    return {
        dotAll: !(disable === null || disable === void 0 ? void 0 : disable.dotAll) && !!((enable === null || enable === void 0 ? void 0 : enable.dotAll) || current.dotAll),
        ignoreCase: !(disable === null || disable === void 0 ? void 0 : disable.ignoreCase) && !!((enable === null || enable === void 0 ? void 0 : enable.ignoreCase) || current.ignoreCase)
    };
}
function getOrInsert(map, key, defaultValue) {
    if (!map.has(key)) {
        map.set(key, defaultValue);
    }
    return map.get(key);
}
function isMinTarget(target, min) {
    return EsVersion[target] >= EsVersion[min];
}
function throwIfNullish(value, msg) {
    if (value == null) {
        throw new Error(msg !== null && msg !== void 0 ? msg : "Value expected");
    }
    return value;
}
// src/options.js
var EsVersion = {
    ES2025: 2025,
    ES2024: 2024,
    ES2018: 2018
};
var Target = /** @type {const} */ {
    auto: "auto",
    ES2025: "ES2025",
    ES2024: "ES2024",
    ES2018: "ES2018"
};
function getOptions() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (({}).toString.call(options) !== "[object Object]") {
        throw new Error("Unexpected options");
    }
    if (options.target !== void 0 && !Target[options.target]) {
        throw new Error('Unexpected target "'.concat(options.target, '"'));
    }
    const opts = {
        // Sets the level of emulation rigor/strictness.
        accuracy: "default",
        // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in
        // certain patterns not being emulatable.
        avoidSubclass: false,
        // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W`, `y{g}` in any order (all
        // optional). Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).
        flags: "",
        // Include JavaScript flag `g` (`global`) in the result.
        global: false,
        // Include JavaScript flag `d` (`hasIndices`) in the result.
        hasIndices: false,
        // Delay regex construction until first use if the transpiled pattern is at least this length.
        lazyCompileLength: Infinity,
        // JavaScript version used for generated regexes. Using `auto` detects the best value based on
        // your environment. Later targets allow faster processing, simpler generated source, and
        // support for additional features.
        target: "auto",
        // Disables minifications that simplify the pattern without changing the meaning.
        verbose: false,
        ...options,
        // Advanced options that override standard behavior, error checking, and flags when enabled.
        rules: {
            // Useful with TextMate grammars that merge backreferences across patterns.
            allowOrphanBackrefs: false,
            // Use ASCII `\b` and `\B`, which increases search performance of generated regexes.
            asciiWordBoundaries: false,
            // Allow unnamed captures and numbered calls (backreferences and subroutines) when using
            // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in
            // `vscode-oniguruma`.
            captureGroup: false,
            // Change the recursion depth limit from Oniguruma's `20` to an integer `2``20`.
            recursionLimit: 20,
            // `^` as `\A`; `$` as`\Z`. Improves search performance of generated regexes without changing
            // the meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.
            singleline: false,
            ...options.rules
        }
    };
    if (opts.target === "auto") {
        opts.target = envFlags.flagGroups ? "ES2025" : envFlags.unicodeSets ? "ES2024" : "ES2018";
    }
    return opts;
}
;
var asciiSpaceChar = "[	-\r ]";
var CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([
    cp(304),
    // 
    cp(305)
]);
var defaultWordChar = r(_templateObject1());
function getIgnoreCaseMatchChars(char) {
    if (CharsWithoutIgnoreCaseExpansion.has(char)) {
        return [
            char
        ];
    }
    const set = /* @__PURE__ */ new Set();
    const lower = char.toLowerCase();
    const upper = lower.toUpperCase();
    const title = LowerToTitleCaseMap.get(lower);
    const altLower = LowerToAlternativeLowerCaseMap.get(lower);
    const altUpper = LowerToAlternativeUpperCaseMap.get(lower);
    if ([
        ...upper
    ].length === 1) {
        set.add(upper);
    }
    altUpper && set.add(altUpper);
    title && set.add(title);
    set.add(lower);
    altLower && set.add(altLower);
    return [
        ...set
    ];
}
var JsUnicodePropertyMap = /* @__PURE__ */ new Map("C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS".split(/\s/).map((p)=>[
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["slug"])(p),
        p
    ]));
var LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([
    [
        "s",
        cp(383)
    ],
    // s, 
    [
        cp(383),
        "s"
    ]
]);
var LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([
    [
        cp(223),
        cp(7838)
    ],
    // , 
    [
        cp(107),
        cp(8490)
    ],
    // k,  (Kelvin)
    [
        cp(229),
        cp(8491)
    ],
    // ,  (Angstrom)
    [
        cp(969),
        cp(8486)
    ]
]);
var LowerToTitleCaseMap = new Map([
    titleEntry(453),
    titleEntry(456),
    titleEntry(459),
    titleEntry(498),
    ...titleRange(8072, 8079),
    ...titleRange(8088, 8095),
    ...titleRange(8104, 8111),
    titleEntry(8124),
    titleEntry(8140),
    titleEntry(8188)
]);
var PosixClassMap = /* @__PURE__ */ new Map([
    [
        "alnum",
        r(_templateObject2())
    ],
    [
        "alpha",
        r(_templateObject3())
    ],
    [
        "ascii",
        r(_templateObject4())
    ],
    [
        "blank",
        r(_templateObject5())
    ],
    [
        "cntrl",
        r(_templateObject6())
    ],
    [
        "digit",
        r(_templateObject7())
    ],
    [
        "graph",
        r(_templateObject8())
    ],
    [
        "lower",
        r(_templateObject9())
    ],
    [
        "print",
        r(_templateObject10())
    ],
    [
        "punct",
        r(_templateObject11())
    ],
    // Updated value from Onig 6.9.9; changed from Unicode `\p{punct}`
    [
        "space",
        r(_templateObject12())
    ],
    [
        "upper",
        r(_templateObject13())
    ],
    [
        "word",
        r(_templateObject14())
    ],
    [
        "xdigit",
        r(_templateObject15())
    ]
]);
function range(start, end) {
    const range2 = [];
    for(let i = start; i <= end; i++){
        range2.push(i);
    }
    return range2;
}
function titleEntry(codePoint) {
    const char = cp(codePoint);
    return [
        char.toLowerCase(),
        char
    ];
}
function titleRange(start, end) {
    return range(start, end).map((codePoint)=>titleEntry(codePoint));
}
var UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([
    "Lower",
    "Lowercase",
    "Upper",
    "Uppercase",
    "Ll",
    "Lowercase_Letter",
    "Lt",
    "Titlecase_Letter",
    "Lu",
    "Uppercase_Letter"
]);
;
;
function transform(ast, options) {
    const opts = {
        // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:
        // - `CharacterSet` kind `text_segment` (`\X`): An exact representation would require heavy
        //   Unicode data; a best-effort approximation requires knowing the target.
        // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode
        //   representations would be hard to change to ASCII versions after the fact in the generator
        //   based on `target`/`accuracy`, so produce the appropriate structure here.
        accuracy: "default",
        asciiWordBoundaries: false,
        avoidSubclass: false,
        bestEffortTarget: "ES2025",
        ...options
    };
    addParentProperties(ast);
    const firstPassState = {
        accuracy: opts.accuracy,
        asciiWordBoundaries: opts.asciiWordBoundaries,
        avoidSubclass: opts.avoidSubclass,
        flagDirectivesByAlt: /* @__PURE__ */ new Map(),
        jsGroupNameMap: /* @__PURE__ */ new Map(),
        minTargetEs2024: isMinTarget(opts.bestEffortTarget, "ES2024"),
        passedLookbehind: false,
        strategy: null,
        // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass 
        subroutineRefMap: /* @__PURE__ */ new Map(),
        supportedGNodes: /* @__PURE__ */ new Set(),
        digitIsAscii: ast.flags.digitIsAscii,
        spaceIsAscii: ast.flags.spaceIsAscii,
        wordIsAscii: ast.flags.wordIsAscii
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverse"])(ast, FirstPassVisitor, firstPassState);
    const globalFlags = {
        dotAll: ast.flags.dotAll,
        ignoreCase: ast.flags.ignoreCase
    };
    const secondPassState = {
        currentFlags: globalFlags,
        prevFlags: null,
        globalFlags,
        groupOriginByCopy: /* @__PURE__ */ new Map(),
        groupsByName: /* @__PURE__ */ new Map(),
        multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),
        openRefs: /* @__PURE__ */ new Map(),
        reffedNodesByReferencer: /* @__PURE__ */ new Map(),
        subroutineRefMap: firstPassState.subroutineRefMap
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverse"])(ast, SecondPassVisitor, secondPassState);
    const thirdPassState = {
        groupsByName: secondPassState.groupsByName,
        highestOrphanBackref: 0,
        numCapturesToLeft: 0,
        reffedNodesByReferencer: secondPassState.reffedNodesByReferencer
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverse"])(ast, ThirdPassVisitor, thirdPassState);
    ast._originMap = secondPassState.groupOriginByCopy;
    ast._strategy = firstPassState.strategy;
    return ast;
}
var FirstPassVisitor = {
    AbsenceFunction (param) {
        let { node, parent, replaceWith } = param;
        const { body, kind } = node;
        if (kind === "repeater") {
            const innerGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])();
            innerGroup.body[0].body.push(// Insert own alts as `body`
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                negate: true,
                body
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createUnicodeProperty"])("Any"));
            const outerGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])();
            outerGroup.body[0].body.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createQuantifier"])("greedy", 0, Infinity, innerGroup));
            replaceWith(setParentDeep(outerGroup, parent), {
                traverse: true
            });
        } else {
            throw new Error('Unsupported absence function "(?~|"');
        }
    },
    Alternative: {
        enter (param, param1) {
            let { node, parent, key } = param, { flagDirectivesByAlt } = param1;
            const flagDirectives = node.body.filter((el)=>el.kind === "flags");
            for(let i = key + 1; i < parent.body.length; i++){
                const forwardSiblingAlt = parent.body[i];
                getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);
            }
        },
        exit (param, param1) {
            let { node } = param, { flagDirectivesByAlt } = param1;
            var _flagDirectivesByAlt_get;
            if ((_flagDirectivesByAlt_get = flagDirectivesByAlt.get(node)) === null || _flagDirectivesByAlt_get === void 0 ? void 0 : _flagDirectivesByAlt_get.length) {
                const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));
                if (flags) {
                    const flagGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])({
                        flags
                    });
                    flagGroup.body[0].body = node.body;
                    node.body = [
                        setParentDeep(flagGroup, node)
                    ];
                }
            }
        }
    },
    Assertion (param, state) {
        let { node, parent, key, container, root, remove, replaceWith } = param;
        const { kind, negate } = node;
        const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;
        if (kind === "text_segment_boundary") {
            throw new Error('Unsupported text segment boundary "\\'.concat(negate ? "Y" : "y", '"'));
        } else if (kind === "line_end") {
            replaceWith(setParentDeep((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                body: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAlternative"])({
                        body: [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAssertion"])("string_end")
                        ]
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAlternative"])({
                        body: [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCharacter"])(10)
                        ]
                    })
                ]
            }), parent));
        } else if (kind === "line_start") {
            replaceWith(setParentDeep(parseFragment(r(_templateObject16()), {
                skipLookbehindValidation: true
            }), parent));
        } else if (kind === "search_start") {
            if (supportedGNodes.has(node)) {
                root.flags.sticky = true;
                remove();
            } else {
                const prev = container[key - 1];
                if (prev && isAlwaysNonZeroLength(prev)) {
                    replaceWith(setParentDeep((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                        negate: true
                    }), parent));
                } else if (avoidSubclass) {
                    throw new Error(r(_templateObject17()));
                } else {
                    replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAssertion"])("string_start"), parent));
                    state.strategy = "clip_search";
                }
            }
        } else if (kind === "string_end" || kind === "string_start") {} else if (kind === "string_end_newline") {
            replaceWith(setParentDeep(parseFragment(r(_templateObject18())), parent));
        } else if (kind === "word_boundary") {
            if (!wordIsAscii && !asciiWordBoundaries) {
                const b = "(?:(?<=".concat(defaultWordChar, ")(?!").concat(defaultWordChar, ")|(?<!").concat(defaultWordChar, ")(?=").concat(defaultWordChar, "))");
                const B = "(?:(?<=".concat(defaultWordChar, ")(?=").concat(defaultWordChar, ")|(?<!").concat(defaultWordChar, ")(?!").concat(defaultWordChar, "))");
                replaceWith(setParentDeep(parseFragment(negate ? B : b), parent));
            }
        } else {
            throw new Error('Unexpected assertion kind "'.concat(kind, '"'));
        }
    },
    Backreference (param, param1) {
        let { node } = param, { jsGroupNameMap } = param1;
        let { ref } = node;
        if (typeof ref === "string" && !isValidJsGroupName(ref)) {
            ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
            node.ref = ref;
        }
    },
    CapturingGroup (param, param1) {
        let { node } = param, { jsGroupNameMap, subroutineRefMap } = param1;
        let { name } = node;
        if (name && !isValidJsGroupName(name)) {
            name = getAndStoreJsGroupName(name, jsGroupNameMap);
            node.name = name;
        }
        subroutineRefMap.set(node.number, node);
        if (name) {
            subroutineRefMap.set(name, node);
        }
    },
    CharacterClassRange (param) {
        let { node, parent, replaceWith } = param;
        if (parent.kind === "intersection") {
            const cc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCharacterClass"])({
                body: [
                    node
                ]
            });
            replaceWith(setParentDeep(cc, parent), {
                traverse: true
            });
        }
    },
    CharacterSet (param, param1) {
        let { node, parent, replaceWith } = param, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii } = param1;
        const { kind, negate, value } = node;
        if (digitIsAscii && (kind === "digit" || value === "digit")) {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCharacterSet"])("digit", {
                negate
            }), parent));
            return;
        }
        if (spaceIsAscii && (kind === "space" || value === "space")) {
            replaceWith(setParentDeep(setNegate(parseFragment(asciiSpaceChar), negate), parent));
            return;
        }
        if (wordIsAscii && (kind === "word" || value === "word")) {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCharacterSet"])("word", {
                negate
            }), parent));
            return;
        }
        if (kind === "any") {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createUnicodeProperty"])("Any"), parent));
        } else if (kind === "digit") {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createUnicodeProperty"])("Nd", {
                negate
            }), parent));
        } else if (kind === "dot") {} else if (kind === "text_segment") {
            if (accuracy === "strict") {
                throw new Error(r(_templateObject19()));
            }
            const eBase = "\\p{Emoji}(?:\\p{EMod}|\\uFE0F\\u20E3?|[\\x{E0020}-\\x{E007E}]+\\x{E007F})?";
            const emoji = r(_templateObject20(), eBase, eBase);
            replaceWith(setParentDeep(parseFragment(// Close approximation of an extended grapheme cluster; see: <unicode.org/reports/tr29/>
            r(_templateObject22(), minTargetEs2024 ? r(_templateObject21()) : emoji), // Allow JS property `RGI_Emoji` through
            {
                skipPropertyNameValidation: true
            }), parent));
        } else if (kind === "hex") {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createUnicodeProperty"])("AHex", {
                negate
            }), parent));
        } else if (kind === "newline") {
            replaceWith(setParentDeep(parseFragment(negate ? "[^\n]" : "(?>\r\n?|[\n\v\f\x85\u2028\u2029])"), parent));
        } else if (kind === "posix") {
            if (!minTargetEs2024 && (value === "graph" || value === "print")) {
                if (accuracy === "strict") {
                    throw new Error('POSIX class "'.concat(value, '" requires min target ES2024 or non-strict accuracy'));
                }
                let ascii = {
                    graph: "!-~",
                    print: " -~"
                }[value];
                if (negate) {
                    ascii = "\0-".concat(cp(ascii.codePointAt(0) - 1)).concat(cp(ascii.codePointAt(2) + 1), "-");
                }
                replaceWith(setParentDeep(parseFragment("[".concat(ascii, "]")), parent));
            } else {
                replaceWith(setParentDeep(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));
            }
        } else if (kind === "property") {
            if (!JsUnicodePropertyMap.has((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["slug"])(value))) {
                node.key = "sc";
            }
        } else if (kind === "space") {
            replaceWith(setParent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createUnicodeProperty"])("space", {
                negate
            }), parent));
        } else if (kind === "word") {
            replaceWith(setParentDeep(setNegate(parseFragment(defaultWordChar), negate), parent));
        } else {
            throw new Error('Unexpected character set kind "'.concat(kind, '"'));
        }
    },
    Directive (param) {
        let { node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings } = param;
        const { kind, flags } = node;
        if (kind === "flags") {
            if (!flags.enable && !flags.disable) {
                remove();
            } else {
                const flagGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])({
                    flags
                });
                flagGroup.body[0].body = removeAllNextSiblings();
                replaceWith(setParentDeep(flagGroup, parent), {
                    traverse: true
                });
            }
        } else if (kind === "keep") {
            const firstAlt = root.body[0];
            const hasWrapperGroup = root.body.length === 1 && // Not emulatable if within a `CapturingGroup`
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$node$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOnlyChild"])(firstAlt, {
                type: "Group"
            }) && firstAlt.body[0].body.length === 1;
            const topLevel = hasWrapperGroup ? firstAlt.body[0] : root;
            if (parent.parent !== topLevel || topLevel.body.length > 1) {
                throw new Error(r(_templateObject23()));
            }
            const lookbehind = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                behind: true
            });
            lookbehind.body[0].body = removeAllPrevSiblings();
            replaceWith(setParentDeep(lookbehind, parent));
        } else {
            throw new Error('Unexpected directive kind "'.concat(kind, '"'));
        }
    },
    Flags (param) {
        let { node, parent } = param;
        if (node.posixIsAscii) {
            throw new Error('Unsupported flag "P"');
        }
        if (node.textSegmentMode === "word") {
            throw new Error('Unsupported flag "y{w}"');
        }
        [
            "digitIsAscii",
            // Flag D
            "extended",
            // Flag x
            "posixIsAscii",
            // Flag P
            "spaceIsAscii",
            // Flag S
            "wordIsAscii",
            // Flag W
            "textSegmentMode"
        ].forEach((f)=>delete node[f]);
        var _node_sticky;
        Object.assign(node, {
            // JS flag g; no Onig equiv
            global: false,
            // JS flag d; no Onig equiv
            hasIndices: false,
            // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break
            // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate
            // results (also allows `^` and `$` to be used in the generator for string start and end)
            multiline: false,
            // JS flag y; no Onig equiv, but used for `\G` emulation
            sticky: (_node_sticky = node.sticky) !== null && _node_sticky !== void 0 ? _node_sticky : false
        });
        parent.options = {
            disable: {
                // Onig uses different rules for flag x than Regex+, so disable the implicit flag
                x: true,
                // Onig has no flag to control "named capture only" mode but contextually applies its
                // behavior when named capturing is used, so disable Regex+'s implicit flag for it
                n: true
            },
            force: {
                // Always add flag v because we're generating an AST that relies on it (it enables JS
                // support for Onig features nested classes, intersection, Unicode properties, etc.).
                // However, the generator might disable flag v based on its `target` option
                v: true
            }
        };
    },
    Group (param) {
        let { node } = param;
        if (!node.flags) {
            return;
        }
        const { enable, disable } = node.flags;
        (enable === null || enable === void 0 ? void 0 : enable.extended) && delete enable.extended;
        (disable === null || disable === void 0 ? void 0 : disable.extended) && delete disable.extended;
        (enable === null || enable === void 0 ? void 0 : enable.dotAll) && (disable === null || disable === void 0 ? void 0 : disable.dotAll) && delete enable.dotAll;
        (enable === null || enable === void 0 ? void 0 : enable.ignoreCase) && (disable === null || disable === void 0 ? void 0 : disable.ignoreCase) && delete enable.ignoreCase;
        enable && !Object.keys(enable).length && delete node.flags.enable;
        disable && !Object.keys(disable).length && delete node.flags.disable;
        !node.flags.enable && !node.flags.disable && delete node.flags;
    },
    LookaroundAssertion (param, state) {
        let { node } = param;
        const { kind } = node;
        if (kind === "lookbehind") {
            state.passedLookbehind = true;
        }
    },
    NamedCallout (param) {
        let { node, parent, replaceWith } = param;
        const { kind } = node;
        if (kind === "fail") {
            replaceWith(setParentDeep((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                negate: true
            }), parent));
        } else {
            throw new Error('Unsupported named callout "(*'.concat(kind.toUpperCase(), '"'));
        }
    },
    Quantifier (param) {
        let { node } = param;
        if (node.body.type === "Quantifier") {
            const group = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])();
            group.body[0].body.push(node.body);
            node.body = setParentDeep(group, node);
        }
    },
    Regex: {
        enter (param, param1) {
            let { node } = param, { supportedGNodes } = param1;
            const leadingGs = [];
            let hasAltWithLeadG = false;
            let hasAltWithoutLeadG = false;
            for (const alt of node.body){
                if (alt.body.length === 1 && alt.body[0].kind === "search_start") {
                    alt.body.pop();
                } else {
                    const leadingG = getLeadingG(alt.body);
                    if (leadingG) {
                        hasAltWithLeadG = true;
                        Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);
                    } else {
                        hasAltWithoutLeadG = true;
                    }
                }
            }
            if (hasAltWithLeadG && !hasAltWithoutLeadG) {
                leadingGs.forEach((g)=>supportedGNodes.add(g));
            }
        },
        exit (_, param) {
            let { accuracy, passedLookbehind, strategy } = param;
            if (accuracy === "strict" && passedLookbehind && strategy) {
                throw new Error(r(_templateObject24()));
            }
        }
    },
    Subroutine (param, param1) {
        let { node } = param, { jsGroupNameMap } = param1;
        let { ref } = node;
        if (typeof ref === "string" && !isValidJsGroupName(ref)) {
            ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
            node.ref = ref;
        }
    }
};
var SecondPassVisitor = {
    Backreference (param, param1) {
        let { node } = param, { multiplexCapturesToLeftByRef, reffedNodesByReferencer } = param1;
        const { orphan, ref } = node;
        if (!orphan) {
            reffedNodesByReferencer.set(node, [
                ...multiplexCapturesToLeftByRef.get(ref).map((param)=>{
                    let { node: node2 } = param;
                    return node2;
                })
            ]);
        }
    },
    CapturingGroup: {
        enter (param, param1) {
            let { node, parent, replaceWith, skip } = param, { groupOriginByCopy, groupsByName, multiplexCapturesToLeftByRef, openRefs, reffedNodesByReferencer } = param1;
            const origin = groupOriginByCopy.get(node);
            if (origin && openRefs.has(node.number)) {
                const recursion2 = setParent(createRecursion(node.number), parent);
                reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));
                replaceWith(recursion2);
                return;
            }
            openRefs.set(node.number, node);
            multiplexCapturesToLeftByRef.set(node.number, []);
            if (node.name) {
                getOrInsert(multiplexCapturesToLeftByRef, node.name, []);
            }
            var _node_name;
            const multiplexNodes = multiplexCapturesToLeftByRef.get((_node_name = node.name) !== null && _node_name !== void 0 ? _node_name : node.number);
            for(let i = 0; i < multiplexNodes.length; i++){
                const multiplex = multiplexNodes[i];
                if (// This group is from subroutine expansion, and there's a multiplex value from either the
                // origin node or a prior subroutine expansion group with the same origin
                origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion
                // group that refers to this group
                node === multiplex.origin) {
                    multiplexNodes.splice(i, 1);
                    break;
                }
            }
            multiplexCapturesToLeftByRef.get(node.number).push({
                node,
                origin
            });
            if (node.name) {
                multiplexCapturesToLeftByRef.get(node.name).push({
                    node,
                    origin
                });
            }
            if (node.name) {
                const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());
                let hasDuplicateNameToRemove = false;
                if (origin) {
                    hasDuplicateNameToRemove = true;
                } else {
                    for (const groupInfo of groupsWithSameName.values()){
                        if (!groupInfo.hasDuplicateNameToRemove) {
                            hasDuplicateNameToRemove = true;
                            break;
                        }
                    }
                }
                groupsByName.get(node.name).set(node, {
                    node,
                    hasDuplicateNameToRemove
                });
            }
        },
        exit (param, param1) {
            let { node } = param, { openRefs } = param1;
            openRefs.delete(node.number);
        }
    },
    Group: {
        enter (param, state) {
            let { node } = param;
            state.prevFlags = state.currentFlags;
            if (node.flags) {
                state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);
            }
        },
        exit (_, state) {
            state.currentFlags = state.prevFlags;
        }
    },
    Subroutine (param, state) {
        let { node, parent, replaceWith } = param;
        const { isRecursive, ref } = node;
        if (isRecursive) {
            let reffed = parent;
            while(reffed = reffed.parent){
                if (reffed.type === "CapturingGroup" && (reffed.name === ref || reffed.number === ref)) {
                    break;
                }
            }
            state.reffedNodesByReferencer.set(node, reffed);
            return;
        }
        const reffedGroupNode = state.subroutineRefMap.get(ref);
        const isGlobalRecursion = ref === 0;
        const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : // The reffed group might itself contain subroutines, which are expanded during sub-traversal
        cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);
        let replacement = expandedSubroutine;
        if (!isGlobalRecursion) {
            const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (p)=>p.type === "Group" && !!p.flags));
            const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;
            if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {
                replacement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])({
                    flags: getFlagModsFromFlags(reffedGroupFlags)
                });
                replacement.body[0].body.push(expandedSubroutine);
            }
        }
        replaceWith(setParentDeep(replacement, parent), {
            traverse: !isGlobalRecursion
        });
    }
};
var ThirdPassVisitor = {
    Backreference (param, state) {
        let { node, parent, replaceWith } = param;
        if (node.orphan) {
            state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);
            return;
        }
        const reffedNodes = state.reffedNodesByReferencer.get(node);
        const participants = reffedNodes.filter((reffed)=>canParticipateWithNode(reffed, node));
        if (!participants.length) {
            replaceWith(setParentDeep((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLookaroundAssertion"])({
                negate: true
            }), parent));
        } else if (participants.length > 1) {
            const group = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])({
                atomic: true,
                body: participants.reverse().map((reffed)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAlternative"])({
                        body: [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createBackreference"])(reffed.number)
                        ]
                    }))
            });
            replaceWith(setParentDeep(group, parent));
        } else {
            node.ref = participants[0].number;
        }
    },
    CapturingGroup (param, state) {
        let { node } = param;
        node.number = ++state.numCapturesToLeft;
        if (node.name) {
            if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {
                delete node.name;
            }
        }
    },
    Regex: {
        exit (param, state) {
            let { node } = param;
            const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);
            for(let i = 0; i < numCapsNeeded; i++){
                const emptyCapture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCapturingGroup"])();
                node.body.at(-1).body.push(emptyCapture);
            }
        }
    },
    Subroutine (param, state) {
        let { node } = param;
        if (!node.isRecursive || node.ref === 0) {
            return;
        }
        node.ref = state.reffedNodesByReferencer.get(node).number;
    }
};
function addParentProperties(root) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverse"])(root, {
        "*" (param) {
            let { node, parent } = param;
            node.parent = parent;
        }
    });
}
function areFlagsEqual(a, b) {
    return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;
}
function canParticipateWithNode(capture, node) {
    let rightmostPoint = node;
    do {
        if (rightmostPoint.type === "Regex") {
            return false;
        }
        if (rightmostPoint.type === "Alternative") {
            continue;
        }
        if (rightmostPoint === capture) {
            return false;
        }
        const kidsOfParent = getKids(rightmostPoint.parent);
        for (const kid of kidsOfParent){
            if (kid === rightmostPoint) {
                break;
            }
            if (kid === capture || isAncestorOf(kid, capture)) {
                return true;
            }
        }
    }while (rightmostPoint = rightmostPoint.parent)
    throw new Error("Unexpected path");
}
function cloneCapturingGroup(obj, originMap, up, up2) {
    const store = Array.isArray(obj) ? [] : {};
    for (const [key, value] of Object.entries(obj)){
        if (key === "parent") {
            store.parent = Array.isArray(up) ? up2 : up;
        } else if (value && typeof value === "object") {
            store[key] = cloneCapturingGroup(value, originMap, store, up);
        } else {
            if (key === "type" && value === "CapturingGroup") {
                var _originMap_get;
                originMap.set(store, (_originMap_get = originMap.get(obj)) !== null && _originMap_get !== void 0 ? _originMap_get : obj);
            }
            store[key] = value;
        }
    }
    return store;
}
function createRecursion(ref) {
    const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSubroutine"])(ref);
    node.isRecursive = true;
    return node;
}
function getAllParents(node, filterFn) {
    const results = [];
    while(node = node.parent){
        if (!filterFn || filterFn(node)) {
            results.push(node);
        }
    }
    return results;
}
function getAndStoreJsGroupName(name, map) {
    if (map.has(name)) {
        return map.get(name);
    }
    const jsName = "$".concat(map.size, "_").concat(name.replace(RegExp("^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]", "ug"), "_"));
    map.set(name, jsName);
    return jsName;
}
function getCombinedFlagModsFromFlagNodes(flagNodes) {
    const flagProps = [
        "dotAll",
        "ignoreCase"
    ];
    const combinedFlags = {
        enable: {},
        disable: {}
    };
    flagNodes.forEach((param)=>{
        let { flags } = param;
        flagProps.forEach((prop)=>{
            var _flags_enable, _flags_disable;
            if ((_flags_enable = flags.enable) === null || _flags_enable === void 0 ? void 0 : _flags_enable[prop]) {
                delete combinedFlags.disable[prop];
                combinedFlags.enable[prop] = true;
            }
            if ((_flags_disable = flags.disable) === null || _flags_disable === void 0 ? void 0 : _flags_disable[prop]) {
                combinedFlags.disable[prop] = true;
            }
        });
    });
    if (!Object.keys(combinedFlags.enable).length) {
        delete combinedFlags.enable;
    }
    if (!Object.keys(combinedFlags.disable).length) {
        delete combinedFlags.disable;
    }
    if (combinedFlags.enable || combinedFlags.disable) {
        return combinedFlags;
    }
    return null;
}
function getFlagModsFromFlags(param) {
    let { dotAll, ignoreCase } = param;
    const mods = {};
    if (dotAll || ignoreCase) {
        mods.enable = {};
        dotAll && (mods.enable.dotAll = true);
        ignoreCase && (mods.enable.ignoreCase = true);
    }
    if (!dotAll || !ignoreCase) {
        mods.disable = {};
        !dotAll && (mods.disable.dotAll = true);
        !ignoreCase && (mods.disable.ignoreCase = true);
    }
    return mods;
}
function getKids(node) {
    if (!node) {
        throw new Error("Node expected");
    }
    const { body } = node;
    return Array.isArray(body) ? body : body ? [
        body
    ] : null;
}
function getLeadingG(els) {
    const firstToConsider = els.find((el)=>el.kind === "search_start" || isLoneGLookaround(el, {
            negate: false
        }) || !isAlwaysZeroLength(el));
    if (!firstToConsider) {
        return null;
    }
    if (firstToConsider.kind === "search_start") {
        return firstToConsider;
    }
    if (firstToConsider.type === "LookaroundAssertion") {
        return firstToConsider.body[0].body[0];
    }
    if (firstToConsider.type === "CapturingGroup" || firstToConsider.type === "Group") {
        const gNodesForGroup = [];
        for (const alt of firstToConsider.body){
            const leadingG = getLeadingG(alt.body);
            if (!leadingG) {
                return null;
            }
            Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);
        }
        return gNodesForGroup;
    }
    return null;
}
function isAncestorOf(node, descendant) {
    var _getKids;
    const kids = (_getKids = getKids(node)) !== null && _getKids !== void 0 ? _getKids : [];
    for (const kid of kids){
        if (kid === descendant || isAncestorOf(kid, descendant)) {
            return true;
        }
    }
    return false;
}
function isAlwaysZeroLength(param) {
    let { type } = param;
    return type === "Assertion" || type === "Directive" || type === "LookaroundAssertion";
}
function isAlwaysNonZeroLength(node) {
    const types = [
        "Character",
        "CharacterClass",
        "CharacterSet"
    ];
    return types.includes(node.type) || node.type === "Quantifier" && node.min && types.includes(node.body.type);
}
function isLoneGLookaround(node, options) {
    const opts = {
        negate: null,
        ...options
    };
    return node.type === "LookaroundAssertion" && (opts.negate === null || node.negate === opts.negate) && node.body.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$node$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOnlyChild"])(node.body[0], {
        type: "Assertion",
        kind: "search_start"
    });
}
function isValidJsGroupName(name) {
    return RegExp("^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$", "u").test(name);
}
function parseFragment(pattern, options) {
    const ast = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])(pattern, {
        ...options,
        // Providing a custom set of Unicode property names avoids converting some JS Unicode
        // properties (ex: `\p{Alpha}`) to Onig POSIX classes
        unicodePropertyMap: JsUnicodePropertyMap
    });
    const alts = ast.body;
    if (alts.length > 1 || alts[0].body.length > 1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])({
            body: alts
        });
    }
    return alts[0].body[0];
}
function setNegate(node, negate) {
    node.negate = negate;
    return node;
}
function setParent(node, parent) {
    node.parent = parent;
    return node;
}
function setParentDeep(node, parent) {
    addParentProperties(node);
    node.parent = parent;
    return node;
}
;
;
function generate(ast, options) {
    const opts = getOptions(options);
    const minTargetEs2024 = isMinTarget(opts.target, "ES2024");
    const minTargetEs2025 = isMinTarget(opts.target, "ES2025");
    const recursionLimit = opts.rules.recursionLimit;
    if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {
        throw new Error("Invalid recursionLimit; use 2-20");
    }
    let hasCaseInsensitiveNode = null;
    let hasCaseSensitiveNode = null;
    if (!minTargetEs2025) {
        const iStack = [
            ast.flags.ignoreCase
        ];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$traverser$2f$traverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverse"])(ast, FlagModifierVisitor, {
            getCurrentModI: ()=>iStack.at(-1),
            popModI () {
                iStack.pop();
            },
            pushModI (isIOn) {
                iStack.push(isIOn);
            },
            setHasCasedChar () {
                if (iStack.at(-1)) {
                    hasCaseInsensitiveNode = true;
                } else {
                    hasCaseSensitiveNode = true;
                }
            }
        });
    }
    const appliedGlobalFlags = {
        dotAll: ast.flags.dotAll,
        // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were
        //   used (to avoid unnecessary node expansion).
        // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be
        //   forced without the use of ES2025 flag groups)
        ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)
    };
    let lastNode = ast;
    const state = {
        accuracy: opts.accuracy,
        appliedGlobalFlags,
        captureMap: /* @__PURE__ */ new Map(),
        currentFlags: {
            dotAll: ast.flags.dotAll,
            ignoreCase: ast.flags.ignoreCase
        },
        inCharClass: false,
        lastNode,
        originMap: ast._originMap,
        recursionLimit,
        useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),
        useFlagMods: minTargetEs2025,
        useFlagV: minTargetEs2024,
        verbose: opts.verbose
    };
    function gen(node) {
        state.lastNode = lastNode;
        lastNode = node;
        const fn = throwIfNullish(generator[node.type], 'Unexpected node type "'.concat(node.type, '"'));
        return fn(node, state, gen);
    }
    const result = {
        pattern: ast.body.map(gen).join("|"),
        // Could reset `lastNode` at this point via `lastNode = ast`, but it isn't needed by flags
        flags: gen(ast.flags),
        options: {
            ...ast.options
        }
    };
    if (!minTargetEs2024) {
        delete result.options.force.v;
        result.options.disable.v = true;
        result.options.unicodeSetsPlugin = null;
    }
    result._captureTransfers = /* @__PURE__ */ new Map();
    result._hiddenCaptures = [];
    state.captureMap.forEach((value, key)=>{
        if (value.hidden) {
            result._hiddenCaptures.push(key);
        }
        if (value.transferTo) {
            getOrInsert(result._captureTransfers, value.transferTo, []).push(key);
        }
    });
    return result;
}
var FlagModifierVisitor = {
    "*": {
        enter (param, state) {
            let { node } = param;
            if (isAnyGroup(node)) {
                const currentModI = state.getCurrentModI();
                state.pushModI(node.flags ? getNewCurrentFlags({
                    ignoreCase: currentModI
                }, node.flags).ignoreCase : currentModI);
            }
        },
        exit (param, state) {
            let { node } = param;
            if (isAnyGroup(node)) {
                state.popModI();
            }
        }
    },
    Backreference (_, state) {
        state.setHasCasedChar();
    },
    Character (param, state) {
        let { node } = param;
        if (charHasCase(cp(node.value))) {
            state.setHasCasedChar();
        }
    },
    CharacterClassRange (param, state) {
        let { node, skip } = param;
        skip();
        if (getCasesOutsideCharClassRange(node, {
            firstOnly: true
        }).length) {
            state.setHasCasedChar();
        }
    },
    CharacterSet (param, state) {
        let { node } = param;
        if (node.kind === "property" && UnicodePropertiesWithSpecificCase.has(node.value)) {
            state.setHasCasedChar();
        }
    }
};
var generator = {
    /**
  @param {AlternativeNode} node
  */ Alternative (param, _, gen) {
        let { body } = param;
        return body.map(gen).join("");
    },
    /**
  @param {AssertionNode} node
  */ Assertion (param) {
        let { kind, negate } = param;
        if (kind === "string_end") {
            return "$";
        }
        if (kind === "string_start") {
            return "^";
        }
        if (kind === "word_boundary") {
            return negate ? r(_templateObject25()) : r(_templateObject26());
        }
        throw new Error('Unexpected assertion kind "'.concat(kind, '"'));
    },
    /**
  @param {BackreferenceNode} node
  */ Backreference (param, state) {
        let { ref } = param;
        if (typeof ref !== "number") {
            throw new Error("Unexpected named backref in transformed AST");
        }
        if (!state.useFlagMods && state.accuracy === "strict" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {
            throw new Error("Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy");
        }
        return "\\" + ref;
    },
    /**
  @param {CapturingGroupNode} node
  */ CapturingGroup (node, state, gen) {
        const { body, name, number } = node;
        const data = {
            ignoreCase: state.currentFlags.ignoreCase
        };
        const origin = state.originMap.get(node);
        if (origin) {
            data.hidden = true;
            if (number > origin.number) {
                data.transferTo = origin.number;
            }
        }
        state.captureMap.set(number, data);
        return "(".concat(name ? "?<".concat(name, ">") : "").concat(body.map(gen).join("|"), ")");
    },
    /**
  @param {CharacterNode} node
  */ Character (param, state) {
        let { value } = param;
        const char = cp(value);
        const escaped = getCharEscape(value, {
            escDigit: state.lastNode.type === "Backreference",
            inCharClass: state.inCharClass,
            useFlagV: state.useFlagV
        });
        if (escaped !== char) {
            return escaped;
        }
        if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {
            const cases = getIgnoreCaseMatchChars(char);
            return state.inCharClass ? cases.join("") : cases.length > 1 ? "[".concat(cases.join(""), "]") : cases[0];
        }
        return char;
    },
    /**
  @param {CharacterClassNode} node
  */ CharacterClass (node, state, gen) {
        const { kind, negate, parent } = node;
        let { body } = node;
        if (kind === "intersection" && !state.useFlagV) {
            throw new Error("Use of class intersection requires min target ES2024");
        }
        if (envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV && body.some(isLiteralHyphen)) {
            body = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCharacter"])(45),
                ...body.filter((kid)=>!isLiteralHyphen(kid))
            ];
        }
        const genClass = ()=>"[".concat(negate ? "^" : "").concat(body.map(gen).join(kind === "intersection" ? "&&" : ""), "]");
        if (!state.inCharClass) {
            if (// Already established `kind !== 'intersection'` if `!state.useFlagV`; don't check again
            (!state.useFlagV || envFlags.bugNestedClassIgnoresNegation) && !negate) {
                const negatedChildClasses = body.filter((kid)=>kid.type === "CharacterClass" && kid.kind === "union" && kid.negate);
                if (negatedChildClasses.length) {
                    const group = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createGroup"])();
                    const groupFirstAlt = group.body[0];
                    group.parent = parent;
                    groupFirstAlt.parent = group;
                    body = body.filter((kid)=>!negatedChildClasses.includes(kid));
                    node.body = body;
                    if (body.length) {
                        node.parent = groupFirstAlt;
                        groupFirstAlt.body.push(node);
                    } else {
                        group.body.pop();
                    }
                    negatedChildClasses.forEach((cc)=>{
                        const newAlt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAlternative"])({
                            body: [
                                cc
                            ]
                        });
                        cc.parent = newAlt;
                        newAlt.parent = group;
                        group.body.push(newAlt);
                    });
                    return gen(group);
                }
            }
            state.inCharClass = true;
            const result = genClass();
            state.inCharClass = false;
            return result;
        }
        const firstEl = body[0];
        if (// Already established that the parent is a char class via `inCharClass`; don't check again
        kind === "union" && !negate && firstEl && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting
        ((!state.useFlagV || !state.verbose) && parent.kind === "union" && !(envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV) || !state.verbose && parent.kind === "intersection" && // JS doesn't allow intersection with union or ranges
        body.length === 1 && firstEl.type !== "CharacterClassRange")) {
            return body.map(gen).join("");
        }
        if (!state.useFlagV && parent.type === "CharacterClass") {
            throw new Error("Use of nested character class requires min target ES2024");
        }
        return genClass();
    },
    /**
  @param {CharacterClassRangeNode} node
  */ CharacterClassRange (node, state) {
        const min = node.min.value;
        const max = node.max.value;
        const escOpts = {
            escDigit: false,
            inCharClass: true,
            useFlagV: state.useFlagV
        };
        const minStr = getCharEscape(min, escOpts);
        const maxStr = getCharEscape(max, escOpts);
        const extraChars = /* @__PURE__ */ new Set();
        if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {
            const charsOutsideRange = getCasesOutsideCharClassRange(node);
            const ranges = getCodePointRangesFromChars(charsOutsideRange);
            ranges.forEach((value)=>{
                extraChars.add(Array.isArray(value) ? "".concat(getCharEscape(value[0], escOpts), "-").concat(getCharEscape(value[1], escOpts)) : getCharEscape(value, escOpts));
            });
        }
        return "".concat(minStr, "-").concat(maxStr).concat([
            ...extraChars
        ].join(""));
    },
    /**
  @param {CharacterSetNode} node
  */ CharacterSet (param, state) {
        let { kind, negate, value, key } = param;
        if (kind === "dot") {
            return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? "." : "[^]" : // Onig's only line break char is line feed, unlike JS
            r(_templateObject27());
        }
        if (kind === "digit") {
            return negate ? r(_templateObject28()) : r(_templateObject29());
        }
        if (kind === "property") {
            if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {
                throw new Error('Unicode property "'.concat(value, "\" can't be case-insensitive when other chars have specific case"));
            }
            return "".concat(negate ? r(_templateObject30()) : r(_templateObject31()), "{").concat(key ? "".concat(key, "=") : "").concat(value, "}");
        }
        if (kind === "word") {
            return negate ? r(_templateObject32()) : r(_templateObject33());
        }
        throw new Error('Unexpected character set kind "'.concat(kind, '"'));
    },
    /**
  @param {FlagsNode} node
  */ Flags (node, state) {
        return(// The transformer should never turn on the properties for flags d, g, m since Onig doesn't
        // have equivs. Flag m is never used since Onig uses different line break chars than JS
        // (node.hasIndices ? 'd' : '') +
        // (node.global ? 'g' : '') +
        // (node.multiline ? 'm' : '') +
        (state.appliedGlobalFlags.ignoreCase ? "i" : "") + (node.dotAll ? "s" : "") + (node.sticky ? "y" : ""));
    },
    /**
  @param {GroupNode} node
  */ Group (param, state, gen) {
        let { atomic: atomic2, body, flags, parent } = param;
        const currentFlags = state.currentFlags;
        if (flags) {
            state.currentFlags = getNewCurrentFlags(currentFlags, flags);
        }
        const contents = body.map(gen).join("|");
        const result = !state.verbose && body.length === 1 && // Single alt
        parent.type !== "Quantifier" && !atomic2 && (!state.useFlagMods || !flags) ? contents : "(?".concat(getGroupPrefix(atomic2, flags, state.useFlagMods)).concat(contents, ")");
        state.currentFlags = currentFlags;
        return result;
    },
    /**
  @param {LookaroundAssertionNode} node
  */ LookaroundAssertion (param, _, gen) {
        let { body, kind, negate } = param;
        const prefix = "".concat(kind === "lookahead" ? "" : "<").concat(negate ? "!" : "=");
        return "(?".concat(prefix).concat(body.map(gen).join("|"), ")");
    },
    /**
  @param {QuantifierNode} node
  */ Quantifier (node, _, gen) {
        return gen(node.body) + getQuantifierStr(node);
    },
    /**
  @param {SubroutineNode & {isRecursive: true}} node
  */ Subroutine (param, state) {
        let { isRecursive, ref } = param;
        if (!isRecursive) {
            throw new Error("Unexpected non-recursive subroutine in transformed AST");
        }
        const limit = state.recursionLimit;
        return ref === 0 ? "(?R=".concat(limit, ")") : r(_templateObject34(), ref, limit);
    }
};
var BaseEscapeChars = /* @__PURE__ */ new Set([
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "?",
    "[",
    "\\",
    "]",
    "^",
    "{",
    "|",
    "}"
]);
var CharClassEscapeChars = /* @__PURE__ */ new Set([
    "-",
    "\\",
    "]",
    "^",
    // Literal `[` doesn't require escaping with flag u, but this can help work around regex source
    // linters and regex syntax processors that expect unescaped `[` to create a nested class
    "["
]);
var CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([
    "(",
    ")",
    "-",
    "/",
    "[",
    "\\",
    "]",
    "^",
    "{",
    "|",
    "}",
    // Double punctuators; also includes already-listed `-` and `^`
    "!",
    "#",
    "$",
    "%",
    "&",
    "*",
    "+",
    ",",
    ".",
    ":",
    ";",
    "<",
    "=",
    ">",
    "?",
    "@",
    "`",
    "~"
]);
var CharCodeEscapeMap = /* @__PURE__ */ new Map([
    [
        9,
        r(_templateObject35())
    ],
    // horizontal tab
    [
        10,
        r(_templateObject36())
    ],
    // line feed
    [
        11,
        r(_templateObject37())
    ],
    // vertical tab
    [
        12,
        r(_templateObject38())
    ],
    // form feed
    [
        13,
        r(_templateObject39())
    ],
    // carriage return
    [
        8232,
        r(_templateObject40())
    ],
    // line separator
    [
        8233,
        r(_templateObject41())
    ],
    // paragraph separator
    [
        65279,
        r(_templateObject42())
    ]
]);
var casedRe = RegExp("^\\p{Cased}$", "u");
function charHasCase(char) {
    return casedRe.test(char);
}
function getCasesOutsideCharClassRange(node, options) {
    const firstOnly = !!(options === null || options === void 0 ? void 0 : options.firstOnly);
    const min = node.min.value;
    const max = node.max.value;
    const found = [];
    if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {
        return found;
    }
    for(let i = min; i <= max; i++){
        const char = cp(i);
        if (!charHasCase(char)) {
            continue;
        }
        const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar)=>{
            const num = caseOfChar.codePointAt(0);
            return num < min || num > max;
        });
        if (charsOutsideRange.length) {
            found.push(...charsOutsideRange);
            if (firstOnly) {
                break;
            }
        }
    }
    return found;
}
function getCharEscape(codePoint, param) {
    let { escDigit, inCharClass, useFlagV } = param;
    if (CharCodeEscapeMap.has(codePoint)) {
        return CharCodeEscapeMap.get(codePoint);
    }
    if (// Control chars, etc.; condition modeled on the Chrome developer console's display for strings
    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area
    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit
    escDigit && isDigitCharCode(codePoint)) {
        return codePoint > 255 ? "\\u{".concat(codePoint.toString(16).toUpperCase(), "}") : "\\x".concat(codePoint.toString(16).toUpperCase().padStart(2, "0"));
    }
    const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;
    const char = cp(codePoint);
    return (escapeChars.has(char) ? "\\" : "") + char;
}
function getCodePointRangesFromChars(chars) {
    const codePoints = chars.map((char)=>char.codePointAt(0)).sort((a, b)=>a - b);
    const values = [];
    let start = null;
    for(let i = 0; i < codePoints.length; i++){
        if (codePoints[i + 1] === codePoints[i] + 1) {
            start !== null && start !== void 0 ? start : start = codePoints[i];
        } else if (start === null) {
            values.push(codePoints[i]);
        } else {
            values.push([
                start,
                codePoints[i]
            ]);
            start = null;
        }
    }
    return values;
}
function getGroupPrefix(atomic2, flagMods, useFlagMods) {
    if (atomic2) {
        return ">";
    }
    let mods = "";
    if (flagMods && useFlagMods) {
        const { enable, disable } = flagMods;
        mods = ((enable === null || enable === void 0 ? void 0 : enable.ignoreCase) ? "i" : "") + ((enable === null || enable === void 0 ? void 0 : enable.dotAll) ? "s" : "") + (disable ? "-" : "") + ((disable === null || disable === void 0 ? void 0 : disable.ignoreCase) ? "i" : "") + ((disable === null || disable === void 0 ? void 0 : disable.dotAll) ? "s" : "");
    }
    return "".concat(mods, ":");
}
function getQuantifierStr(param) {
    let { kind, max, min } = param;
    let base;
    if (!min && max === 1) {
        base = "?";
    } else if (!min && max === Infinity) {
        base = "*";
    } else if (min === 1 && max === Infinity) {
        base = "+";
    } else if (min === max) {
        base = "{".concat(min, "}");
    } else {
        base = "{".concat(min, ",").concat(max === Infinity ? "" : max, "}");
    }
    return base + ({
        greedy: "",
        lazy: "?",
        possessive: "+"
    })[kind];
}
function isAnyGroup(param) {
    let { type } = param;
    return type === "CapturingGroup" || type === "Group" || type === "LookaroundAssertion";
}
function isDigitCharCode(value) {
    return value > 47 && value < 58;
}
function isLiteralHyphen(param) {
    let { type, value } = param;
    return type === "Character" && value === 45;
}
// src/subclass.js
var EmulatedRegExp = (_captureMap = /*#__PURE__*/ new WeakMap(), _compiled = /*#__PURE__*/ new WeakMap(), _pattern = /*#__PURE__*/ new WeakMap(), _nameMap = /*#__PURE__*/ new WeakMap(), _strategy = /*#__PURE__*/ new WeakMap(), _execCore = /*#__PURE__*/ new WeakSet(), __EmulatedRegExp = class _EmulatedRegExp extends RegExp {
    // Override the getter with one that works with lazy-compiled regexes
    get source() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern) || "(?:)";
    }
    /**
  Called internally by all String/RegExp methods that use regexes.
  @override
  @param {string} str
  @returns {RegExpExecArray?}
  */ exec(str) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled)) {
            const { lazyCompile, ...rest } = this.rawOptions;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled, new _EmulatedRegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern), this.flags, rest));
        }
        const useLastIndex = this.global || this.sticky;
        const pos = this.lastIndex;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _strategy) === "clip_search" && useLastIndex && pos) {
            this.lastIndex = 0;
            const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _execCore, execCore).call(this, str.slice(pos));
            if (match) {
                adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);
                this.lastIndex += pos;
            }
            return match;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _execCore, execCore).call(this, str);
    }
    /**
  @overload
  @param {string} pattern
  @param {string} [flags]
  @param {EmulatedRegExpOptions} [options]
  */ /**
  @overload
  @param {EmulatedRegExp} pattern
  @param {string} [flags]
  */ constructor(pattern, flags, options){
        const lazyCompile = !!(options === null || options === void 0 ? void 0 : options.lazyCompile);
        if (pattern instanceof RegExp) {
            if (options) {
                throw new Error("Cannot provide options when copying a regexp");
            }
            const re = pattern;
            super(re, flags), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _execCore), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap, {
                writable: true,
                value: /* @__PURE__ */ new Map()
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled, {
                writable: true,
                value: null
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern, {
                writable: true,
                value: void 0
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap, {
                writable: true,
                value: null
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _strategy, {
                writable: true,
                value: null
            }), /**
  Can be used to serialize the instance.
  @type {EmulatedRegExpOptions}
  */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "rawOptions", {});
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern, re.source);
            if (re instanceof _EmulatedRegExp) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(re, _captureMap));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(re, _nameMap));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _strategy, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(re, _strategy));
                this.rawOptions = re.rawOptions;
            }
        } else {
            const opts = {
                hiddenCaptures: [],
                strategy: null,
                transfers: [],
                ...options
            };
            super(lazyCompile ? "" : pattern, flags), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_method_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _execCore), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap, {
                writable: true,
                value: new Map()
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled, {
                writable: true,
                value: null
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern, {
                writable: true,
                value: void 0
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap, {
                writable: true,
                value: null
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _strategy, {
                writable: true,
                value: null
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "rawOptions", {});
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _pattern, pattern);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap, createCaptureMap(opts.hiddenCaptures, opts.transfers));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _strategy, opts.strategy);
            this.rawOptions = options !== null && options !== void 0 ? options : {};
        }
        if (!lazyCompile) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled, this);
        }
    }
}, __EmulatedRegExp);
function adjustMatchDetailsForOffset(match, offset, input, hasIndices) {
    match.index += offset;
    match.input = input;
    if (hasIndices) {
        const indices = match.indices;
        for(let i = 0; i < indices.length; i++){
            const arr = indices[i];
            if (arr) {
                indices[i] = [
                    arr[0] + offset,
                    arr[1] + offset
                ];
            }
        }
        const groupIndices = indices.groups;
        if (groupIndices) {
            Object.keys(groupIndices).forEach((key)=>{
                const arr = groupIndices[key];
                if (arr) {
                    groupIndices[key] = [
                        arr[0] + offset,
                        arr[1] + offset
                    ];
                }
            });
        }
    }
}
function createCaptureMap(hiddenCaptures, transfers) {
    const captureMap = /* @__PURE__ */ new Map();
    for (const num of hiddenCaptures){
        captureMap.set(num, {
            hidden: true
        });
    }
    for (const [to, from] of transfers){
        for (const num of from){
            getOrInsert(captureMap, num, {}).transferTo = to;
        }
    }
    return captureMap;
}
function createNameMap(pattern) {
    const re = RegExp("(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?.", "gsu");
    const map = /* @__PURE__ */ new Map();
    let numCharClassesOpen = 0;
    let numCaptures = 0;
    let match;
    while(match = re.exec(pattern)){
        const { 0: m, groups: { capture, name } } = match;
        if (m === "[") {
            numCharClassesOpen++;
        } else if (!numCharClassesOpen) {
            if (capture) {
                numCaptures++;
                if (name) {
                    map.set(numCaptures, name);
                }
            }
        } else if (m === "]") {
            numCharClassesOpen--;
        }
    }
    return map;
}
;
;
;
function toRegExp(pattern, options) {
    const d = toRegExpDetails(pattern, options);
    if (d.options) {
        return new EmulatedRegExp(d.pattern, d.flags, d.options);
    }
    return new RegExp(d.pattern, d.flags);
}
function toRegExpDetails(pattern, options) {
    const opts = getOptions(options);
    const onigurumaAst = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$parser$2f$dist$2f$parser$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])(pattern, {
        flags: opts.flags,
        normalizeUnknownPropertyNames: true,
        rules: {
            captureGroup: opts.rules.captureGroup,
            singleline: opts.rules.singleline
        },
        skipBackrefValidation: opts.rules.allowOrphanBackrefs,
        unicodePropertyMap: JsUnicodePropertyMap
    });
    const regexPlusAst = transform(onigurumaAst, {
        accuracy: opts.accuracy,
        asciiWordBoundaries: opts.rules.asciiWordBoundaries,
        avoidSubclass: opts.avoidSubclass,
        bestEffortTarget: opts.target
    });
    const generated = generate(regexPlusAst, opts);
    const recursionResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2d$recursion$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["recursion"])(generated.pattern, {
        captureTransfers: generated._captureTransfers,
        hiddenCaptures: generated._hiddenCaptures,
        mode: "external"
    });
    const possessiveResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$atomic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["possessive"])(recursionResult.pattern);
    const atomicResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$regex$2f$src$2f$atomic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atomic"])(possessiveResult.pattern, {
        captureTransfers: recursionResult.captureTransfers,
        hiddenCaptures: recursionResult.hiddenCaptures
    });
    const details = {
        pattern: atomicResult.pattern,
        flags: "".concat(opts.hasIndices ? "d" : "").concat(opts.global ? "g" : "").concat(generated.flags).concat(generated.options.disable.v ? "u" : "v")
    };
    if (opts.avoidSubclass) {
        if (opts.lazyCompileLength !== Infinity) {
            throw new Error("Lazy compilation requires subclass");
        }
    } else {
        const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b)=>a - b);
        const transfers = Array.from(atomicResult.captureTransfers);
        const strategy = regexPlusAst._strategy;
        const lazyCompile = details.pattern.length >= opts.lazyCompileLength;
        if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {
            details.options = {
                ...hiddenCaptures.length && {
                    hiddenCaptures
                },
                ...transfers.length && {
                    transfers
                },
                ...strategy && {
                    strategy
                },
                ...lazyCompile && {
                    lazyCompile
                }
            };
        }
    }
    return details;
}
;
function execCore(str) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled).lastIndex = this.lastIndex;
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__EmulatedRegExp.prototype), "exec", this).call((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled), str);
    this.lastIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _compiled).lastIndex;
    if (!match || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap).size) {
        return match;
    }
    const matchCopy = [
        ...match
    ];
    match.length = 1;
    let indicesCopy;
    if (this.hasIndices) {
        indicesCopy = [
            ...match.indices
        ];
        match.indices.length = 1;
    }
    const mappedNums = [
        0
    ];
    for(let i = 1; i < matchCopy.length; i++){
        var _class_private_field_get_get;
        const { hidden, transferTo } = (_class_private_field_get_get = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _captureMap).get(i)) !== null && _class_private_field_get_get !== void 0 ? _class_private_field_get_get : {};
        if (hidden) {
            mappedNums.push(null);
        } else {
            mappedNums.push(match.length);
            match.push(matchCopy[i]);
            if (this.hasIndices) {
                match.indices.push(indicesCopy[i]);
            }
        }
        if (transferTo && matchCopy[i] !== void 0) {
            const to = mappedNums[transferTo];
            if (!to) {
                throw new Error('Invalid capture transfer to "'.concat(to, '"'));
            }
            match[to] = matchCopy[i];
            if (this.hasIndices) {
                match.indices[to] = indicesCopy[i];
            }
            if (match.groups) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap)) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap, createNameMap(this.source));
                }
                const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _nameMap).get(transferTo);
                if (name) {
                    match.groups[name] = matchCopy[i];
                    if (this.hasIndices) {
                        match.indices.groups[name] = indicesCopy[i];
                    }
                }
            }
        }
    }
    return match;
}
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "J",
    ()=>JavaScriptScanner
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
const MAX = 4294967295;
class JavaScriptScanner {
    findNextMatchSync(string, startPosition, _options) {
        const str = typeof string === "string" ? string : string.content;
        const pending = [];
        function toResult(index, match) {
            let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            return {
                index,
                captureIndices: match.indices.map((indice)=>{
                    if (indice == null) {
                        return {
                            start: MAX,
                            end: MAX,
                            length: 0
                        };
                    }
                    return {
                        start: indice[0] + offset,
                        end: indice[1] + offset,
                        length: indice[1] - indice[0]
                    };
                })
            };
        }
        for(let i = 0; i < this.regexps.length; i++){
            const regexp = this.regexps[i];
            if (!regexp) continue;
            try {
                regexp.lastIndex = startPosition;
                const match = regexp.exec(str);
                if (!match) continue;
                if (match.index === startPosition) {
                    return toResult(i, match, 0);
                }
                pending.push([
                    i,
                    match,
                    0
                ]);
            } catch (e) {
                if (this.options.forgiving) continue;
                throw e;
            }
        }
        if (pending.length) {
            const minIndex = Math.min(...pending.map((m)=>m[1].index));
            for (const [i, match, offset] of pending){
                if (match.index === minIndex) {
                    return toResult(i, match, offset);
                }
            }
        }
        return null;
    }
    constructor(patterns, options = {}){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "regexps", void 0);
        this.patterns = patterns;
        this.options = options;
        const { forgiving = false, cache, regexConstructor } = options;
        if (!regexConstructor) {
            throw new Error("Option `regexConstructor` is not provided");
        }
        this.regexps = patterns.map((p)=>{
            if (typeof p !== "string") {
                return p;
            }
            const cached = cache === null || cache === void 0 ? void 0 : cache.get(p);
            if (cached) {
                if (cached instanceof RegExp) {
                    return cached;
                }
                if (forgiving) return null;
                throw cached;
            }
            try {
                const regex = regexConstructor(p);
                cache === null || cache === void 0 ? void 0 : cache.set(p, regex);
                return regex;
            } catch (e) {
                cache === null || cache === void 0 ? void 0 : cache.set(p, e);
                if (forgiving) return null;
                throw e;
            }
        });
    }
}
;
}),
"[project]/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createJavaScriptRegexEngine",
    ()=>createJavaScriptRegexEngine,
    "defaultJavaScriptRegexConstructor",
    ()=>defaultJavaScriptRegexConstructor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$to$2d$es$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oniguruma-to-es/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$javascript$2f$dist$2f$shared$2f$engine$2d$javascript$2e$hzpS1_41$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs [app-client] (ecmascript)");
;
;
function defaultJavaScriptRegexConstructor(pattern, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oniguruma$2d$to$2d$es$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRegExp"])(pattern, {
        global: true,
        hasIndices: true,
        // This has no benefit for the standard JS engine, but it avoids a perf penalty for
        // precompiled grammars when constructing extremely long patterns that aren't always used
        lazyCompileLength: 3e3,
        rules: {
            // Needed since TextMate grammars merge backrefs across patterns
            allowOrphanBackrefs: true,
            // Improves search performance for generated regexes
            asciiWordBoundaries: true,
            // Follow `vscode-oniguruma` which enables this Oniguruma option by default
            captureGroup: true,
            // Oniguruma uses depth limit `20`; lowered here to keep regexes shorter and maybe
            // sometimes faster, but can be increased if issues reported due to low limit
            recursionLimit: 5,
            // Oniguruma option for `^`->`\A`, `$`->`\Z`; improves search performance without any
            // change in meaning since TM grammars search line by line
            singleline: true
        },
        ...options
    });
}
function createJavaScriptRegexEngine() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _options;
    const _options1 = Object.assign({
        target: "auto",
        cache: /* @__PURE__ */ new Map()
    }, options);
    (_options = _options1).regexConstructor || (_options.regexConstructor = (pattern)=>defaultJavaScriptRegexConstructor(pattern, {
            target: _options1.target
        }));
    return {
        createScanner (patterns) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$javascript$2f$dist$2f$shared$2f$engine$2d$javascript$2e$hzpS1_41$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["J"](patterns, _options1);
        },
        createString (s) {
            return {
                content: s
            };
        }
    };
}
;
}),
"[project]/node_modules/@shikijs/core/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShikiError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"],
    "addClassToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassToHast"],
    "applyColorReplacements",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["applyColorReplacements"],
    "codeToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToHast"],
    "codeToHtml",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToHtml"],
    "codeToTokens",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokens"],
    "codeToTokensBase",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokensBase"],
    "codeToTokensWithThemes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokensWithThemes"],
    "createCssVariablesTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createCssVariablesTheme"],
    "createHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createHighlighterCore"],
    "createHighlighterCoreSync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createHighlighterCoreSync"],
    "createPositionConverter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createPositionConverter"],
    "createShikiInternal",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createShikiInternal"],
    "createShikiInternalSync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createShikiInternalSync"],
    "createSingletonShorthands",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSingletonShorthands"],
    "createdBundledHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createdBundledHighlighter"],
    "enableDeprecationWarnings",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["enableDeprecationWarnings"],
    "flatTokenVariants",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flatTokenVariants"],
    "getSingletonHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getSingletonHighlighterCore"],
    "getTokenStyleObject",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getTokenStyleObject"],
    "guessEmbeddedLanguages",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guessEmbeddedLanguages"],
    "hastToHtml",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hastToHtml"],
    "isNoneTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNoneTheme"],
    "isPlainLang",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPlainLang"],
    "isSpecialLang",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isSpecialLang"],
    "isSpecialTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isSpecialTheme"],
    "makeSingletonHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["makeSingletonHighlighter"],
    "makeSingletonHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["makeSingletonHighlighterCore"],
    "normalizeGetter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeGetter"],
    "normalizeTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeTheme"],
    "resolveColorReplacements",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resolveColorReplacements"],
    "splitLines",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["splitLines"],
    "splitToken",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["splitToken"],
    "splitTokens",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["splitTokens"],
    "stringifyTokenStyle",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["stringifyTokenStyle"],
    "toArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toArray"],
    "tokenizeAnsiWithTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["tokenizeAnsiWithTheme"],
    "tokenizeWithTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["tokenizeWithTheme"],
    "tokensToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["tokensToHast"],
    "transformerDecorations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transformerDecorations"],
    "warnDeprecated",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["warnDeprecated"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/core/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/types/dist/index.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/shiki/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShikiError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShikiError"],
    "addClassToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addClassToHast"],
    "applyColorReplacements",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyColorReplacements"],
    "bundledLanguages",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledLanguages"],
    "bundledLanguagesAlias",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledLanguagesAlias"],
    "bundledLanguagesBase",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledLanguagesBase"],
    "bundledLanguagesInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledLanguagesInfo"],
    "bundledThemes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$themes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledThemes"],
    "bundledThemesInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$themes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bundledThemesInfo"],
    "codeToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToHast"],
    "codeToHtml",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToHtml"],
    "codeToTokens",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokens"],
    "codeToTokensBase",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokensBase"],
    "codeToTokensWithThemes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["codeToTokensWithThemes"],
    "createCssVariablesTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCssVariablesTheme"],
    "createHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createHighlighter"],
    "createHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHighlighterCore"],
    "createHighlighterCoreSync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHighlighterCoreSync"],
    "createJavaScriptRegexEngine",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$javascript$2f$dist$2f$engine$2d$compile$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createJavaScriptRegexEngine"],
    "createOnigurumaEngine",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$oniguruma$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOnigurumaEngine"],
    "createPositionConverter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPositionConverter"],
    "createShikiInternal",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createShikiInternal"],
    "createShikiInternalSync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createShikiInternalSync"],
    "createSingletonShorthands",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSingletonShorthands"],
    "createdBundledHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createdBundledHighlighter"],
    "defaultJavaScriptRegexConstructor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$javascript$2f$dist$2f$engine$2d$compile$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultJavaScriptRegexConstructor"],
    "enableDeprecationWarnings",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enableDeprecationWarnings"],
    "flatTokenVariants",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flatTokenVariants"],
    "getLastGrammarState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getLastGrammarState"],
    "getSingletonHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getSingletonHighlighter"],
    "getSingletonHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSingletonHighlighterCore"],
    "getTokenStyleObject",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTokenStyleObject"],
    "guessEmbeddedLanguages",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["guessEmbeddedLanguages"],
    "hastToHtml",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hastToHtml"],
    "isNoneTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNoneTheme"],
    "isPlainLang",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainLang"],
    "isSpecialLang",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpecialLang"],
    "isSpecialTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpecialTheme"],
    "loadWasm",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$oniguruma$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadWasm"],
    "makeSingletonHighlighter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeSingletonHighlighter"],
    "makeSingletonHighlighterCore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeSingletonHighlighterCore"],
    "normalizeGetter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeGetter"],
    "normalizeTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeTheme"],
    "resolveColorReplacements",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveColorReplacements"],
    "splitLines",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitLines"],
    "splitToken",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitToken"],
    "splitTokens",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitTokens"],
    "stringifyTokenStyle",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyTokenStyle"],
    "toArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"],
    "tokenizeAnsiWithTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokenizeAnsiWithTheme"],
    "tokenizeWithTheme",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokenizeWithTheme"],
    "tokensToHast",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokensToHast"],
    "transformerDecorations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformerDecorations"],
    "warnDeprecated",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warnDeprecated"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$bundle$2d$full$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/bundle-full.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$javascript$2f$dist$2f$engine$2d$compile$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$engine$2d$oniguruma$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/engine-oniguruma/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$shikijs$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@shikijs/core/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$langs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/langs.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shiki$2f$dist$2f$themes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/shiki/dist/themes.mjs [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_c0ad92bc._.js.map