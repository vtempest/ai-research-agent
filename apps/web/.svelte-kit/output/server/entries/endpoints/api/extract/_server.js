import "@langchain/langgraph/prebuilt";
import "@langchain/core/tools";
import "langchain/hub";
import "@langchain/openai";
import "@langchain/anthropic";
import "@langchain/groq";
import "@langchain/community/chat_models/perplexity";
import "@langchain/cloudflare";
import "@langchain/ollama";
import "@langchain/community/llms/togetherai";
import "@langchain/xai";
import "@langchain/google-vertexai-web";
import { b as convertMarkdownToHTML, c as convertURLSafeHTMLToHTML, R as REMOVED_ANNOTATION, f as ADDED_ANNOTATION, B as BlockTypes, D as DETECTED_ANNOTATION, U as UNCHANGED_ANNOTATION, M as MODIFIED_ANNOTATION } from "../../../../chunks/BlockType.js";
import "js-yaml";
import "tldts";
import "katex";
import "marked";
import { e as extractContentAndCite, c as convertHTMLToBasicHTML } from "../../../../chunks/html-to-content.js";
import { resolvePDFJS } from "pdfjs-serverless";
import JSZip from "jszip";
import "linkedom";
import { json } from "@sveltejs/kit";
import "../../../../chunks/schema.js";
import "stripe";
import { i as initializeUser } from "../../../../chunks/auth.js";
import "resend";
import { p as proxyDomain } from "../../../../chunks/customize-site.js";
import "../../../../chunks/validations.js";
async function scrapeURL(url, options = {}) {
  let {
    timeout = 15,
    checkBotDetection = true,
    maxRedirects = 3,
    changeReferer = 0,
    userAgentIndex = 0,
    proxy = null,
    useProxyAsBackup = true,
    checkRobotsAllowed = false
  } = options;
  if (checkRobotsAllowed) {
    const rules = await fetchScrapingRules(url);
    if (!isAllowedToScrape(rules, url)) {
      return { error: "Robots.txt forbids to scrape there" };
    }
  }
  if (proxy)
    url = proxy + url;
  var userAgentStrings = [
    "Chrome/41.0.2272.96 Mobile Safari/537.36 (compatible ; Googlebot/2.1 ; +http://www.google.com/bot.html)",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36,gzip(gfe)"
  ];
  var headers = {
    ...options,
    "User-Agent": userAgentStrings[userAgentIndex],
    signal: AbortSignal.timeout(timeout * 1e3),
    "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
    "accept-language": "en-US,en;q=0.9"
  };
  if (changeReferer)
    headers["Referer"] = "https://www.google.com/";
  let response;
  try {
    response = await fetch(url, headers);
  } catch (e) {
    return { error: "Error in fetch", msg: e.message };
  }
  if (response.redirected) {
    if (maxRedirects <= 0)
      return { error: "Max redirects exceeded" };
    maxRedirects--;
    options = { ...options, maxRedirects };
    return scrapeURL(response.url, options);
  }
  response.headers.get("Content-Type");
  var html = await response.text();
  if (checkBotDetection && checkHTMLForBotDetection(html)) {
    html = await scrapeJINA(url);
    if (checkBotDetection && checkHTMLForBotDetection(html))
      return { error: "Bot detected" };
  }
  return html;
}
async function scrapeJINA(url) {
  var articleExtract = await (await fetch("https://r.jina.ai/" + url)).text();
  var title = articleExtract.match(/Title: (.*)/)?.[1];
  if (articleExtract.includes("===============\n"))
    articleExtract = articleExtract.split("===============\n").slice(1).join(" ");
  var match = articleExtract.match(/Markdown Content:([\s\S]*)/);
  articleExtract = match ? match[1] : articleExtract;
  articleExtract = convertMarkdownToHTML(articleExtract);
  if (title)
    articleExtract = "<title>" + title + "</title>" + articleExtract;
  return articleExtract;
}
function checkHTMLForBotDetection(html) {
  var commonBlocks = [
    "Error 403 - Unavailable",
    "The security system for this website has been triggered",
    "You do not have permission to view this page.",
    "Our systems have detected unusual traffic from your computer network.",
    "Your request has been blocked due to a network policy.",
    "Cloudflare Ray ID found ",
    "Please verify you are a human",
    "Our systems have detected unusual traffic activity from your network. Please complete this reCAPTCHA",
    "Sorry, we just need to make sure you're not a robot",
    "Access to this page has been denied",
    "<p>Please enable JS and disable any ad blocker",
    "Please make sure your browser supports JavaScript",
    "Please complete the security check to access",
    "https://errors.edgesuite.net",
    "Please enable JS and disable any ad blocker",
    "The resource you are looking for might have been removed, had its name changed, or is temporarily unavailable.",
    "We’re currently checking your connection. This shouldn’t take long.",
    "Generated by cloudfront (CloudFront)",
    "You don't have permission to access",
    "The request could not be satisfied.",
    "Enable JavaScript and cookies to continue",
    "Something went wrong. Wait a moment and try again.",
    "You’re using a web browser that isn’t supported",
    "403 Forbidden",
    "504 Gateway Timeout",
    "You’re Temporarily Blocked",
    "Our systems have detected unusual activity",
    "Agree & Join LinkedIn",
    "Verifying you are human. This may take a few seconds",
    "500 Internal Server Error",
    "By clicking Continue to join or sign in, you agree to LinkedIn",
    "Enable JS in your browser",
    "Verifying you are human",
    "Your request has been blocked",
    "You've been blocked by network security",
    "You've hit the rate limit."
  ];
  return commonBlocks.filter((m) => html?.indexOf(m) > -1).length > 0;
}
async function fetchScrapingRules(url) {
  const robotsUrl = `https://${url.split("//")[1].split("/")[0]}/robots.txt`;
  try {
    const content2 = await (await fetch(robotsUrl)).text();
  } catch (e) {
    return { error: "No robots.txt found" };
  }
  const rules = {
    directives: {},
    crawlDelay: {},
    sitemaps: [],
    preferredHost: null
  };
  let currentUserAgents = [];
  const lines = content.split("\n");
  for (const line of lines) {
    const [directive, value] = line.split(":").map((s) => s.trim());
    switch (directive.toLowerCase()) {
      case "user-agent":
        currentUserAgents = [value.toLowerCase()];
        break;
      case "disallow":
      case "allow":
        for (const ua of currentUserAgents) {
          rules.directives[ua] = rules.directives[ua] || [];
          rules.directives[ua].push({ path: value, allow: directive.toLowerCase() === "allow" });
        }
        break;
      case "crawl-delay":
        for (const ua of currentUserAgents) {
          rules.crawlDelay[ua] = parseFloat(value);
        }
        break;
      case "sitemap":
        rules.sitemaps.push(value);
        break;
      case "host":
        rules.preferredHost = value.toLowerCase();
        break;
    }
  }
  return rules;
}
function isAllowedToScrape(rules, path, userAgent = "*") {
  const relevantRules = rules.directives[userAgent.toLowerCase()] || rules.directives["*"] || [];
  for (const rule of relevantRules)
    if (path.startsWith(rule.path))
      return rule.allow;
  return true;
}
async function convertYoutubeToText(videoUrl, options = {}) {
  const {
    addTimestamps = true,
    addPlayer = true,
    timeout = 10,
    proxy = null
  } = options;
  var videoId = getURLYoutubeVideo(videoUrl), res = {};
  res = await fetchTranscriptTactiq(videoId, options);
  if (!res.content || res.error)
    res = await fetchTranscriptOfficialYoutube(videoId, options);
  if (!res.content || res.error)
    res = await fetchViaYoutubeToTranscriptCom(videoId, options);
  if (!res.content || res.error)
    res = await fetchViaYoutubeTranscript(videoId, options);
  var { date, title, author_cite, length } = await extractYouTubeInfo(videoId, options);
  if (!res.content || res.error) return { error: 1 };
  var { content: content2, timestamps } = res;
  var word_count = content2.split(" ").length;
  content2 = convertURLSafeHTMLToHTML(content2);
  var speedsEveryCharPeriod = {};
  const valueCharPeriod = 100;
  for (var timestamp of timestamps) {
    var [char, time] = timestamp;
    var speed = Math.floor(char / time) - 10;
    speedsEveryCharPeriod[Math.floor(char / valueCharPeriod)] = speed;
  }
  var speeds = Object.keys(speedsEveryCharPeriod).map(
    (timeKey) => speedsEveryCharPeriod[timeKey]
  );
  let compressed = [];
  let compressedCount = [];
  let currentNum = speeds[0];
  let count = 1;
  for (let i = 1; i < speeds.length; i++) {
    if (speeds[i] === currentNum) {
      count++;
    } else {
      compressed.push(currentNum);
      compressedCount.push(count);
      currentNum = speeds[i];
      count = 1;
    }
  }
  compressed.push(currentNum);
  compressedCount.push(count);
  var total = 0;
  compressedCount = compressedCount.map((c) => {
    total += c;
    return total;
  });
  content2 = content2.replace(/\s+/g, " ");
  speeds = compressed.join(",") + "  " + compressedCount.join(",");
  if (addPlayer)
    content2 = `<iframe width="100%" height="315px" data-timestamps="${speeds}" 
    src="https://www.youtube.com/embed/${videoId}" frameborder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; 
    gyroscope; picture-in-picture" allowfullscreen></iframe>${content2}`;
  var source = "YouTube";
  return { html: content2, word_count, source, date, title, author_cite, length };
}
function getURLYoutubeVideo(url) {
  var match = url?.match(
    /(?:\/embed\/|v=|v\/|vi\/|youtu\.be\/|\/v\/|^https?:\/\/(?:www\.)?youtube\.com\/(?:(?:watch)?\?.*v=|(?:embed|v|vi|user)\/))([^#\&\?]*).*/
  );
  return match ? match[1] : false;
}
async function fetchViaYoutubeToTranscriptCom(videoId, options = {}) {
  const url = `https://youtubetotranscript.com/transcript?v=${videoId}&current_language_code=en`;
  var html = await scrapeURL(url, options);
  if (!html) return { error: 1 };
  html = html?.replace(/[\r\n]/gi, " ");
  const titleRegex = /<h1[^>]*>([^<]+)<\/h1>/gi;
  var title = html?.match(titleRegex)?.[1];
  title = title?.replace(/<[^>]*>/g, "")?.replace("Transcript of ", "")?.trim();
  const authorRegex = /Author\s*:\s*<a[\s\S]*?>\s*(.*?)\s*<\/a\s*>/;
  var author_cite = html.match(authorRegex)?.[1];
  const transcriptRegex = /<span[^>]*?data-start="([\d.]+)"[^>]*?class="transcript-segment"[^>]*?>[\s\n]*((?:(?!<\/span>).|\n)*?)[\s\n]*<\/span>/gms;
  const matches = Array.from(html.matchAll(transcriptRegex));
  const transcript = matches.map((match) => ({
    text: match[2]?.replace(/<br\s*\/?>/gi, " ")?.trim(),
    offset: parseFloat(match[1])
  }));
  const content2 = transcript.map((item) => item.text).join(" ");
  let timestamps = [];
  let charIndex = 0;
  transcript.forEach((item) => {
    timestamps.push([charIndex, Math.floor(item.offset)]);
    charIndex += item.text.length + 1;
  });
  return { content: content2, title, author_cite, timestamps };
}
async function fetchTranscriptTactiq(videoId, options = {}) {
  try {
    var data = await (await fetch(
      "https://tactiq-apps-prod.tactiq.io/transcript",
      {
        "headers": {
          "content-type": "application/json"
        },
        "body": '{"videoUrl":"https://www.youtube.com/watch?v=' + videoId + '"}',
        "method": "POST"
      }
    )).text();
    if (data.startsWith("{"))
      data = JSON.parse(data);
    if (!data.captions || data.captions.length === 0) {
      return { error: true };
    }
    let content2 = "";
    let timestamps = [];
    let currentLength = 0;
    data.captions.forEach(({ start, dur, text }) => {
      timestamps.push([currentLength, Math.floor(parseFloat(start))]);
      content2 += text + " ";
      currentLength = content2.length;
    });
    return { content: content2, timestamps };
  } catch (error) {
    console.error("Error fetching transcript:", error);
    return { error: true };
  }
}
async function fetchViaYoutubeTranscript(videoId, options = {}) {
  const url = "https://youtubetranscript.com/?server_vid2=" + videoId;
  var html = await (await fetch(url)).text();
  const transcriptRegex = /<text start="([\d.]+)" dur="[\d.]+">((?:(?!<\/text>).|\n)*?)<\/text>/gms;
  const matches = Array.from(html.matchAll(transcriptRegex));
  const transcript = matches.map((match) => ({
    text: match[2],
    offset: parseFloat(match[1])
  }));
  const content2 = transcript.map((item) => item.text).join(" ");
  let timestamps = [];
  let charIndex = 0;
  if (content2.includes("YouTube is currently blocking us from fetching"))
    return { error: 1 };
  transcript.forEach((item) => {
    timestamps.push([charIndex, Math.floor(item.offset)]);
    charIndex += item.text.length + 1;
  });
  return { content: content2, timestamps };
}
async function extractYouTubeInfo(videoId, options = {}) {
  var htmlString = await scrapeURL(
    `https://www.youtube.com/watch?v=${videoId}`,
    options
  );
  if (htmlString?.error || htmlString.includes('class="g-recaptcha"') || !htmlString.includes('"playabilityStatus":')) return { error: 1 };
  htmlString = htmlString?.replace(/\n/g, "");
  const result = {};
  const datePattern = /id="info"[^>]*>(?:.*?)(?:(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},\s+\d{4}|\d+\s+(?:second|minute|hour|day|week|month|year)s?\s+ago)/gi;
  const dateMatch = htmlString.match(datePattern);
  if (dateMatch) {
    const absoluteDatePattern = /(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},\s+\d{4}/;
    const relativeDatePattern = /\d+\s+(?:second|minute|hour|day|week|month|year)s?\s+ago/i;
    const absoluteMatch = dateMatch[0].match(absoluteDatePattern);
    const relativeMatch = dateMatch[0].match(relativeDatePattern);
    if (absoluteMatch) {
      result.date = absoluteMatch[0];
    } else if (relativeMatch) {
      const relative = relativeMatch[0];
      const [amount, unit] = relative.split(" ");
      const now = /* @__PURE__ */ new Date();
      const date = new Date(now);
      switch (unit?.toLowerCase()) {
        case "second":
        case "seconds":
          date.setSeconds(now.getSeconds() - parseInt(amount));
          break;
        case "minute":
        case "minutes":
          date.setMinutes(now.getMinutes() - parseInt(amount));
          break;
        case "hour":
        case "hours":
          date.setHours(now.getHours() - parseInt(amount));
          break;
        case "day":
        case "days":
          date.setDate(now.getDate() - parseInt(amount));
          break;
        case "week":
        case "weeks":
          date.setDate(now.getDate() - parseInt(amount) * 7);
          break;
        case "month":
        case "months":
          date.setMonth(now.getMonth() - parseInt(amount));
          break;
        case "year":
        case "years":
          date.setFullYear(now.getFullYear() - parseInt(amount));
          break;
      }
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const formatted = `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      result.date = formatted;
    }
  } else {
    result.date = null;
  }
  const titlePattern = /"title":"([^"]+)"/;
  const titleMatch = htmlString.match(titlePattern);
  result.title = titleMatch ? titleMatch[1] : null;
  const authorPattern = /"author":"([^"]+)"/;
  const authorMatch = htmlString.match(authorPattern);
  result.author_cite = authorMatch ? authorMatch[1] : null;
  const lengthPattern = /"lengthSeconds":"(\d+)"/;
  const lengthMatch = htmlString.match(lengthPattern);
  result.length = lengthMatch ? parseInt(lengthMatch[1]) : null;
  return result;
}
async function fetchTranscriptOfficialYoutube(videoId, options = {}) {
  const videoPageBody = await scrapeURL(
    `https://www.youtube.com/watch?v=${videoId}`,
    options
  );
  if (videoPageBody?.error || videoPageBody.includes('class="g-recaptcha"') || !videoPageBody.includes('"playabilityStatus":'))
    return { error: 1 };
  var videoObj = videoPageBody.replace("\n", "").split('"captions":')?.[1]?.split(',"videoDetails')[0];
  if (!videoObj) return { error: 2 };
  const captions = JSON.parse(videoObj)?.playerCaptionsTracklistRenderer;
  if (!captions?.captionTracks) return { error: 3 };
  const track = captions.captionTracks.find(
    (track2) => track2.languageCode === "en"
  );
  if (!track) return { error: 4 };
  options.proxy = null;
  const transcriptBody = await scrapeURL(track.baseUrl, options);
  if (transcriptBody.error) return { error: true };
  const results = [
    ...transcriptBody.matchAll(
      /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g
    )
  ];
  var transcript = results.map(([, start, duration, text]) => ({
    text,
    duration: parseFloat(duration),
    offset: parseFloat(start),
    lang: track.languageCode
  }));
  var content2 = "";
  var timestamps = [];
  transcript.forEach(({ offset, text }) => {
    timestamps.push([content2.length, Math.floor(offset, 0)]);
    content2 += text + " ";
  });
  return { content: content2, timestamps };
}
const MIN_DIGIT_CHAR_CODE = 48;
const MAX_DIGIT_CHAR_CODE = 57;
const WHITESPACE_CHAR_CODE = 32;
const TAB_CHAR_CODE = 9;
const DOT_CHAR_CODE = 46;
function removeLeadingWhitespaces(string) {
  while (string.charCodeAt(0) === WHITESPACE_CHAR_CODE) {
    string = string.substring(1, string.length);
  }
  return string;
}
function removeTrailingWhitespaces(string) {
  while (string.charCodeAt(string.length - 1) === WHITESPACE_CHAR_CODE) {
    string = string.substring(0, string.length - 1);
  }
  return string;
}
function isDigit(charCode) {
  return charCode >= MIN_DIGIT_CHAR_CODE && charCode <= MAX_DIGIT_CHAR_CODE;
}
function isNumber(string) {
  for (var i = 0; i < string.length; i++) {
    const charCode = string.charCodeAt(i);
    if (!isDigit(charCode)) {
      return false;
    }
  }
  return true;
}
function hasOnly(string, char) {
  const charCode = char.charCodeAt(0);
  for (var i = 0; i < string.length; i++) {
    const aCharCode = string.charCodeAt(i);
    if (aCharCode !== charCode) {
      return false;
    }
  }
  return true;
}
function normalizedCharCodeArray(string) {
  string = string.toUpperCase();
  return charCodeArray(string).filter((charCode) => charCode !== WHITESPACE_CHAR_CODE && charCode !== TAB_CHAR_CODE && charCode !== DOT_CHAR_CODE);
}
function charCodeArray(string) {
  const charCodes = [];
  for (var i = 0; i < string.length; i++) {
    charCodes.push(string.charCodeAt(i));
  }
  return charCodes;
}
function isListItemCharacter(string) {
  if (string.length > 1) {
    return false;
  }
  const char = string.charAt(0);
  return char === "-" || char === "•" || char === "–";
}
function isListItem(string) {
  return /^[\s]*[-•–][\s].*$/g.test(string);
}
function isNumberedListItem(string) {
  return /^[\s]*[\d]*[.][\s].*$/g.test(string);
}
function wordMatch(string1, string2) {
  const words1 = new Set(string1.toUpperCase().split(" "));
  const words2 = new Set(string2.toUpperCase().split(" "));
  const intersection = new Set(
    [...words1].filter((x) => words2.has(x))
  );
  return intersection.size / Math.max(words1.size, words2.size);
}
const searchRange = (numerator, denominator, length) => {
  return Math.floor(numerator / denominator * length);
};
const searchArea = (range, pageIndexNumMap, pageIndex) => {
  for (const { str } of range) {
    const trimLeadingWhitespaces = removeLeadingWhitespaces(str);
    const trimWhitespaces = removeTrailingWhitespaces(trimLeadingWhitespaces);
    if (isNumber(trimWhitespaces)) {
      if (!pageIndexNumMap[pageIndex]) {
        pageIndexNumMap[pageIndex] = [];
      }
      pageIndexNumMap[pageIndex].push(Number(trimWhitespaces));
    }
  }
  return pageIndexNumMap;
};
const findPageNumbers = (pageIndexNumMap, pageIndex, items) => {
  const topArea = searchRange(1, 6, items.length);
  const bottomArea = searchRange(5, 6, items.length);
  const topAreaResult = searchArea(items.slice(0, topArea), pageIndexNumMap, pageIndex);
  return searchArea(items.slice(bottomArea), topAreaResult, pageIndex);
};
const findFirstPage = (pageIndexNumMap) => {
  let counter = 0;
  const keys = Object.keys(pageIndexNumMap);
  if (keys.length === 0 || keys.length === 1) {
    return;
  }
  for (let x = 0; x < keys.length - 1; x++) {
    const firstPage = pageIndexNumMap[keys[x]];
    const secondPage = pageIndexNumMap[keys[x + 1]];
    const prevCounter = counter;
    for (let y = 0; y < firstPage.length && counter < 2; y++) {
      for (let z = 0; z < secondPage.length && counter < 2; z++) {
        const pageDifference = keys[x + 1] - keys[x];
        if (firstPage[y] + 1 === secondPage[z]) {
          counter++;
        } else if (pageDifference > 1 && firstPage[y] + pageDifference === secondPage[z]) {
          counter++;
        }
      }
    }
    let pageDetails = x > 0 ? Object.entries(pageIndexNumMap)[x - 1] : Object.entries(pageIndexNumMap)[x];
    if (prevCounter === counter) {
      counter = 0;
      pageDetails = Object.entries(pageIndexNumMap)[x];
    } else if (counter >= 2) {
      return { pageIndex: Number(pageDetails[0]), pageNum: pageDetails[1][0] };
    }
  }
};
const removePageNumber = (textContent, pageNum) => {
  const filteredContent = { items: [...textContent.items] };
  const topArea = searchRange(1, 6, filteredContent.items.length);
  const bottomArea = searchRange(5, 6, filteredContent.items.length);
  filteredContent.items = filteredContent.items.filter((item, index) => {
    const isAtTop = index > 0 && index < topArea;
    const isAtBottom = index > bottomArea && index < filteredContent.items.length;
    return isAtTop || isAtBottom ? Number(item.str) !== Number(pageNum) : item;
  });
  return filteredContent;
};
let PageItem$1 = class PageItem {
  constructor(options) {
    if (this.constructor === PageItem) {
      throw new TypeError("Can not construct abstract class.");
    }
    this.type = options.type;
    this.annotation = options.annotation;
    this.parsedElements = options.parsedElements;
  }
};
class TextItem extends PageItem$1 {
  constructor(options) {
    super(options);
    this.x = options.x;
    this.y = options.y;
    this.width = options.width;
    this.height = options.height;
    this.text = options.text;
    this.font = options.font;
    this.lineFormat = options.lineFormat;
    this.unopenedFormat = options.unopenedFormat;
    this.unclosedFormat = options.unclosedFormat;
  }
}
class Page {
  constructor(options) {
    this.index = options.index;
    this.items = options.items || [];
  }
}
class Transformation {
  constructor(name, itemType) {
    if (this.constructor === Transformation) {
      throw new TypeError("Can not construct abstract class.");
    }
    if (this.transform === Transformation.prototype.transform) {
      throw new TypeError("Please implement abstract method 'transform()'.");
    }
    this.name = name;
    this.itemType = itemType;
  }
  // Transform an incoming ParseResult into an outgoing ParseResult
  transform(parseResult) {
    throw new TypeError("Do not call abstract method foo from child.");
  }
  // Sometimes the transform() does only visualize a change. This methods then does the actual change.
  completeTransform(parseResult) {
    parseResult.messages = [];
    return parseResult;
  }
}
class ToTextItemTransformation extends Transformation {
  constructor(name) {
    super(name, TextItem.name);
    if (this.constructor === ToTextItemTransformation) {
      throw new TypeError("Can not construct abstract class.");
    }
  }
  completeTransform(parseResult) {
    parseResult.messages = [];
    parseResult.pages.forEach((page) => {
      page.items = page.items.filter((item) => !item.annotation || item.annotation !== REMOVED_ANNOTATION);
      page.items.forEach((item) => item.annotation = null);
    });
    return parseResult;
  }
}
class ParseResult {
  constructor(options) {
    this.pages = options.pages;
    this.globals = options.globals;
    this.messages = options.messages;
  }
}
class Word {
  constructor(options) {
    this.string = options.string;
    this.type = options.type;
    this.format = options.format;
  }
}
class PageItem2 {
  constructor(options) {
    if (this.constructor === PageItem2) {
      throw new TypeError("Can not construct abstract class.");
    }
    this.type = options.type;
    this.annotation = options.annotation;
    this.parsedElements = options.parsedElements;
  }
}
class LineItem extends PageItem2 {
  constructor(options) {
    super(options);
    this.x = options.x;
    this.y = options.y;
    this.width = options.width;
    this.height = options.height;
    this.words = options.words || [];
    if (options.text && !options.words) {
      this.words = options.text.split(" ").filter((string) => string.trim().length > 0).map((wordAsString) => new Word({
        string: wordAsString
      }));
    }
  }
  text() {
    return this.wordStrings().join(" ");
  }
  wordStrings() {
    return this.words.map((word) => word.string);
  }
}
class StashingStream {
  constructor() {
    if (this.constructor === StashingStream) {
      throw new TypeError("Can not construct abstract class.");
    }
    this.results = [];
    this.stash = [];
  }
  consumeAll(items) {
    items.forEach((item) => this.consume(item));
  }
  consume(item) {
    if (this.shouldStash(item)) {
      if (!this.matchesStash(item)) {
        this.flushStash();
      }
      this.pushOnStash(item);
    } else {
      if (this.stash.length > 0) {
        this.flushStash();
      }
      this.results.push(item);
    }
  }
  pushOnStash(item) {
    this.onPushOnStash(item);
    this.stash.push(item);
  }
  complete() {
    if (this.stash.length > 0) {
      this.flushStash();
    }
    return this.results;
  }
  // return true if the item matches the items of the stack
  matchesStash(item) {
    if (this.stash.length === 0) {
      return true;
    }
    const lastItem = this.stash[this.stash.length - 1];
    return this.doMatchesStash(lastItem, item);
  }
  flushStash() {
    if (this.stash.length > 0) {
      this.doFlushStash(this.stash, this.results);
      this.stash = [];
    }
  }
  onPushOnStash(item) {
  }
  shouldStash(item) {
    throw new TypeError(" Do not call abstract method foo from child." + item);
  }
  doMatchesStash(lastItem, item) {
    throw new TypeError(" Do not call abstract method foo from child." + lastItem + item);
  }
  doFlushStash(stash, results) {
    throw new TypeError(" Do not call abstract method foo from child." + stash + results);
  }
}
class ParsedElements {
  constructor(options) {
    this.footnoteLinks = options.footnoteLinks || [];
    this.footnotes = options.footnotes || [];
    this.containLinks = options.containLinks;
    this.formattedWords = options.formattedWords;
  }
  add(parsedElements) {
    this.footnoteLinks = this.footnoteLinks.concat(parsedElements.footnoteLinks);
    this.footnotes = this.footnotes.concat(parsedElements.footnotes);
    this.containLinks = this.containLinks || parsedElements.containLinks;
    this.formattedWords += parsedElements.formattedWords;
  }
}
function minXFromBlocks(blocks) {
  var minX = 999;
  blocks.forEach((block) => {
    block.items.forEach((item) => {
      minX = Math.min(minX, item.x);
    });
  });
  if (minX === 999) {
    return null;
  }
  return minX;
}
function minXFromPageItems(items) {
  var minX = 999;
  items.forEach((item) => {
    minX = Math.min(minX, item.x);
  });
  if (minX === 999) {
    return null;
  }
  return minX;
}
function sortByX(items) {
  items.sort((a, b) => a.x - b.x);
}
const WordFormat = {
  BOLD: {
    name: "BOLD",
    startSymbol: "<strong>",
    endSymbol: "</strong>"
  },
  OBLIQUE: {
    name: "OBLIQUE",
    startSymbol: "<em>",
    endSymbol: "</em>"
  },
  BOLD_OBLIQUE: {
    name: "BOLD_OBLIQUE",
    startSymbol: "<strong><em>",
    endSymbol: "</em></strong>"
  }
};
const WordType = {
  LINK: {
    name: "LINK",
    toText(string) {
      return `<a href="${string}">${string}</a>`;
    }
  },
  FOOTNOTE_LINK: {
    name: "FOOTNOTE_LINK",
    attachWithoutWhitespace: true,
    plainTextFormat: true,
    toText(string) {
      return `<sup><a href="#${string}">${string}</a></sup>`;
    }
  },
  FOOTNOTE: {
    name: "FOOTNOTE",
    toText(string) {
      return `<p id="${string}">^${string}</p>`;
    }
  }
};
class LineConverter {
  constructor(fontToFormats) {
    this.fontToFormats = fontToFormats;
  }
  // returns a CombineResult
  compact(textItems) {
    sortByX(textItems);
    const wordStream = new WordDetectionStream(this.fontToFormats);
    wordStream.consumeAll(textItems.map((item) => new TextItem({ ...item })));
    const words = wordStream.complete();
    var maxHeight = 0;
    var widthSum = 0;
    textItems.forEach((item) => {
      maxHeight = Math.max(maxHeight, item.height);
      widthSum += item.width;
    });
    return new LineItem({
      x: textItems[0].x,
      y: textItems[0].y,
      height: maxHeight,
      width: widthSum,
      words,
      parsedElements: new ParsedElements({
        footnoteLinks: wordStream.footnoteLinks,
        footnotes: wordStream.footnotes,
        containLinks: wordStream.containLinks,
        formattedWords: wordStream.formattedWords
      })
    });
  }
}
class WordDetectionStream extends StashingStream {
  constructor(fontToFormats) {
    super();
    this.fontToFormats = fontToFormats;
    this.footnoteLinks = [];
    this.footnotes = [];
    this.formattedWords = 0;
    this.containLinks = false;
    this.stashedNumber = false;
  }
  shouldStash(item) {
    if (!this.firstY) {
      this.firstY = item.y;
    }
    this.currentItem = item;
    return true;
  }
  onPushOnStash(item) {
    this.stashedNumber = isNumber(item.text.trim());
  }
  doMatchesStash(lastItem, item) {
    const lastItemFormat = this.fontToFormats.get(lastItem.font);
    const itemFormat = this.fontToFormats.get(item.font);
    if (lastItemFormat !== itemFormat) {
      return false;
    }
    const itemIsANumber = isNumber(item.text.trim());
    return this.stashedNumber === itemIsANumber;
  }
  doFlushStash(stash, results) {
    if (this.stashedNumber) {
      const joinedNumber = stash.map((item) => item.text).join("").trim();
      if (stash[0].y > this.firstY) {
        results.push(new Word({
          string: `${joinedNumber}`,
          type: WordType.FOOTNOTE_LINK
        }));
        this.footnoteLinks.push(parseInt(joinedNumber));
      } else if (this.currentItem && this.currentItem.y < stash[0].y) {
        results.push(new Word({
          string: `${joinedNumber}`,
          type: WordType.FOOTNOTE
        }));
        this.footnotes.push(joinedNumber);
      } else {
        this.copyStashItemsAsText(stash, results);
      }
    } else {
      this.copyStashItemsAsText(stash, results);
    }
  }
  copyStashItemsAsText(stash, results) {
    const format = this.fontToFormats.get(stash[0].font);
    results.push(...this.itemsToWords(stash, format));
  }
  itemsToWords(items, formatName) {
    const combinedText = combineText(items);
    const words = combinedText.split(" ");
    const format = formatName ? WordFormat.enumValueOf(formatName) : null;
    return words.filter((w) => w.trim().length > 0).map((word) => {
      var type = null;
      if (word.startsWith("http:")) {
        this.containLinks = true;
        type = WordType.LINK;
      } else if (word.startsWith("www.")) {
        this.containLinks = true;
        word = `http://${word}`;
        type = WordType.LINK;
      }
      if (format) {
        this.formattedWords++;
      }
      return new Word({ string: word, type, format });
    });
  }
}
function combineText(textItems) {
  var text = "";
  var lastItem;
  textItems.forEach((textItem) => {
    var textToAdd = textItem.text;
    if (!text.endsWith(" ") && !textToAdd.startsWith(" ")) {
      if (lastItem) {
        const xDistance = textItem.x - lastItem.x - lastItem.width;
        if (xDistance > 5) {
          text += " ";
        }
      } else {
        if (isListItemCharacter(textItem.text)) {
          textToAdd += " ";
        }
      }
    }
    text += textToAdd;
    lastItem = textItem;
  });
  return text;
}
class CalculateGlobalStats extends ToTextItemTransformation {
  constructor(fontMap) {
    super("$1");
    this.fontMap = fontMap;
  }
  transform(parseResult) {
    const heightToOccurrence = {};
    const fontToOccurrence = {};
    var maxHeight = 0;
    var maxHeightFont;
    parseResult.pages.forEach((page) => {
      page.items.forEach((item) => {
        if (!item.height) return;
        heightToOccurrence[item.height] = heightToOccurrence[item.height] ? heightToOccurrence[item.height] + 1 : 1;
        fontToOccurrence[item.font] = fontToOccurrence[item.font] ? fontToOccurrence[item.font] + 1 : 1;
        if (item.height > maxHeight) {
          maxHeight = item.height;
          maxHeightFont = item.font;
        }
      });
    });
    const mostUsedHeight = parseInt(getMostUsedKey(heightToOccurrence));
    const mostUsedFont = getMostUsedKey(fontToOccurrence);
    const distanceToOccurrence = {};
    parseResult.pages.forEach((page) => {
      var lastItemOfMostUsedHeight;
      page.items.forEach((item) => {
        if (item.height === mostUsedHeight && item.text.trim().length > 0) {
          if (lastItemOfMostUsedHeight && item.y !== lastItemOfMostUsedHeight.y) {
            const distance = lastItemOfMostUsedHeight.y - item.y;
            if (distance > 0) {
              distanceToOccurrence[distance] = distanceToOccurrence[distance] ? distanceToOccurrence[distance] + 1 : 1;
            }
          }
          lastItemOfMostUsedHeight = item;
        } else {
          lastItemOfMostUsedHeight = null;
        }
      });
    });
    const mostUsedDistance = parseInt(getMostUsedKey(distanceToOccurrence));
    const fontIdToName = [];
    const fontToFormats = /* @__PURE__ */ new Map();
    this.fontMap?.forEach(function(value, key) {
      fontIdToName.push(key + " = " + value.name);
      const fontName = value.name.toLowerCase();
      var format;
      if (key === mostUsedFont) {
        format = null;
      } else if (fontName.includes("bold") && (fontName.includes("oblique") || fontName.includes("italic"))) {
        format = LineConverter.BOLD_OBLIQUE;
      } else if (fontName.includes("bold")) {
        format = LineConverter.BOLD;
      } else if (fontName.includes("oblique") || fontName.includes("italic")) {
        format = LineConverter.OBLIQUE;
      } else if (fontName === maxHeightFont) {
        format = LineConverter.BOLD;
      }
      if (format) {
        fontToFormats.set(key, format.name);
      }
    });
    fontIdToName.sort();
    const newPages = parseResult.pages.map((page) => {
      return {
        ...page,
        items: page.items.map((textItem) => ({ ...textItem }))
      };
    });
    return new ParseResult({
      ...parseResult,
      pages: newPages,
      globals: {
        mostUsedHeight,
        mostUsedFont,
        mostUsedDistance,
        maxHeight,
        maxHeightFont,
        fontToFormats
      },
      messages: [
        "Items per height: " + JSON.stringify(heightToOccurrence),
        "Items per font: " + JSON.stringify(fontToOccurrence),
        "Items per distance: " + JSON.stringify(distanceToOccurrence),
        "Fonts:" + JSON.stringify(fontIdToName)
      ]
    });
  }
}
function getMostUsedKey(keyToOccurrence) {
  var maxOccurence = 0;
  var maxKey;
  Object.keys(keyToOccurrence).map((element) => {
    if (!maxKey || keyToOccurrence[element] > maxOccurence) {
      maxOccurence = keyToOccurrence[element];
      maxKey = element;
    }
  });
  return maxKey;
}
class ToLineItemTransformation extends Transformation {
  constructor(name) {
    super(name, LineItem.name);
    if (this.constructor === ToLineItemTransformation) {
      throw new TypeError("Can not construct abstract class.");
    }
  }
  completeTransform(parseResult) {
    parseResult.messages = [];
    parseResult.pages.forEach((page) => {
      page.items = page.items.filter((item) => !item.annotation || item.annotation !== REMOVED_ANNOTATION);
      page.items.forEach((item) => item.annotation = null);
    });
    return parseResult;
  }
}
class TextItemLineGrouper {
  constructor(options) {
    this.mostUsedDistance = options.mostUsedDistance || 12;
  }
  // returns a CombineResult
  group(textItems) {
    const lines = [];
    var currentLine = [];
    textItems.forEach((item) => {
      if (currentLine.length > 0 && Math.abs(currentLine[0].y - item.y) >= this.mostUsedDistance / 2) {
        lines.push(currentLine);
        currentLine = [];
      }
      currentLine.push(item);
    });
    lines.push(currentLine);
    lines.forEach((textItems2) => {
      sortByX(textItems2);
    });
    return lines;
  }
}
class CompactLines extends ToLineItemTransformation {
  constructor() {
    super("Compact To Lines");
  }
  transform(parseResult) {
    const { mostUsedDistance, fontToFormats } = parseResult.globals;
    const foundFootnotes = [];
    const foundFootnoteLinks = [];
    var linkCount = 0;
    var formattedWords = 0;
    const lineGrouper = new TextItemLineGrouper({
      mostUsedDistance
    });
    const lineCompactor = new LineConverter(fontToFormats);
    parseResult.pages.forEach((page) => {
      if (page.items.length > 0) {
        const lineItems = [];
        const textItemsGroupedByLine = lineGrouper.group(page.items);
        textItemsGroupedByLine.forEach((lineTextItems) => {
          const lineItem = lineCompactor.compact(lineTextItems);
          if (lineTextItems.length > 1) {
            lineItem.annotation = ADDED_ANNOTATION;
            lineTextItems.forEach((item) => {
              item.annotation = REMOVED_ANNOTATION;
              lineItems.push(new LineItem({
                ...item
              }));
            });
          }
          if (lineItem.words.length === 0) {
            lineItem.annotation = REMOVED_ANNOTATION;
          }
          lineItems.push(lineItem);
          if (lineItem.parsedElements.formattedWords) {
            formattedWords += lineItem.parsedElements.formattedWords;
          }
          if (lineItem.parsedElements.containLinks > 0) {
            linkCount++;
          }
          if (lineItem.parsedElements.footnoteLinks.length > 0) {
            const footnoteLinks = lineItem.parsedElements.footnoteLinks.map((footnoteLink) => ({ footnoteLink, page: page.index + 1 }));
            foundFootnoteLinks.push.apply(foundFootnoteLinks, footnoteLinks);
          }
          if (lineItem.parsedElements.footnotes.length > 0) {
            lineItem.type = BlockTypes.FOOTNOTES;
            const footnotes = lineItem.parsedElements.footnotes.map((footnote) => ({ footnote, page: page.index + 1 }));
            foundFootnotes.push.apply(foundFootnotes, footnotes);
          }
        });
        page.items = lineItems;
      }
    });
    return new ParseResult({
      ...parseResult,
      messages: [
        "Detected " + formattedWords + " formatted words",
        "Found " + linkCount + " links",
        "Detected " + foundFootnoteLinks.length + " footnotes links",
        "Detected " + foundFootnotes.length + " footnotes"
      ]
    });
  }
}
function hashCodeIgnoringSpacesAndNumbers(string) {
  var hash = 0;
  if (string.trim().length === 0) return hash;
  for (var i = 0; i < string.length; i++) {
    const charCode = string.charCodeAt(i);
    if (!isDigit(charCode) && charCode !== 32 && charCode !== 160) {
      hash = (hash << 5) - hash + charCode;
      hash |= 0;
    }
  }
  return hash;
}
class RemoveRepetitiveElements extends ToLineItemTransformation {
  constructor() {
    super("Remove Repetitive Elements");
  }
  // The idea is the following:
  // - For each page, collect all items of the first, and all items of the last line
  // - Calculate how often these items occur accros all pages (hash ignoring numbers, whitespace, upper/lowercase)
  // - Delete items occuring on more then 2/3 of all pages
  transform(parseResult) {
    const pageStore = [];
    const minLineHashRepetitions = {};
    const maxLineHashRepetitions = {};
    parseResult.pages.forEach((page) => {
      const minMaxItems = page.items.reduce((itemStore, item) => {
        if (item.y < itemStore.minY) {
          itemStore.minElements = [item];
          itemStore.minY = item.y;
        } else if (item.y === itemStore.minY) {
          itemStore.minElements.push(item);
        }
        if (item.y > itemStore.maxY) {
          itemStore.maxElements = [item];
          itemStore.maxY = item.y;
        } else if (item.y === itemStore.maxY) {
          itemStore.maxElements.push(item);
        }
        return itemStore;
      }, {
        minY: 999,
        maxY: 0,
        minElements: [],
        maxElements: []
      });
      const minLineHash = hashCodeIgnoringSpacesAndNumbers(minMaxItems.minElements.reduce((combinedString, item) => combinedString + item.text().toUpperCase(), ""));
      const maxLineHash = hashCodeIgnoringSpacesAndNumbers(minMaxItems.maxElements.reduce((combinedString, item) => combinedString + item.text().toUpperCase(), ""));
      pageStore.push({
        minElements: minMaxItems.minElements,
        maxElements: minMaxItems.maxElements,
        minLineHash,
        maxLineHash
      });
      minLineHashRepetitions[minLineHash] = minLineHashRepetitions[minLineHash] ? minLineHashRepetitions[minLineHash] + 1 : 1;
      maxLineHashRepetitions[maxLineHash] = maxLineHashRepetitions[maxLineHash] ? maxLineHashRepetitions[maxLineHash] + 1 : 1;
    });
    var removedHeader = 0;
    var removedFooter = 0;
    parseResult.pages.forEach((page, i) => {
      if (minLineHashRepetitions[pageStore[i].minLineHash] >= Math.max(3, parseResult.pages.length * 2 / 3)) {
        pageStore[i].minElements.forEach((item) => {
          item.annotation = REMOVED_ANNOTATION;
        });
        removedFooter++;
      }
      if (maxLineHashRepetitions[pageStore[i].maxLineHash] >= Math.max(3, parseResult.pages.length * 2 / 3)) {
        pageStore[i].maxElements.forEach((item) => {
          item.annotation = REMOVED_ANNOTATION;
        });
        removedHeader++;
      }
    });
    return new ParseResult({
      ...parseResult,
      messages: [
        "Removed Header: " + removedHeader,
        "Removed Footers: " + removedFooter
      ]
    });
  }
}
class VerticalToHorizontal extends ToLineItemTransformation {
  constructor() {
    super("Vertical to Horizontal Text");
  }
  transform(parseResult) {
    var foundVerticals = 0;
    parseResult.pages.forEach((page) => {
      const stream = new VerticalsStream();
      stream.consumeAll(page.items);
      page.items = stream.complete();
      foundVerticals += stream.foundVerticals;
    });
    return new ParseResult({
      ...parseResult,
      messages: ["Converted " + foundVerticals + " verticals"]
    });
  }
}
class VerticalsStream extends StashingStream {
  constructor() {
    super();
    this.foundVerticals = 0;
  }
  shouldStash(item) {
    return item.words.length === 1 && item.words[0].string.length === 1;
  }
  doMatchesStash(lastItem, item) {
    return lastItem.y - item.y > 5 && lastItem.words[0].type === item.words[0].type;
  }
  doFlushStash(stash, results) {
    if (stash.length > 5) {
      var combinedWords = [];
      var minX = 999;
      var maxY = 0;
      var sumWidth = 0;
      var maxHeight = 0;
      stash.forEach((oneCharacterLine) => {
        oneCharacterLine.annotation = REMOVED_ANNOTATION;
        results.push(oneCharacterLine);
        combinedWords.push(oneCharacterLine.words[0]);
        minX = Math.min(minX, oneCharacterLine.x);
        maxY = Math.max(maxY, oneCharacterLine.y);
        sumWidth += oneCharacterLine.width;
        maxHeight = Math.max(maxHeight, oneCharacterLine.height);
      });
      results.push(new LineItem({
        ...stash[0],
        x: minX,
        y: maxY,
        width: sumWidth,
        height: maxHeight,
        words: combinedWords,
        annotation: ADDED_ANNOTATION
      }));
      this.foundVerticals++;
    } else {
      results.push(...stash);
    }
  }
}
class HeadlineFinder {
  constructor(options) {
    this.headlineCharCodes = normalizedCharCodeArray(options.headline);
    this.stackedLineItems = [];
    this.stackedChars = 0;
  }
  consume(lineItem) {
    const normalizedCharCodes = normalizedCharCodeArray(lineItem.text());
    const matchAll = this.matchAll(normalizedCharCodes);
    if (matchAll) {
      this.stackedLineItems.push(lineItem);
      this.stackedChars += normalizedCharCodes.length;
      if (this.stackedChars === this.headlineCharCodes.length) {
        return this.stackedLineItems;
      }
    } else {
      if (this.stackedChars > 0) {
        this.stackedChars = 0;
        this.stackedLineItems = [];
        this.consume(lineItem);
      }
    }
    return null;
  }
  matchAll(normalizedCharCodes) {
    for (var i = 0; i < normalizedCharCodes.length; i++) {
      const headlineChar = this.headlineCharCodes[this.stackedChars + i];
      const textItemChar = normalizedCharCodes[i];
      if (textItemChar !== headlineChar) {
        return false;
      }
    }
    return true;
  }
}
class DetectTOC extends ToLineItemTransformation {
  constructor() {
    super("Detect TOC");
  }
  transform(parseResult) {
    const tocPages = [];
    const maxPagesToEvaluate = Math.min(20, parseResult.pages.length);
    const linkLeveler = new LinkLeveler();
    var tocLinks = [];
    var lastTocPage;
    var headlineItem;
    parseResult.pages.slice(0, maxPagesToEvaluate).forEach((page) => {
      var lineItemsWithDigits = 0;
      const unknownLines = /* @__PURE__ */ new Set();
      const pageTocLinks = [];
      var lastWordsWithoutNumber;
      var lastLine;
      const tocLines = page.items.filter((line) => line.words.includes((word) => hasOnly(word.string, ".")));
      tocLines.forEach((line) => {
        var words = line.words.filter((word) => !hasOnly(word.string, "."));
        const digits = [];
        while (words.length > 0 && isNumber(words[words.length - 1].string)) {
          const lastWord = words.pop();
          digits.unshift(lastWord.string);
        }
        if (digits.length === 0 && words.length > 0) {
          const lastWord = words[words.length - 1];
          while (isDigit(lastWord.string.charCodeAt(lastWord.string.length - 1))) {
            digits.unshift(lastWord.string.charAt(lastWord.string.length - 1));
            lastWord.string = lastWord.string.substring(0, lastWord.string.length - 1);
          }
        }
        var endsWithDigit = digits.length > 0;
        if (endsWithDigit) {
          endsWithDigit = true;
          if (lastWordsWithoutNumber) {
            words.push(...lastWordsWithoutNumber);
            lastWordsWithoutNumber = null;
          }
          pageTocLinks.push(new TocLink({
            pageNumber: parseInt(digits.join("")),
            lineItem: new LineItem({ ...line, words })
          }));
          lineItemsWithDigits++;
        } else {
          if (!headlineItem) {
            headlineItem = line;
          } else {
            if (lastWordsWithoutNumber) {
              unknownLines.add(lastLine);
            }
            lastWordsWithoutNumber = words;
            lastLine = line;
          }
        }
      });
      if (lineItemsWithDigits * 100 / page.items.length > 75) {
        tocPages.push(page.index + 1);
        lastTocPage = page;
        linkLeveler.levelPageItems(pageTocLinks);
        tocLinks.push(...pageTocLinks);
        const newBlocks = [];
        page.items.forEach((line) => {
          if (!unknownLines.has(line)) {
            line.annotation = REMOVED_ANNOTATION;
          }
          newBlocks.push(line);
          if (line === headlineItem) {
            newBlocks.push(new LineItem({
              ...line,
              type: BlockTypes.H2,
              annotation: ADDED_ANNOTATION
            }));
          }
        });
        page.items = newBlocks;
      } else {
        headlineItem = null;
      }
    });
    var foundHeadlines = tocLinks.length;
    const notFoundHeadlines = [];
    const foundBySize = [];
    const headlineTypeToHeightRange = {};
    if (tocPages.length > 0) {
      tocLinks.forEach((tocLink) => {
        lastTocPage.items.push(new LineItem({
          words: [new Word({
            string: " ".repeat(tocLink.level * 3) + "-"
          })].concat(tocLink.lineItem.words),
          type: BlockTypes.TOC,
          annotation: ADDED_ANNOTATION
        }));
      });
      const pageMapping = detectPageMappingNumber(parseResult.pages.filter((page) => page.index > lastTocPage.index), tocLinks);
      tocLinks.forEach((tocLink) => {
        var linkedPage = parseResult.pages[tocLink.pageNumber + pageMapping];
        var foundHealineItems;
        if (linkedPage) {
          foundHealineItems = findHeadlineItems(linkedPage, tocLink.lineItem.text());
          if (!foundHealineItems) {
            linkedPage = parseResult.pages[tocLink.pageNumber + pageMapping + 1];
            if (linkedPage) {
              foundHealineItems = findHeadlineItems(linkedPage, tocLink.lineItem.text());
            }
          }
        }
        if (foundHealineItems) {
          addHeadlineItems(linkedPage, tocLink, foundHealineItems, headlineTypeToHeightRange);
        } else {
          notFoundHeadlines.push(tocLink);
        }
      });
      var fromPage = lastTocPage.index + 2;
      var lastNotFound = [];
      const rollupLastNotFound = (currentPageNumber) => {
        if (lastNotFound.length > 0) {
          lastNotFound.forEach((notFoundTocLink) => {
            const headlineType = BlockTypes.headlineByLevel(notFoundTocLink.level + 2);
            const heightRange = headlineTypeToHeightRange[headlineType.name];
            if (heightRange) {
              const [pageIndex, lineIndex] = findPageAndLineFromHeadline(parseResult.pages, notFoundTocLink, heightRange, fromPage, currentPageNumber);
              if (lineIndex > -1) {
                const page = parseResult.pages[pageIndex];
                page.items[lineIndex].annotation = REMOVED_ANNOTATION;
                page.items.splice(lineIndex + 1, 0, new LineItem({
                  ...notFoundTocLink.lineItem,
                  type: headlineType,
                  annotation: ADDED_ANNOTATION
                }));
                foundBySize.push(notFoundTocLink);
              }
            }
          });
          lastNotFound = [];
        }
      };
      if (notFoundHeadlines.length > 0) {
        tocLinks.forEach((tocLink) => {
          if (notFoundHeadlines.includes(tocLink)) {
            lastNotFound.push(tocLink);
          } else {
            rollupLastNotFound(tocLink.pageNumber);
            fromPage = tocLink.pageNumber;
          }
        });
        if (lastNotFound.length > 0) {
          rollupLastNotFound(parseResult.pages.length);
        }
      }
    }
    const messages = [];
    messages.push("Detected " + tocPages.length + " table of content pages");
    if (tocPages.length > 0) {
      messages.push("TOC headline heights: " + JSON.stringify(headlineTypeToHeightRange));
      messages.push("Found TOC headlines: " + (foundHeadlines - notFoundHeadlines.length + foundBySize.length) + "/" + foundHeadlines);
    }
    if (notFoundHeadlines.length > 0) {
      messages.push("Found TOC headlines (by size): " + foundBySize.map((tocLink) => tocLink.lineItem.text()));
      messages.push("Missing TOC headlines: " + notFoundHeadlines.filter((fTocLink) => !foundBySize.includes(fTocLink)).map((tocLink) => tocLink.lineItem.text() + "=>" + tocLink.pageNumber));
    }
    return new ParseResult({
      ...parseResult,
      globals: {
        ...parseResult.globals,
        tocPages,
        headlineTypeToHeightRange
      },
      messages
    });
  }
}
function detectPageMappingNumber(pages, tocLinks) {
  for (var tocLink of tocLinks) {
    const page = findPageWithHeadline(pages, tocLink.lineItem.text());
    if (page) {
      return page.index - tocLink.pageNumber;
    }
  }
  return null;
}
function findPageWithHeadline(pages, headline) {
  for (var page of pages) {
    if (findHeadlineItems(page, headline)) {
      return page;
    }
  }
  return null;
}
function findHeadlineItems(page, headline) {
  const headlineFinder = new HeadlineFinder({ headline });
  var lineIndex = 0;
  for (var line of page.items) {
    const headlineItems = headlineFinder.consume(line);
    if (headlineItems) {
      return { lineIndex, headlineItems };
    }
    lineIndex++;
  }
  return null;
}
function addHeadlineItems(page, tocLink, foundItems, headlineTypeToHeightRange) {
  foundItems.headlineItems.forEach((item) => item.annotation = REMOVED_ANNOTATION);
  const headlineType = BlockTypes.headlineByLevel(tocLink.level + 2);
  const headlineHeight = foundItems.headlineItems.reduce((max, item) => Math.max(max, item.height), 0);
  page.items.splice(foundItems.lineIndex + 1, 0, new LineItem({
    ...foundItems.headlineItems[0],
    words: tocLink.lineItem.words,
    height: headlineHeight,
    type: headlineType,
    annotation: ADDED_ANNOTATION
  }));
  var range = headlineTypeToHeightRange[headlineType.name];
  if (range) {
    range.min = Math.min(range.min, headlineHeight);
    range.max = Math.max(range.max, headlineHeight);
  } else {
    range = {
      min: headlineHeight,
      max: headlineHeight
    };
    headlineTypeToHeightRange[headlineType.name] = range;
  }
}
function findPageAndLineFromHeadline(pages, tocLink, heightRange, fromPage, toPage) {
  const linkText = tocLink.lineItem.text().toUpperCase();
  for (var i = fromPage; i <= toPage; i++) {
    const page = pages[i - 1];
    if (page) {
      const lineIndex = page.items.findIndex((line) => {
        if (!line.type && !line.annotation && line.height >= heightRange.min && line.height <= heightRange.max) {
          const match = wordMatch(linkText, line.text());
          return match >= 0.5;
        }
        return false;
      });
      if (lineIndex > -1) return [i - 1, lineIndex];
    }
  }
  return [-1, -1];
}
class LinkLeveler {
  constructor() {
    this.levelByMethod = null;
    this.uniqueFonts = [];
  }
  levelPageItems(tocLinks) {
    if (!this.levelByMethod) {
      const uniqueX = this.calculateUniqueX(tocLinks);
      if (uniqueX.length > 1) {
        this.levelByMethod = this.levelByXDiff;
      } else {
        const uniqueFonts = this.calculateUniqueFonts(tocLinks);
        if (uniqueFonts.length > 1) {
          this.uniqueFonts = uniqueFonts;
          this.levelByMethod = this.levelByFont;
        } else {
          this.levelByMethod = this.levelToZero;
        }
      }
    }
    this.levelByMethod(tocLinks);
  }
  levelByXDiff(tocLinks) {
    const uniqueX = this.calculateUniqueX(tocLinks);
    tocLinks.forEach((link) => {
      link.level = uniqueX.indexOf(link.lineItem.x);
    });
  }
  levelByFont(tocLinks) {
    tocLinks.forEach((link) => {
      link.level = this.uniqueFonts.indexOf(link.lineItem.font);
    });
  }
  levelToZero(tocLinks) {
    tocLinks.forEach((link) => {
      link.level = 0;
    });
  }
  calculateUniqueX(tocLinks) {
    var uniqueX = tocLinks.reduce(function(uniquesArray, link) {
      if (uniquesArray.indexOf(link.lineItem.x) < 0) uniquesArray.push(link.lineItem.x);
      return uniquesArray;
    }, []);
    uniqueX.sort((a, b) => {
      return a - b;
    });
    return uniqueX;
  }
  calculateUniqueFonts(tocLinks) {
    var uniqueFont = tocLinks.reduce(function(uniquesArray, link) {
      if (uniquesArray.indexOf(link.lineItem.font) < 0) uniquesArray.push(link.lineItem.font);
      return uniquesArray;
    }, []);
    return uniqueFont;
  }
}
class TocLink {
  constructor(options) {
    this.lineItem = options.lineItem;
    this.pageNumber = options.pageNumber;
    this.level = 0;
  }
}
class DetectListItems extends ToLineItemTransformation {
  constructor() {
    super("Detect List Items");
  }
  transform(parseResult) {
    var foundListItems = 0;
    var foundNumberedItems = 0;
    parseResult.pages.forEach((page) => {
      const newItems = [];
      page.items.forEach((item) => {
        newItems.push(item);
        if (!item.type) {
          var text = item.text();
          if (isListItemCharacter(item.words[0].string)) {
            foundListItems++;
            if (item.words[0].string === "-") {
              item.annotation = DETECTED_ANNOTATION;
              item.type = BlockTypes.LIST;
            } else {
              item.annotation = REMOVED_ANNOTATION;
              const newWords = item.words.map((word) => new Word({
                ...word
              }));
              newWords[0].string = "-";
              newItems.push(new LineItem({
                ...item,
                words: newWords,
                annotation: ADDED_ANNOTATION,
                type: BlockTypes.LIST
              }));
            }
          } else if (isNumberedListItem(text)) {
            foundNumberedItems++;
            item.annotation = DETECTED_ANNOTATION;
            item.type = BlockTypes.LIST;
          }
        }
      });
      page.items = newItems;
    });
    return new ParseResult({
      ...parseResult,
      messages: [
        "Detected " + foundListItems + " plain list items.",
        "Detected " + foundNumberedItems + " numbered list items."
      ]
    });
  }
}
class DetectHeaders extends ToLineItemTransformation {
  constructor() {
    super("Detect Headers");
  }
  transform(parseResult) {
    const { tocPages, headlineTypeToHeightRange, mostUsedHeight, mostUsedDistance, mostUsedFont, maxHeight } = parseResult.globals;
    const hasToc = tocPages.length > 0;
    var detectedHeaders = 0;
    const pagesWithMaxHeight = findPagesWithMaxHeight(parseResult.pages, maxHeight);
    const min2ndLevelHeaderHeigthOnMaxPage = mostUsedHeight + (maxHeight - mostUsedHeight) / 4;
    pagesWithMaxHeight.forEach((titlePage) => {
      titlePage.items.forEach((item) => {
        const height = item.height;
        if (!item.type && height > min2ndLevelHeaderHeigthOnMaxPage) {
          if (height === maxHeight) {
            item.type = BlockTypes.H1;
          } else {
            item.type = BlockTypes.H2;
          }
          item.annotation = DETECTED_ANNOTATION;
          detectedHeaders++;
        }
      });
    });
    if (hasToc) {
      const headlineTypes = Object.keys(headlineTypeToHeightRange);
      headlineTypes.forEach((headlineType) => {
        var range = headlineTypeToHeightRange[headlineType];
        if (range.max > mostUsedHeight) {
          parseResult.pages.forEach((page) => {
            page.items.forEach((item) => {
              if (!item.type && item.height === range.max) {
                item.annotation = DETECTED_ANNOTATION;
                item.type = BlockTypes.enumValueOf(headlineType);
                detectedHeaders++;
              }
            });
          });
        }
      });
    } else {
      const heights = [];
      var lastHeight;
      parseResult.pages.forEach((page) => {
        page.items.forEach((item) => {
          if (!item.type && item.height > mostUsedHeight && !isListItem(item.text())) {
            if (!heights.includes(item.height) && (!lastHeight || lastHeight > item.height)) {
              heights.push(item.height);
            }
          }
        });
      });
      heights.sort((a, b) => b - a);
      heights.forEach((height, i) => {
        const headlineLevel = i + 2;
        if (headlineLevel <= 6) {
          const headlineType = BlockTypes.headlineByLevel(2 + i);
          parseResult.pages.forEach((page) => {
            page.items.forEach((item) => {
              if (!item.type && item.height === height && !isListItem(item.text())) {
                detectedHeaders++;
                item.annotation = DETECTED_ANNOTATION;
                item.type = headlineType;
              }
            });
          });
        }
      });
    }
    var smallesHeadlineLevel = 1;
    parseResult.pages.forEach((page) => {
      page.items.forEach((item) => {
        if (item.type && item.type.headline) {
          smallesHeadlineLevel = Math.max(smallesHeadlineLevel, item.type.headlineLevel);
        }
      });
    });
    if (smallesHeadlineLevel < 6) {
      const nextHeadlineType = BlockTypes.headlineByLevel(smallesHeadlineLevel + 1);
      parseResult.pages.forEach((page) => {
        var lastItem;
        page.items.forEach((item) => {
          if (!item.type && item.height === mostUsedHeight && item.font !== mostUsedFont && (!lastItem || lastItem.y < item.y || lastItem.type && lastItem.type.headline || lastItem.y - item.y > mostUsedDistance * 2) && item.text() === item.text().toUpperCase()) {
            detectedHeaders++;
            item.annotation = DETECTED_ANNOTATION;
            item.type = nextHeadlineType;
          }
          lastItem = item;
        });
      });
    }
    return new ParseResult({
      ...parseResult,
      messages: [
        "Detected " + detectedHeaders + " headlines."
      ]
    });
  }
}
function findPagesWithMaxHeight(pages, maxHeight) {
  const maxHeaderPagesSet = /* @__PURE__ */ new Set();
  pages.forEach((page) => {
    page.items.forEach((item) => {
      if (!item.type && item.height === maxHeight) {
        maxHeaderPagesSet.add(page);
      }
    });
  });
  return maxHeaderPagesSet;
}
class LineItemBlock extends PageItem2 {
  constructor(options) {
    super(options);
    this.items = [];
    if (options.items) {
      options.items.forEach((item) => this.addItem(item));
    }
  }
  addItem(item) {
    if (this.type && item.type && this.type !== item.type) {
      throw new Error(`Adding item of type ${item.type} to block of type ${this.type}`);
    }
    if (!this.type) {
      this.type = item.type;
    }
    if (item.parsedElements) {
      if (this.parsedElements) {
        this.parsedElements.add(item.parsedElements);
      } else {
        this.parsedElements = item.parsedElements;
      }
    }
    const copiedItem = new LineItem({ ...item });
    copiedItem.type = null;
    this.items.push(copiedItem);
  }
}
class ToLineItemBlockTransformation extends Transformation {
  constructor(name) {
    super(name, LineItemBlock.name);
    if (this.constructor === ToLineItemBlockTransformation) {
      throw new TypeError("Can not construct abstract class.");
    }
  }
  completeTransform(parseResult) {
    parseResult.messages = [];
    parseResult.pages.forEach((page) => {
      page.items = page.items.filter((item) => !item.annotation || item.annotation !== REMOVED_ANNOTATION);
      page.items.forEach((item) => item.annotation = null);
    });
    return parseResult;
  }
}
class GatherBlocks extends ToLineItemBlockTransformation {
  constructor() {
    super("Gather Blocks");
  }
  transform(parseResult) {
    const { mostUsedDistance } = parseResult.globals;
    var createdBlocks = 0;
    var lineItemCount = 0;
    parseResult.pages.map((page) => {
      lineItemCount += page.items.length;
      const blocks = [];
      var stashedBlock = new LineItemBlock({});
      const flushStashedItems = () => {
        if (stashedBlock.items.length > 1) {
          stashedBlock.annotation = DETECTED_ANNOTATION;
        }
        blocks.push(stashedBlock);
        stashedBlock = new LineItemBlock({});
        createdBlocks++;
      };
      var minX = minXFromPageItems(page.items);
      page.items.forEach((item) => {
        if (stashedBlock.items.length > 0 && shouldFlushBlock(stashedBlock, item, minX, mostUsedDistance)) {
          flushStashedItems();
        }
        stashedBlock.addItem(item);
      });
      if (stashedBlock.items.length > 0) {
        flushStashedItems();
      }
      page.items = blocks;
    });
    return new ParseResult({
      ...parseResult,
      messages: ["Gathered " + createdBlocks + " blocks out of " + lineItemCount + " line items"]
    });
  }
}
function shouldFlushBlock(stashedBlock, item, minX, mostUsedDistance) {
  if (stashedBlock.type && stashedBlock.type.mergeFollowingNonTypedItems && !item.type) {
    return false;
  }
  const lastItem = stashedBlock.items[stashedBlock.items.length - 1];
  const hasBigDistance = bigDistance(lastItem, item, minX, mostUsedDistance);
  if (stashedBlock.type && stashedBlock.type.mergeFollowingNonTypedItemsWithSmallDistance && !item.type && !hasBigDistance) {
    return false;
  }
  if (item.type !== stashedBlock.type) {
    return true;
  }
  if (item.type) {
    return !item.type.mergeToBlock;
  } else {
    return hasBigDistance;
  }
}
function bigDistance(lastItem, item, minX, mostUsedDistance) {
  const distance = lastItem.y - item.y;
  if (distance < 0 - mostUsedDistance / 2) {
    return true;
  }
  var allowedDisctance = mostUsedDistance + 1;
  if (lastItem.x > minX && item.x > minX) {
    allowedDisctance = mostUsedDistance + mostUsedDistance / 2;
  }
  if (distance > allowedDisctance) {
    return true;
  }
  return false;
}
class DetectCodeQuoteBlocks extends ToLineItemBlockTransformation {
  constructor() {
    super("$1");
  }
  transform(parseResult) {
    const { mostUsedHeight } = parseResult.globals;
    var foundCodeItems = 0;
    parseResult.pages.forEach((page) => {
      var minX = minXFromBlocks(page.items);
      page.items.forEach((block) => {
        if (!block.type && looksLikeCodeBlock(minX, block.items, mostUsedHeight)) {
          block.annotation = DETECTED_ANNOTATION;
          block.type = BlockTypes.CODE;
          foundCodeItems++;
        }
      });
    });
    return new ParseResult({
      ...parseResult,
      messages: [
        "Detected " + foundCodeItems + " code/quote items."
      ]
    });
  }
}
function looksLikeCodeBlock(minX, items, mostUsedHeight) {
  if (items.length === 0) {
    return false;
  }
  if (items.length === 1) {
    return items[0].x > minX && items[0].height <= mostUsedHeight + 1;
  }
  for (var item of items) {
    if (item.x === minX) {
      return false;
    }
  }
  return true;
}
class DetectListLevels extends ToLineItemBlockTransformation {
  constructor() {
    super("Level Lists");
  }
  transform(parseResult) {
    var listBlocks = 0;
    var modifiedBlocks = 0;
    parseResult.pages.forEach((page) => {
      page.items.filter((block) => block.type === BlockTypes.LIST).forEach((listBlock) => {
        var lastItemX;
        var currentLevel = 0;
        const xByLevel = {};
        var modifiedBlock = false;
        listBlock.items.forEach((item) => {
          const isListItem2 = true;
          if (lastItemX && isListItem2) {
            if (item.x > lastItemX) {
              currentLevel++;
              xByLevel[item.x] = currentLevel;
            } else if (item.x < lastItemX) {
              currentLevel = xByLevel[item.x];
            }
          } else {
            xByLevel[item.x] = 0;
          }
          if (currentLevel > 0) {
            item.words = [
              new Word({ string: " ".repeat(currentLevel * 3) })
            ].concat(item.words);
            modifiedBlock = true;
          }
          lastItemX = item.x;
        });
        listBlocks++;
        if (modifiedBlock) {
          modifiedBlocks++;
          listBlock.annotation = MODIFIED_ANNOTATION;
        } else {
          listBlock.annotation = UNCHANGED_ANNOTATION;
        }
      });
    });
    return new ParseResult({
      ...parseResult,
      messages: ["Modified " + modifiedBlocks + " / " + listBlocks + " list blocks."]
    });
  }
}
class ToTextBlocks extends Transformation {
  constructor() {
    super("To Text Blocks", "TextBlock");
  }
  transform(parseResult) {
    parseResult.pages.forEach((page) => {
      const textItems = [];
      page.items.forEach((block) => {
        const category = block.type ? block.type.name : "Unknown";
        textItems.push({
          category,
          text: BlockTypes.blockToText(block)
        });
      });
      page.items = textItems;
    });
    return new ParseResult({
      ...parseResult
    });
  }
}
class ToHTML extends Transformation {
  constructor() {
    super("To HTML", "String");
  }
  transform(parseResult) {
    parseResult.pages.forEach((page) => {
      var text = "";
      page.items.forEach((block) => {
        let concatText;
        if (block.category === "TOC") {
          concatText = block.text;
        } else {
          concatText = block.text.replace(/(\r\n|\n|\r)/gm, "\n");
        }
        if (block.category !== "LIST") {
          concatText = concatText.split("- ").join("");
        }
        if (block.category === "CODE") {
          concatText = concatText.split("<code>").join("").split("</code>").join("");
        }
        text += `<p>${concatText}</p>

`;
      });
      page.items = [text];
    });
    return new ParseResult({
      ...parseResult
    });
  }
}
async function convertPDFToHTML(pdfURLOrBuffer, options = {}) {
  var {
    addPageNumbers = false,
    addCitation = true
  } = options;
  var buffer = typeof pdfURLOrBuffer === "string" ? await (await fetch(pdfURLOrBuffer, { signal: AbortSignal.timeout(10 * 1e3) })).arrayBuffer() : pdfURLOrBuffer;
  try {
    const { getDocument } = await resolvePDFJS();
    var pdfDocument = await getDocument({
      data: new Uint8Array(buffer),
      useSystemFonts: true,
      verbosity: 0
    }).promise;
  } catch (e) {
    return { error: e.message };
  }
  const pages = [...Array(pdfDocument.numPages).keys()].map(
    (index) => new Page({ index })
  );
  let pageIndexNumMap = {};
  let firstPage;
  for (let j = 1; j <= pdfDocument.numPages; j++) {
    const page = await pdfDocument.getPage(j);
    const textContent = await page.getTextContent();
    if (Object.keys(pageIndexNumMap).length < 10) {
      pageIndexNumMap = findPageNumbers(pageIndexNumMap, page.pageNumber - 1, textContent.items);
    } else {
      firstPage = findFirstPage(pageIndexNumMap);
      break;
    }
  }
  let pageNum = firstPage ? firstPage.pageNum : 0;
  for (let j = 1; j <= pdfDocument.numPages; j++) {
    const page = await pdfDocument.getPage(j);
    await page.getOperatorList();
    const scale = 1;
    const viewport = page.getViewport({ scale });
    let textContent = await page.getTextContent();
    if (firstPage && page.pageIndex >= firstPage.pageIndex) {
      textContent = removePageNumber(textContent, pageNum);
      pageNum++;
    }
    const textItems = textContent.items.map((item) => {
      const tx = [1, 0, 0, 1, 0, 0];
      for (let i = 0; i < 6; i++) {
        tx[i] += item.transform[i] * viewport.transform[i % 2 ? 3 : 0];
        if (i % 2) {
          tx[i + 1] += item.transform[i] * viewport.transform[1];
        }
      }
      const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
      const dividedHeight = item.height / fontHeight;
      return new TextItem({
        x: Math.round(item.transform[4]),
        y: Math.round(item.transform[5]),
        width: Math.round(item.width),
        height: Math.round(dividedHeight <= 1 ? item.height : dividedHeight),
        text: item.str,
        font: item.fontName
      });
    });
    pages[page.pageNumber - 1].items = textItems;
  }
  var parseResult = new ParseResult({ pages });
  let lastTransformation, transformations = [
    new CalculateGlobalStats(),
    new CompactLines(),
    new RemoveRepetitiveElements(),
    new VerticalToHorizontal(),
    new DetectTOC(),
    new DetectHeaders(),
    new DetectListItems(),
    new GatherBlocks(),
    new DetectCodeQuoteBlocks(),
    new DetectListLevels(),
    new ToTextBlocks(),
    new ToHTML()
  ];
  transformations?.forEach((transformation) => {
    if (lastTransformation) {
      parseResult = lastTransformation.completeTransform(parseResult);
    }
    parseResult = transformation.transform(parseResult);
    lastTransformation = transformation;
  });
  var html = parseResult.pages.reduce((acc, page, pageNumber) => {
    return acc + `<p id="page-${pageNumber + 1}">${addPageNumbers ? ` [${pageNumber + 1}] ` : ""}${page.items.join('</p><p id="page-' + pageNumber + '">')}</p>`;
  }, "");
  if (addCitation) {
    var metadata = await pdfDocument.getMetadata();
    var { Author: author, Title: title } = metadata.info;
    title = html.slice(0, 400).match(/<h[0-9]>(.*?)<\/h[0-9]>/)?.[1] || title;
  }
  return { author, title, html, format: "pdf" };
}
async function isUrlPDF(url) {
  let response;
  try {
    response = await fetch(url);
    if (response.headers.get("content-type")?.includes("pdf")) return true;
    if (!response.body || !response.body.getReader)
      return false;
    const reader = response.body.getReader();
    const chunk = new Uint8Array(5);
    let bytesRead = 0;
    while (bytesRead < 5) {
      const { value, done } = await reader.read();
      if (done) break;
      const remainingBytes = 5 - bytesRead;
      const bytesToCopy = Math.min(remainingBytes, value.length);
      chunk.set(value.subarray(0, bytesToCopy), bytesRead);
      bytesRead += bytesToCopy;
    }
    return bytesRead === 5 && chunk[0] === 37 && // %
    chunk[1] === 80 && // P
    chunk[2] === 68 && // D
    chunk[3] === 70 && // F
    chunk[4] === 45;
  } catch (error) {
    console.error("Error checking URL:", error);
    return false;
  }
}
const TABLE_STYLES = {
  firstRow: "table-first-row",
  lastRow: "table-last-row",
  oddRow: "table-odd-row",
  evenRow: "table-even-row"
};
async function convertDOCXToHTML(input, options = {}) {
  const settings = {
    preserveShapes: true,
    includeStyles: true,
    imgPath: "",
    ...options
  };
  async function getBuffer(input2) {
    if (input2 instanceof ArrayBuffer) {
      return input2;
    }
    if (input2 instanceof Uint8Array) {
      return input2.buffer.slice(input2.byteOffset, input2.byteOffset + input2.byteLength);
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(input2)) {
      return input2.buffer.slice(input2.byteOffset, input2.byteOffset + input2.byteLength);
    }
    if (input2 instanceof Blob || input2 instanceof File) {
      return await input2.arrayBuffer();
    }
    if (typeof input2 === "string") {
      const response = await fetch(input2);
      return await response.arrayBuffer();
    }
    throw new Error("Invalid input type");
  }
  async function extractXml(zip, path) {
    const file = zip.file(path);
    return file ? await file.async("string") : "";
  }
  function parseStyles(xml) {
    if (!xml) return {};
    const styles = {
      document: {},
      paragraph: {},
      character: {},
      table: {}
    };
    const defaultMatch = /<w:docDefaults>[\s\S]*?<\/w:docDefaults>/i.exec(xml);
    if (defaultMatch) {
      const defaults = defaultMatch[0];
      styles.document = {
        fontFamily: /<w:rFonts[^>]*w:ascii="([^"]+)"/.exec(defaults)?.[1],
        fontSize: /<w:sz[^>]*w:val="([^"]+)"/.exec(defaults)?.[1],
        color: /<w:color[^>]*w:val="([^"]+)"/.exec(defaults)?.[1]
      };
    }
    const styleRegex = /<w:style\s+w:type="(\w+)"\s+w:styleId="([^"]+)"[^>]*>([\s\S]*?)<\/w:style>/gi;
    let match;
    while ((match = styleRegex.exec(xml)) !== null) {
      const [_, type, id, content2] = match;
      if (styles[type.toLowerCase()]) {
        styles[type.toLowerCase()][id] = parseStyleProperties(content2);
      }
    }
    return styles;
  }
  function parseStyleProperties(content2) {
    return {
      bold: /<w:b\/>/.test(content2),
      italic: /<w:i\/>/.test(content2),
      underline: /<w:u\/>/.test(content2),
      fontSize: /<w:sz[^>]*w:val="([^"]+)"/.exec(content2)?.[1],
      color: /<w:color[^>]*w:val="([^"]+)"/.exec(content2)?.[1],
      alignment: /<w:jc[^>]*w:val="([^"]+)"/.exec(content2)?.[1]
    };
  }
  function parseDocument(xml, context) {
    const blocks = [];
    const sections = xml.split(/<w:sectPr[^>]*>[\s\S]*?<\/w:sectPr>/gi);
    sections.forEach((section, index) => {
      if (!section.trim()) return;
      const content2 = [];
      const pRegex = /<w:p\b[^>]*>[\s\S]*?<\/w:p>/gi;
      let pMatch;
      while ((pMatch = pRegex.exec(section)) !== null) {
        const para = parseParagraph(pMatch[0], context);
        if (para) content2.push(para);
      }
      blocks.push({
        type: "section",
        content: content2
      });
    });
    return blocks;
  }
  try {
    const buffer = await getBuffer(input);
    const zip = new JSZip();
    const docx = await zip.loadAsync(buffer);
    const [docXml, stylesXml, numberingXml, relsXml] = await Promise.all([
      extractXml(docx, "word/document.xml"),
      extractXml(docx, "word/styles.xml"),
      extractXml(docx, "word/numbering.xml"),
      extractXml(docx, "word/_rels/document.xml.rels")
    ]);
    const styles = settings.includeStyles ? parseStyles(stylesXml) : {};
    const content2 = parseDocument(docXml, { styles });
    return generateHtml(content2, styles);
  } catch (error) {
    console.error("Error converting DOCX:", error);
    throw error;
  }
}
function parseParagraph(xml, context) {
  if (!xml || !xml.trim()) return null;
  function getParagraphStyle(pPr) {
    if (!pPr) return {};
    return {
      alignment: /<w:jc\s+w:val="([^"]+)"/.exec(pPr)?.[1],
      spacing: /<w:spacing\s+w:line="([^"]+)"/.exec(pPr)?.[1],
      indentation: /<w:ind\s+w:left="([^"]+)"/.exec(pPr)?.[1],
      keepNext: /<w:keepNext\s*\/>/.test(pPr),
      pageBreakBefore: /<w:pageBreakBefore\s*\/>/.test(pPr),
      styleId: /<w:pStyle\s+w:val="([^"]+)"/.exec(pPr)?.[1]
    };
  }
  function getRunStyle(rPr) {
    if (!rPr) return {};
    return {
      bold: /<w:b\s*\/>/.test(rPr),
      italic: /<w:i\s*\/>/.test(rPr),
      underline: /<w:u\s*\/>/.test(rPr),
      strike: /<w:strike\s*\/>/.test(rPr),
      color: /<w:color\s+w:val="([^"]+)"/.exec(rPr)?.[1],
      highlight: /<w:highlight\s+w:val="([^"]+)"/.exec(rPr)?.[1],
      size: /<w:sz\s+w:val="([^"]+)"/.exec(rPr)?.[1],
      font: /<w:rFonts[^>]*w:ascii="([^"]+)"/.exec(rPr)?.[1]
    };
  }
  function processText(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\s+/g, " ").replace(/[\n\r]/g, " ");
  }
  try {
    const pPrMatch = /<w:pPr>([\s\S]*?)<\/w:pPr>/.exec(xml);
    const paragraphStyle = getParagraphStyle(pPrMatch?.[1]);
    const styleId = paragraphStyle.styleId;
    if (styleId && context.styles?.paragraph?.[styleId]) {
      Object.assign(paragraphStyle, context.styles.paragraph[styleId]);
    }
    const runs = [];
    const runRegex = /<w:r\b[^>]*>([\s\S]*?)<\/w:r>/g;
    let runMatch;
    while ((runMatch = runRegex.exec(xml)) !== null) {
      const runXml = runMatch[1];
      const rPrMatch = /<w:rPr>([\s\S]*?)<\/w:rPr>/.exec(runXml);
      const runStyle = getRunStyle(rPrMatch?.[1]);
      const textMatch = /<w:t\b[^>]*>([\s\S]*?)<\/w:t>/.exec(runXml);
      if (textMatch) {
        const text = processText(textMatch[1]);
        if (text.trim()) {
          runs.push({
            type: "text",
            text,
            style: runStyle
          });
        }
      }
      if (/<w:tab\/>/.test(runXml)) {
        runs.push({ type: "tab" });
      }
      if (/<w:br\/>/.test(runXml)) {
        runs.push({ type: "break" });
      }
      const hyperlinkMatch = /<w:hyperlink\s+r:id="([^"]+)"/.exec(runXml);
      if (hyperlinkMatch && context.relationships) {
        const relationshipId = hyperlinkMatch[1];
        const target = context.relationships[relationshipId];
        if (target) {
          runs.push({
            type: "hyperlink",
            target,
            style: runStyle
          });
        }
      }
    }
    if (runs.length === 0 && !paragraphStyle.pageBreakBefore) {
      return null;
    }
    return {
      type: "paragraph",
      style: paragraphStyle,
      content: runs
    };
  } catch (error) {
    console.warn("Error parsing paragraph:", error);
    return null;
  }
}
function generateHtml(content2, styles) {
  function styleToCSS(style) {
    if (!style) return "";
    const cssMap = {
      alignment: "text-align",
      color: "color",
      highlight: "background-color",
      size: (value) => `font-size: ${parseInt(value) / 2}pt`,
      spacing: (value) => `line-height: ${parseInt(value) / 240}`,
      indentation: (value) => `margin-left: ${parseInt(value) / 20}pt`,
      font: "font-family"
    };
    return Object.entries(style).map(([key, value]) => {
      if (value == null) return "";
      if (key === "bold") return value ? "font-weight: bold" : "";
      if (key === "italic") return value ? "font-style: italic" : "";
      if (key === "underline") return value ? "text-decoration: underline" : "";
      if (key === "strike") return value ? "text-decoration: line-through" : "";
      const cssProperty = cssMap[key];
      if (!cssProperty) return "";
      if (typeof cssProperty === "function") {
        return cssProperty(value);
      }
      return `${cssProperty}: ${value}`;
    }).filter(Boolean).join("; ");
  }
  function generateRunHtml(run) {
    if (!run) return "";
    switch (run.type) {
      case "text": {
        const style = styleToCSS(run.style);
        return style ? `<span style="${style}">${run.text}</span>` : run.text;
      }
      case "tab":
        return "&nbsp;&nbsp;&nbsp;&nbsp;";
      case "break":
        return "<br>";
      case "hyperlink": {
        const style = styleToCSS(run.style);
        return `<a href="${run.target}"${style ? ` style="${style}"` : ""}>${run.text || run.target}</a>`;
      }
      default:
        return "";
    }
  }
  function generateParagraphHtml(paragraph) {
    if (!paragraph?.content) return "";
    const style = styleToCSS(paragraph.style);
    const content3 = paragraph.content.map((run) => generateRunHtml(run)).join("");
    const styleId = paragraph.style?.styleId;
    if (styleId && styles?.paragraph?.[styleId]) {
      const baseStyle = styles.paragraph[styleId];
      if (baseStyle.heading) {
        const level = parseInt(styleId.match(/Heading(\d+)/)?.[1] || "1");
        return `<h${level}${style ? ` style="${style}"` : ""}>${content3}</h${level}>`;
      }
    }
    if (paragraph.style?.pageBreakBefore) {
      return `<div style="page-break-before: always"></div><p${style ? ` style="${style}"` : ""}>${content3}</p>`;
    }
    return `<p${style ? ` style="${style}"` : ""}>${content3}</p>`;
  }
  function generateTableHtml(table) {
    if (!table?.rows) return "";
    const style = styleToCSS(table.style);
    const rows = table.rows.map((row, rowIndex) => {
      const cells = row.cells.map((cell, cellIndex) => {
        const cellStyle = styleToCSS({
          ...cell.style,
          width: cell.width ? `${cell.width}pt` : void 0
        });
        const content3 = cell.content.map((block) => {
          switch (block.type) {
            case "paragraph":
              return generateParagraphHtml(block);
            default:
              return "";
          }
        }).join("");
        return `<td${cellStyle ? ` style="${cellStyle}"` : ""}>${content3}</td>`;
      }).join("");
      const rowClasses = [];
      if (rowIndex === 0 && table.style?.firstRow) rowClasses.push(TABLE_STYLES.firstRow);
      if (rowIndex === table.rows.length - 1 && table.style?.lastRow) rowClasses.push(TABLE_STYLES.lastRow);
      if (rowIndex % 2 === 0) rowClasses.push(TABLE_STYLES.evenRow);
      else rowClasses.push(TABLE_STYLES.oddRow);
      return `<tr${rowClasses.length ? ` class="${rowClasses.join(" ")}"` : ""}>${cells}</tr>`;
    }).join("");
    return `<table${style ? ` style="${style}"` : ""}>${rows}</table>`;
  }
  function generateSectionHtml(section) {
    if (!section?.content) return "";
    const blocks = section.content.map((block) => {
      switch (block.type) {
        case "paragraph":
          return generateParagraphHtml(block);
        case "table":
          return generateTableHtml(block);
        default:
          return "";
      }
    }).filter(Boolean).join("\n");
    const style = styleToCSS(section.style);
    return `<section${style ? ` style="${style}"` : ""}>${blocks}</section>`;
  }
  let css = "";
  if (styles?.document) {
    const documentStyle = styleToCSS(styles.document);
    if (documentStyle) {
      css = `<style>
        body {
          ${documentStyle}
        }
        ${Object.entries(TABLE_STYLES).map(([key, className]) => `
          .${className} {
            ${styles.table?.[key] ? styleToCSS(styles.table[key]) : ""}
          }
        `).join("\n")}
      </style>`;
    }
  }
  const bodyContent = content2.map((block) => {
    switch (block.type) {
      case "section":
        return generateSectionHtml(block);
      case "paragraph":
        return generateParagraphHtml(block);
      case "table":
        return generateTableHtml(block);
      default:
        return "";
    }
  }).filter(Boolean).join("\n");
  return `<!DOCTYPE html>
    <html>
    <head>
    <meta charset="UTF-8">
    ${css}
    </head>
    <body>
    ${bodyContent}
    </body>
    </html>`;
}
function isBufferDOCX(buffer) {
  if (!buffer) return false;
  try {
    const uint8Array = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    if (uint8Array.length < 30) return false;
    if (uint8Array[0] !== 80 || uint8Array[1] !== 75) return false;
    const signature = uint8Array[2] << 8 | uint8Array[3];
    if (signature !== 772 && signature !== 513) return false;
    const bufferString = new TextDecoder("utf-8", { fatal: false }).decode(uint8Array.slice(0, Math.min(1024, uint8Array.length)));
    return bufferString.includes("word/document.xml") || bufferString.includes("word/styles.xml") || bufferString.includes("[Content_Types].xml");
  } catch (error) {
    return false;
  }
}
async function extractContent(urlOrDoc, options = {}) {
  var {
    images = true,
    links = true,
    formatting = true,
    absoluteURLs = true,
    timeout = 10,
    proxy = null,
    citeFormatMonthFull = false,
    citeFormatAuthorFull = true
  } = options;
  var response = {};
  let url, isPdf, isDocxBuffer;
  if (urlOrDoc instanceof ArrayBuffer || urlOrDoc instanceof Uint8Array || typeof Buffer !== "undefined" && Buffer.isBuffer(urlOrDoc)) {
    isDocxBuffer = isBufferDOCX(urlOrDoc);
    if (isDocxBuffer) {
      response.html = await convertDOCXToHTML(urlOrDoc, options);
      url = "buffer://docx";
    } else {
      return { error: "Binary buffer is not a valid DOCX file" };
    }
  } else if (typeof urlOrDoc === "string" && /<\/[^>]+>/.test(urlOrDoc.trim())) {
    options.url = options.url || "";
    response = extractContentAndCite(urlOrDoc, options);
    return response;
  } else if (typeof urlOrDoc === "string" && urlOrDoc.startsWith("http")) {
    url = urlOrDoc;
    let googleDocId = url.match(/google\.com\/(file|document)\/d\/([\w-]+)/);
    if (googleDocId)
      url = googleDocId[1] === "file" ? `https://drive.google.com/uc?export=download&id=${googleDocId[2]}` : `https://docs.google.com/document/d/${googleDocId[2]}/export?format=html`;
    isPdf = url.endsWith(".pdf") || await isUrlPDF(url);
    let youtubeID2 = getURLYoutubeVideo(url);
    if (isPdf) {
      response = await convertPDFToHTML(url, options);
    } else if (url.endsWith(".docx")) {
      response.html = await convertDOCXToHTML(url);
    } else if (youtubeID2) {
      response = await convertYoutubeToText(url, options);
    } else {
      var html = await scrapeURL(url, {
        proxy
      });
      options.url = url;
      response = extractContentAndCite(html, options);
    }
  } else if (typeof urlOrDoc == "object" && urlOrDoc.location) {
    url = urlOrDoc.location.href;
    if (urlOrDoc?.querySelectorAll)
      isPdf = urlOrDoc?.querySelectorAll(
        'embed[type="application/pdf"]'
      )?.length;
    var youtubeID = getURLYoutubeVideo(url);
    if (isPdf)
      response = await convertPDFToHTML(url, {});
    else if (youtubeID) {
      options.useThirdPartyBackup = false;
      response = await convertYoutubeToText(url, options);
    } else response = extractContentAndCite(urlOrDoc, options);
  } else {
    return { error: "Invalid input type. Expected URL string, DOM object, or DOCX binary buffer." };
  }
  if (response.error || !response.html) return { error: response.error };
  response.word_count = response.html?.replace(/<[^>]*>/g, " ").split(" ").length;
  var { author, author_cite, author_short, date, title, source } = response;
  var apa_cite_date = new Date(date).getFullYear() > 1971 ? " (" + new Date(date).getFullYear() + ", " + new Date(date).toLocaleDateString(
    "en-US",
    { month: citeFormatMonthFull ? "long" : "short", day: "numeric" }
  ) + ")" : "";
  var cite = `${author_cite || source || " "}${apa_cite_date}. <b>${title || ""}</b>. <i>${source || ""}</i>. <a href="${url}" target="_blank">${url}</a>`;
  if (url && url.includes("?") && url.length > 150)
    response.url = url.split("?")[0];
  response = Object.assign({ url, cite }, response);
  return response;
}
async function GET({ url, locals, request }) {
  const {
    url: urlToExtract,
    full: optionReturnAllHTML = false,
    basic: optionBasicHTML = false,
    proxylinks
  } = Object.fromEntries(url.searchParams.entries());
  if (!urlToExtract)
    return json({ error: "URL parameter is required" }, { status: 500 });
  await initializeUser(locals, request);
  if (optionReturnAllHTML == "true") {
    let html = await scrapeURL(url);
    if (optionBasicHTML)
      html = convertHTMLToBasicHTML(html, { url: urlToExtract });
    return json({ html });
  }
  let article = await extractContent(urlToExtract, {
    proxy: false,
    timeout: 4
  });
  if (!article || article.error || article.html?.length < 1e3)
    article = await extractContent(urlToExtract, {
      proxy: proxyDomain,
      timeout: 10
    });
  if (!article || article.error)
    return json({ error: article.error }, { status: 500 });
  return json(article);
}
export {
  GET
};
