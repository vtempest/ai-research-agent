

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> pdf-to-content.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Global</h3><ul><li><a href="global.html#extractPDF">extractPDF</a></li><li><a href="global.html#isUrlPDF">isUrlPDF</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#softmax">softmax</a></li><li><a href="global.html#standardDeviation">standardDeviation</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>pdf-to-content.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {getDocumentProxy } from "unpdf"
import * as chrono from "chrono-node";

/**
 *  Extracts formatted text from PDF with parsing of headings,
 *  page headers, footnotes, and adding linebreaks based on
 *  standard deviation of range from average text height
 *
 * @param {string} pdfURL - url to a PDF file or buffer from fs.readFile
 * @param {object} options
 * addHeadingsTags = true, adds H1 tags to heading titles in document
 * addPageNumbers = true, adds [ # ] to end of each page
 * addSentenceLineBreaks = true, inserts line breaks at the end of sentence ranges
 * removePageHeaders = true, removes repeated headers found on each page
 * removeHyphens = true, removes hyphens at end of lines
 * moveFootnotes = true, moves footnotes to end of document
 *
 * @returns {string} html formatted text or {error} if error in parsing
 */
export async function extractPDF(pdfURL, options = {}) {
  try {
    var {
      addHeadingsTags = true,
      addPageNumbers = true,
      addSentenceLineBreaks = false,
      removePageHeaders = true,
      removeHyphens = true,
      moveFootnotes = true,
      addCitation = true,
    } = options ;

    var buffer = await (await fetch(pdfURL)).arrayBuffer();


    var doc;
    try {
      doc = await getDocumentProxy( 
         new Uint8Array(buffer),
        {verbosity: 0});
    } catch (e) {
      return { error: e.message };
    }
    // get text ranges with pdf.js which gives pages
    // with few word ranges with {str, hasEOL, height}
    var pages = [];
    for (let i = 1; i &lt;= doc.numPages; i++) {
      const page = await doc.getPage(i);
      var contentObjects = await page.getTextContent();
      pages.push(contentObjects.items);
    }

    //remove redundant headers
    if (removePageHeaders &amp;&amp; pages.length > 2) {
      //test first 4 ranges in each page for a redundant header
      for (let rangeIndex = 0; rangeIndex &lt; 3; rangeIndex++) {
        pages.forEach((page, pageNum) => {
          var range = page[rangeIndex];
          if (!range) return;

          // detect header if same range in same index as prior page
          if (
            range?.length > 6 &amp;&amp;
            pageNum >= 1 &amp;&amp;
            range == pages[pageNum - 1][rangeIndex].str
          ) {
            pages[pageNum][rangeIndex].str = "";
          }
        });
      }
    }

    //get average text heights to infer headings and footnotes
    const articleCharHeights = [];
    for (const textItem of pages.flat()) {
      if (textItem.height) {
        articleCharHeights.push(
          ...Array(textItem.str.length).fill(textItem.height)
        );
      }
    }
    const articleAvgHeight = mean(articleCharHeights);
    const articlesStandardDev = standardDeviation(articleCharHeights);

    const rangeTokens = []; // array of ranges {newline, mode, text}
    let newline = true;
    let mode = "p"; // "h1" | "h2" | "p" | "space" | "footnote"
    let pageNumber = 1;
    for (const pageTextItems of pages) {
      const charHeights = [];
      for (const textItem of pageTextItems) {
        if (textItem.height) {
          charHeights.push(...Array(textItem.str.length).fill(textItem.height));
        }
      }

      const avgHeight = mean(charHeights);
      const standardDeviationHeight = standardDeviation(charHeights);

      // use text height to infer headings and footnotes based on
      // standard deviation to the average text heights
      for (const textItem of pageTextItems) {
        if (textItem.height > articleAvgHeight + 3 * articlesStandardDev) {
          mode = "h1";
        } else if (textItem.height > articleAvgHeight + articlesStandardDev) {
          mode = "h2";
        } else if (
          textItem.height &amp;&amp;
          textItem.height &lt; avgHeight - standardDeviationHeight
        ) {
          mode = "footnote";
        } else if (textItem.height) {
          mode = "p";
        } else {
          mode = "space";
        }

        rangeTokens.push({
          newline,
          mode,
          text: textItem.str,
        });
        newline = textItem.hasEOL &amp;&amp; !textItem.str;
      }

      //add page numbers
      if (addPageNumbers)
        rangeTokens.push({ mode: "p", text: "[ " + pageNumber + " ]" });
      pageNumber++;
    }

    //convert {} ranges to html text
    let htmlChunks = [],
      appendixChunks = [],
      previousMode = "space";
    for (const x of rangeTokens) {
      if (x.mode == "space") {
        // previousMode = x.mode;
        continue;
      }
      if (x.newline) {
        if (addHeadingsTags &amp;&amp; previousMode == "h1") htmlChunks.push(`&lt;/h1> `);
        if (addHeadingsTags &amp;&amp; previousMode == "h2") htmlChunks.push(`&lt;/h2> `);
        if (previousMode == "p") htmlChunks.push("&lt;/p>");
        if (x.mode == "p") htmlChunks.push("\n\n&lt;p>");
        if (addHeadingsTags &amp;&amp; x.mode == "h1") htmlChunks.push(`\n\n&lt;h1>`);
        if (addHeadingsTags &amp;&amp; x.mode == "h2") htmlChunks.push(`&lt;h2>`);
      }

      if (x.text) {
        if (moveFootnotes &amp;&amp; x.mode === "footnote")
          appendixChunks.push((x.newline ? "&lt;br />" : "") + x.text.trim());
        else htmlChunks.push(x.text.trim());
      }

      previousMode = x.mode;
    }

    //add appendixChunks to end of document
    if (moveFootnotes &amp;&amp; appendixChunks.length) {
      const appendix =
        "&lt;h1>Footnotes&lt;/h1> &lt;small>" +
        appendixChunks.join(" ").replace(/[\r?\n]/gi, "&lt;br />") +
        " &lt;/small>";
      htmlChunks.push(appendix);
    }

    var content = htmlChunks.reduce((all, range) => {
      if (!range || !range.endsWith) return all;
      //hyphenated words at end of line or column
      if (removeHyphens &amp;&amp; range.endsWith("-")) return all + range.slice(0, -1);

      // Merge unwanted mid-sentence line breaks
      var separator =
        addSentenceLineBreaks &amp;&amp;
        !Number(range) &amp;&amp;
        range.length > 5 &amp;&amp;
        '.?!"â€\n'.includes(range[range.length - 1]) //end of sentence
          ? "&lt;/p>\n&lt;p>"
          : " ";

      return all + range + (separator ?? " ");
    }, "");

    if (addCitation) {
      // Get metadata
      var metadata = await doc.getMetadata();
      var { Author: author, CreationDate: date, Title: title } = metadata.info;
      date =
        date.slice(2, 6) + "-" + date.slice(6, 8) + "-" + date.slice(8, 10);
      date = date ? new Date(date)?.toISOString().split("T")[0] : null;

      //look for date in first page
      date =
        chrono.parseDate(content.slice(0, 400))?.toISOString().split("T")[0] ||
        date;

      title = content.slice(0, 400).match(/&lt;h1>(.*?)&lt;\/h1>/)?.[1] || title;

      return { author, title, date, html: content, format: "pdf" };
    }

    return { html: content };
  } catch (e) {
    return { error: e.message };
  }
}



/**
 * @param {array} array
 * @returns {int} average or mean of array
 */
const mean = function (array) {
  return array.length == 0 ? 0 : array.reduce((a, b) => a + b) / array.length;
}

/**
 * Calculate standard deviation of array
 * https://en.wikipedia.org/wiki/Standard_error
 * @param {array} array
 * @returns {int} number of standard deviation from average
 */
const standardDeviation = function (array) {
  var mean2 = mean(array);
  return Math.sqrt(mean(array.map((x) => (x - mean2) ** 2)));
}


/**
 * Compute the softmax of an array of numbers.
 * @param {T} arr The array of numbers to compute the softmax of.
 * @returns {T} The softmax array.
 */
export function softmax(arr) {
  // Compute the maximum value in the array
  const maxVal = Math.max(...arr);

  // Compute the exponentials of the array values
  const exps = arr.map(x => Math.exp(x - maxVal));

  // Compute the sum of the exponentials
  // @ts-ignore
  const sumExps = exps.reduce((acc, val) => acc + val, 0);

  // Compute the softmax values
  const softmaxArr = exps.map(x => x / sumExps);

  return softmaxArr;
}


/**
 * Detects if a given URL points to a PDF file by checking 
 * the stream's first bytes for %PDF-  then ends  the request.
 * Useful for hidden pdf url that does not end with pdf
 * @param {string} url - The URL to check.
 * @returns {Promise&lt;boolean>} True if the URL points to a PDF, false otherwise.
 */
export async function isUrlPDF(url) {
  let response;
  try {
    // Fetch the URL with a stream response
    response = await fetch(url);
    

    const reader = response.body.getReader();
    const chunk = new Uint8Array(5);
    let bytesRead = 0;

    while (bytesRead &lt; 5) {
      const { value, done } = await reader.read();
      
      if (done) break;

      const remainingBytes = 5 - bytesRead;
      const bytesToCopy = Math.min(remainingBytes, value.length);
      
      chunk.set(value.subarray(0, bytesToCopy), bytesRead);
      bytesRead += bytesToCopy;
    }

    // Check if we read 5 bytes and if they match the PDF signature
    return bytesRead === 5 &amp;&amp; 
           chunk[0] === 0x25 &amp;&amp; // %
           chunk[1] === 0x50 &amp;&amp; // P
           chunk[2] === 0x44 &amp;&amp; // D
           chunk[3] === 0x46 &amp;&amp; // F
           chunk[4] === 0x2D;   // -

  } catch (error) {
    console.error('Error checking URL:', error);
    return false;
  } 
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
