

<!DOCTYPE html>
<html lang="en">

<head>
  <script async src= "https://www.googletagmanager.com/gtag/js?id=G-E5TZ32BZDF "></script> <script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-E5TZ32BZDF'); </script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Research Agent - Docs tokenize/sentences.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">AI Research Agent</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/vtempest/ai-research-agent"
                        >
                            Github
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://wiki-phrases-tokenizer.vtempest.workers.dev"
                        >
                            Demo
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>Extractor</h2><h3>Global</h3><ul><li><a href="global.html#convertHTMLSpecialChars">convertHTMLSpecialChars</a></li><li><a href="global.html#convertHTMLToBasicHTML">convertHTMLToBasicHTML</a></li><li><a href="global.html#convertHTMLToTokens">convertHTMLToTokens</a></li><li><a href="global.html#convertURLToDomain">convertURLToDomain</a></li><li><a href="global.html#extract">extract</a></li><li><a href="global.html#extractCite">extractCite</a></li><li><a href="global.html#extractFavicon">extractFavicon</a></li><li><a href="global.html#extractNamedEntity">extractNamedEntity</a></li><li><a href="global.html#extractNamedEntityParts">extractNamedEntityParts</a></li><li><a href="global.html#extractPDF">extractPDF</a></li><li><a href="global.html#extractYoutubeText">extractYoutubeText</a></li><li><a href="global.html#fetchURL">fetchURL</a></li><li><a href="global.html#isUrlPDF">isUrlPDF</a></li></ul></div><div class="category"><h2>Math</h2><h3>Global</h3><ul><li><a href="global.html#calculateCosineSimilarity">calculateCosineSimilarity</a></li><li><a href="global.html#calculateSimilarityByCharacter">calculateSimilarityByCharacter</a></li><li><a href="global.html#calculateSoftmax">calculateSoftmax</a></li><li><a href="global.html#calculateStandardDeviation">calculateStandardDeviation</a></li></ul></div><div class="category"><h2>Relevance</h2><h3>Global</h3><ul><li><a href="global.html#calculatePhraseSpecificity">calculatePhraseSpecificity</a></li><li><a href="global.html#matchQUASAR">matchQUASAR</a></li><li><a href="global.html#vectorizeTextAsConcept">vectorizeTextAsConcept</a></li><li><a href="global.html#weighRelevanceConceptVector">weighRelevanceConceptVector</a></li><li><a href="global.html#weighRelevanceTermFrequency">weighRelevanceTermFrequency</a></li></ul></div><div class="category"><h2>Search</h2><h3>Global</h3><ul><li><a href="global.html#searchSTREAM">searchSTREAM</a></li><li><a href="global.html#searchWeb">searchWeb</a></li><li><a href="global.html#searchWikipedia">searchWikipedia</a></li></ul></div><div class="category"><h2>Tokenize</h2><h3>Global</h3><ul><li><a href="global.html#autocompleteNextWords">autocompleteNextWords</a></li><li><a href="global.html#isStopWord">isStopWord</a></li><li><a href="global.html#splitSentences">splitSentences</a></li><li><a href="global.html#stemRootWord">stemRootWord</a></li><li><a href="global.html#tokenizeTopics">tokenizeTopics</a></li></ul></div><div class="category"><h2>Topics</h2><h3>Global</h3><ul><li><a href="global.html#extractSEEKTOPIC">extractSEEKTOPIC</a></li><li><a href="global.html#rankSentencesCentralToKeyphrase">rankSentencesCentralToKeyphrase</a></li><li><a href="global.html#weighTopicDirichletDistribution">weighTopicDirichletDistribution</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>tokenize/sentences.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Splits text into sentences, handling abbreviations from 222 common list 
 * and infering acronyms, numbers, URLs, times, names, etc. 
 * 
 * @param {string} inputText - The text to be split into sentences.
 * @param {Object} options - Options for sentence splitting.
 * @param {boolean} options.splitOnNewlines=true - Split on newlines and markdown line breaks.
 * @param {boolean} options.splitOnHtmlTags=true - Split on HTML tags like P, DIV, UL, OL.
 * @param {number} options.minSize=20 - Minimum size for a sentence.
 * @param {number} options.maxSize=600 - Maximum size for a sentence.
 * @returns {Array&lt;string>} An array of sentences.
 * @category Tokenize
 */
export function splitSentences(inputText, options = {}) {
  const {
    splitOnNewlines = true,
    splitOnHtmlTags = true,
    minSize = 20,
    maxSize = 500,
  } = options;

    // List of 222 common abbreviations for various categories
  const COMMON_ABBR_LIST = (
    "adj,adm,adv,al,ala,alta,apr,arc,ariz,ark,art,assn,asst,attys,aug,ave,ba," +
    "bart,bld,bldg,blvd,brig,bros,bsc,btw,cal,calif,capt,cc,cell,ch,cl,cmdr,co,col,colo,comdr,con," +
    "conn,corp,cpl,cres,ct,dak,dec,del,dem,dept,det,dist,dphil,dr,drs,ed,eg,ens,eq,eqs,esp,esq,est," +
    "etc,ex,exp,expy,ext,feb,fed,fig,figs,fla,fri,ft,fwy,fy,ga,gen,gov,hon,hosp,hr,hrs,hway,hwy,ia,id," +
    "ida,ie,ill,inc,ind,ing,insp,is,jan,jr,jul,jun,kan,kans,ken,kg,km,kmph,ky,la,lt,ltd,ma,maj,man," +
    "mar,mass,may,md,me,med,messrs,mex,mfg,mi,mich,min,minn,miss,mlle,mm,mme,mo,mol,mont,mr,mrs,ms," +
    "msc,msgr,mssrs,mt,mtn,neb,nebr,nev,no,nos,nov,nr,oct,ok,okla,ont,op,ord,ore,p,pa,pd,pde,penn," +
    "penna,pfc,ph,phd,pl,plz,pop,pp,prof,pvt,que,rd,ref,refs,rep,repr,reps,res,rev,rs,rt,sask,sat," +
    "sec,secs,sen,sens,sep,sept,sfc,sgt,sr,st,sun,supt,surg,tce,tenn,tex,th,thu,thur,thurs,trans,tu," +
    "tue,tues,univ,us,usafa,ut,v,va,ver,viz,vol,vs,vt,wash,wed,wis,wisc,wy,wyo"
  ).split(",");

  const LINEBREAK_MARKER = " @~@ ";
  const LINEBREAK_MARKER_TRIMMED = LINEBREAK_MARKER.trim();

  const NON_EMPTY_REGEX = /\S/;
  const LINEBREAK_BOUNDARY_REGEX = /\n+|[-#=_+*]{4,}/g;
  const WORD_TOKENIZE_REGEX = /\S+|\n/g;

  // Validate input
  if (
    !inputText ||
    typeof inputText !== "string" ||
    !inputText.length ||
    !NON_EMPTY_REGEX.test(inputText)
  ) {
    return [];
  }

  // Preprocess text
  let processedText = inputText;
  if (splitOnNewlines) {
    processedText = processedText.replace(
      LINEBREAK_BOUNDARY_REGEX,
      LINEBREAK_MARKER
    );
  }

  if (splitOnHtmlTags) {
    const htmlTagsToSplit = ["p", "div", "ul", "ol"];
    const htmlSplitRegex = new RegExp(
      `(&lt;br\\s*\\/?>|&lt;\\/(${htmlTagsToSplit.join("|")})>)`,
      "g"
    );
    processedText = processedText.replace(
      htmlSplitRegex,
      `$1${LINEBREAK_MARKER}`
    );
  }

  // Tokenize text
  const tokens = processedText.trim().match(WORD_TOKENIZE_REGEX);

  if (!tokens || !tokens.length) {
    return [];
  }

  // Detect sentence boundaries
  const sentenceGroups = [];
  let currentGroup = [];
  let wordCounter = 0;

  for (let i = 0; i &lt; tokens.length; i++) {
    const token = tokens[i];

    wordCounter++;
    currentGroup.push(token);

    if (token.includes(",")) {
      wordCounter = 0;
    }

    if (
      isSentenceEnd(token) ||
      hasEndPunctuation(token, "?!") ||
      token === LINEBREAK_MARKER_TRIMMED
    ) {
      if (
        (splitOnNewlines || splitOnHtmlTags) &amp;&amp;
        token === LINEBREAK_MARKER_TRIMMED
      ) {
        currentGroup.pop();
      }

      sentenceGroups.push(currentGroup);
      currentGroup = [];
      wordCounter = 0;
      continue;
    }

    if (hasEndPunctuation(token, '"') || hasEndPunctuation(token, "'")) {
      tokens[i] = token.slice(0, -1);
    }

    if (hasEndPunctuation(token, ".")) {
      if (i + 1 &lt; tokens.length) {
        // Handle special cases for periods
        if (token.length === 2 &amp;&amp; isNaN(token.charAt(0))) {
          continue;
        }

        if (isInCommonAbbreviationList(token, COMMON_ABBR_LIST)) {
          continue;
        }

        if (isBeginsNewSentence(tokens[i + 1])) {
          if (isAbbreviatedTime(token, tokens[i + 1])) {
            continue;
          }

          if (isAbbreviatedName(wordCounter, tokens.slice(i, i + 6))) {
            continue;
          }

          if (isNumeric(tokens[i + 1])) {
            if (isCustomAbbreviation(token)) {
              continue;
            }
          }
        } else {
          if (endsWith(token, "..")) {
            continue;
          }

          if (isComplexAbbreviation(token)) {
            continue;
          }

          if (isAbbreviatedName(wordCounter, tokens.slice(i, i + 5))) {
            continue;
          }
        }
      }

      sentenceGroups.push(currentGroup);
      currentGroup = [];
      wordCounter = 0;
      continue;
    }

    const periodIndex = token.indexOf(".");
    if (periodIndex > -1) {
      if (isNumeric(token, periodIndex)) {
        continue;
      }

      if (isComplexAbbreviation(token)) {
        continue;
      }

      if (isValidUrl(token) || isPhoneNumber(token)) {
        continue;
      }
    }

    const splitResult = splitConcatenatedSentences(token);
    if (splitResult) {
      currentGroup.pop();
      currentGroup.push(splitResult[0]);
      sentenceGroups.push(currentGroup);
      currentGroup = [splitResult[1]];
      wordCounter = 0;
    }
  }

  if (currentGroup.length) {
    sentenceGroups.push(currentGroup);
  }

  // Post-process sentence groups
  const finalResult = sentenceGroups
    .filter((group) => group.length > 0)
    .reduce((output, group, index) => {
      if (index === 0) {
        output.push(group);
        return output;
      }

      const previousGroup = output[output.length - 1];

      // Check for short abbreviations that might have been split incorrectly
      if (
        previousGroup.length === 1 &amp;&amp;
        /^.{1,2}[.]$/.test(previousGroup[0]) &amp;&amp;
        !/[.]/.test(group[0])
      ) {
        output[output.length - 1] = previousGroup.concat(group);
      } else {
        output.push(group);
      }

      return output;
    }, []);

  // Join tokens back into sentences and apply size constraints
  return finalResult
    .map((group, index) => {
      let sentence = group.join(" ");

      // Apply minSize and maxSize constraints
      if (sentence.length &lt; minSize) {
        // If the sentence is too short, combine it with the next one if possible
        if (index &lt; finalResult.length - 1) {
          finalResult[index + 1] = group.concat(finalResult[index + 1]);
          return null;
        }
      } else if (sentence.length > maxSize) {
        // If the sentence is too long, split it at the last punctuation mark before maxSize
        const lastPunctuation = sentence.lastIndexOf(".", maxSize);
        if (lastPunctuation === -1) 
          return sliceIntoChunks(sentence, maxSize);
        if (lastPunctuation > minSize) {
          finalResult.splice(
            index + 1,
            0,
            sentence
              .slice(lastPunctuation + 1)
              .trim()
              .split(" ")
          );
          return sentence.slice(0, lastPunctuation + 1);
        }
      }

      return sentence;
    })
    .flat()
    .filter(Boolean); // Remove null entries from combining short sentences
}

function sliceIntoChunks(str, maxSize) {
  const chunks = [];
  let startIndex = 0;

  while (startIndex &lt; str.length) {
    let endIndex = startIndex + maxSize;
    
    if (endIndex &lt; str.length) {
      // Look for the last space within the last 20 characters
      let lastSpaceIndex = str.lastIndexOf(' ', endIndex);
      let searchStartIndex = Math.max(startIndex, endIndex - 20);
      
      if (lastSpaceIndex >= searchStartIndex) {
        endIndex = lastSpaceIndex;
      }
    } else {
      endIndex = str.length;
    }

    chunks.push(str.slice(startIndex, endIndex).trim());
    startIndex = endIndex + 1; // Skip the space
  }

  return chunks;
}

/**
 * Checks if a word ends with a specific character or characters.
 * @param {string} word - The word to check.
 * @param {string} char - The character(s) to check for at the end of the word.
   * @private
* @returns {boolean} True if the word ends with the specified character(s), false otherwise.
 */
function hasEndPunctuation(word, char) {
  return char.length > 1
    ? char.includes(word.slice(-1))
    : word.slice(-1) === char;
}

/**
 * Checks if a word ends with a specific string.
 * @param {string} word - The word to check.
 * @param {string} ending - The ending string to check for.
 * @returns {boolean} True if the word ends with the specified string, false otherwise.
  * @private
 */
function endsWith(word, ending) {
  return word.slice(word.length - ending.length) === ending;
}

/**
 * Checks if a string is capitalized or a number.
 * @param {string} str - The string to check.
 * @returns {boolean} True if the string is capitalized or a number, false otherwise.
  * @private
 */
function isCapitalizedOrNumeric(str) {
  return /^[A-Z][a-z].*/.test(str) || isNumeric(str);
}

/**
 * Checks if a string is likely to begin a new sentence.
 * @param {string} str - The string to check.
 * @returns {boolean} True if the string is likely to begin a new sentence, false otherwise.
  * @private
*/
function isBeginsNewSentence(str) {
  return isCapitalizedOrNumeric(str) || /``|"|'/.test(str.substring(0, 2));
}

/**
 * Checks if a string is in the list of common abbreviations.
 * @param {string} str - The string to check.
 * @returns {boolean} True if the string is a common abbreviation, false otherwise.
  * @private
*/
function isInCommonAbbreviationList(str, COMMON_ABBR_LIST) {
  const cleaned = str
    .toLowerCase()
    .replace(/[-'`~!@#$%^&amp;*()_|+=?;:'",.&lt;>\{\}\[\]\\\/]/gi, "");
  return COMMON_ABBR_LIST.includes(cleaned);
}

/**
 * Checks if a word is an abbreviated time (a.m. or p.m.) followed by 'day'.
 * @param {string} word - The current word.
 * @param {string} nextWord - The next word in the sequence.
 * @returns {boolean} True if it's an abbreviated time followed by 'day', false otherwise.
  * @private
*/
function isAbbreviatedTime(word, nextWord) {
  if (word === "a.m." || word === "p.m.") {
    const nextWordEnd = nextWord.replace(/\W+/g, "").slice(-3).toLowerCase();
    return nextWordEnd === "day";
  }
  return false;
}

/**
 * Checks if a word or phrase is a complex abbreviation.
 * @param {string} word - The word or phrase to check.
 * @returns {boolean} True if it's a complex abbreviation, false otherwise.
  * @private
*/
function isComplexAbbreviation(word) {
  // Check for common multi-part abbreviations like U.S. or U.K.
  if (/^([A-Za-z]\.){2,}[A-Za-z]?\.?(\s*\([^)]+\))?$/.test(word)) {
    return true;
  }

  const cleaned = word.replace(/[\(\)\[\]\{\}]/g, "");
  const matches = cleaned.match(/(.\.)*/);
  return matches &amp;&amp; matches[0].length > 0;
}

/**
 * Checks if a string is a custom abbreviation (short or capitalized).
 * @param {string} str - The string to check.
 * @returns {boolean} True if it's a custom abbreviation, false otherwise.
  * @private
*/
function isCustomAbbreviation(str) {
  return str.length &lt;= 3 || isCapitalizedOrNumeric(str);
}

/**
 * Checks if a sequence of words represents an abbreviated name.
 * @param {number} wordCount - The current word count in the sentence.
 * @param {string[]} words - A sequence of words to check.
 * @returns {boolean} True if the sequence represents an abbreviated name, false otherwise.
 * @private
 */
function isAbbreviatedName(wordCount, words) {
  if (words.length > 0) {
    if (
      wordCount &lt; 5 &amp;&amp;
      words[0].length &lt; 6 &amp;&amp;
      isCapitalizedOrNumeric(words[0])
    ) {
      return true;
    }
    const capitalizedCount = words.filter((str) =>
      /[A-Z]/.test(str.charAt(0))
    ).length;
    return capitalizedCount >= 3;
  }
  return false;
}

/**
 * Checks if a string is numeric, optionally starting from a specific position.
 * @param {string} str - The string to check.
 * @param {number} [startPos] - The position to start checking from.
 * @returns {boolean} True if the string is numeric, false otherwise.
  * @private
*/
function isNumeric(str, startPos) {
  if (startPos != null) {
    str = str.slice(startPos - 1, startPos + 2);
  }
  return !isNaN(str);
}

/**
 * Checks if a string matches a phone number pattern.
 * @param {string} str - The string to check.
 * @returns {boolean} True if the string matches a phone number pattern, false otherwise.
 * @private
 */
function isPhoneNumber(str) {
  const phoneRegex =
    /^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/;
  return phoneRegex.test(str);
}

/**
 * Checks if a string is a valid URL.
 * @param {string} str - The string to check.
 * @returns {boolean} True if the string is a valid URL, false otherwise.
 * @private
 */
function isValidUrl(str) {
  const urlRegex =
    /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/;
  return urlRegex.test(str);
}

/**
 * Attempts to split a word that might contain multiple sentences.
 * @param {string} word - The word to check and potentially split.
 * @returns {string[]|false} An array with the split parts if found, false otherwise.
 * @private
 */
function splitConcatenatedSentences(word) {
  const boundaryIndex = word.search(/[.!?]/);
  if (boundaryIndex > -1 &amp;&amp; boundaryIndex &lt; word.length - 1) {
    const nextChar = word.charAt(boundaryIndex + 1);
    if (nextChar.match(/[a-zA-Z]/)) {
      return [word.slice(0, boundaryIndex + 1), word.slice(boundaryIndex + 1)];
    }
  }
  return false;
}

/**
 * Checks if a token is a sentence boundary character.
 * @param {string} token - The token to check.
 * @returns {boolean} True if the token is a sentence boundary character, false otherwise.
 * @private
 */
function isSentenceEnd(token) {
  return [".", "!", "?"].includes(token);
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
